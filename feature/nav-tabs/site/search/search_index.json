{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Crystal Programming Language \u00b6 Welcome to the language reference for the Crystal programming language! Crystal is a programming language with the following goals: Have a syntax similar to Ruby (but compatibility with it is not a goal). Be statically type-checked, but without having to specify the type of variables or method parameters. Be able to call C code by writing bindings to it in Crystal. Have compile-time evaluation and generation of code, to avoid boilerplate code. Compile to efficient native code. From here, you can jump to anywhere you want in this document. Although, if you are new to the Crystal Language, we suggest that you continue reading the Getting started section. Crystal's standard library is documented in the API docs .","title":"Home"},{"location":"index.html#crystal-programming-language","text":"Welcome to the language reference for the Crystal programming language! Crystal is a programming language with the following goals: Have a syntax similar to Ruby (but compatibility with it is not a goal). Be statically type-checked, but without having to specify the type of variables or method parameters. Be able to call C code by writing bindings to it in Crystal. Have compile-time evaluation and generation of code, to avoid boilerplate code. Compile to efficient native code. From here, you can jump to anywhere you want in this document. Although, if you are new to the Crystal Language, we suggest that you continue reading the Getting started section. Crystal's standard library is documented in the API docs .","title":"Crystal Programming Language"},{"location":"SUMMARY.html","text":"Summary \u00b6 Home Getting started An HTTP Server A Command Line Application Using the compiler The shards command Coding style Platform Support Language Specification About this guide Comments Documenting code Literals Nil Bool Integers Floats Char String Symbol Array Hash Range Regex Tuple NamedTuple Proc Command Assignment Local variables Control expressions Truthy and falsey values if As a suffix As an expression Ternary if if var if var.is_a?(...) if var.responds_to?(...) if var.nil? if ! unless case while break next until && || Requiring files Types and methods Everything is an object The Program Classes and methods new, initialize and allocate Methods and instance variables Type inference Union types Overloading Default parameter values and named arguments Splats and tuples Type restrictions Return types Method arguments Operators Visibility Inheritance Virtual and abstract types Class methods Class variables finalize Modules Generics Structs Constants Enums Blocks and Procs Capturing blocks Proc literal Block forwarding Closures alias Exception handling Type grammar Type reflection is_a? nil? responds_to? as as? typeof Macros Macro methods Hooks Fresh variables Annotations Built-in annotations Low-level primitives pointerof sizeof instance_sizeof offsetof Uninitialized variable declaration Compile-time flags Cross-compilation C bindings lib fun out to_unsafe struct union enum Variables Constants type alias Callbacks Unsafe code Guides Performance Concurrency Testing Writing Shards Hosting on GitHub Hosting on GitLab Continuous Integration Using Travis CI Using CircleCI Static Linking Database Connection Connection pool Transactions Tutorials","title":"Summary"},{"location":"SUMMARY.html#summary","text":"Home Getting started An HTTP Server A Command Line Application Using the compiler The shards command Coding style Platform Support Language Specification About this guide Comments Documenting code Literals Nil Bool Integers Floats Char String Symbol Array Hash Range Regex Tuple NamedTuple Proc Command Assignment Local variables Control expressions Truthy and falsey values if As a suffix As an expression Ternary if if var if var.is_a?(...) if var.responds_to?(...) if var.nil? if ! unless case while break next until && || Requiring files Types and methods Everything is an object The Program Classes and methods new, initialize and allocate Methods and instance variables Type inference Union types Overloading Default parameter values and named arguments Splats and tuples Type restrictions Return types Method arguments Operators Visibility Inheritance Virtual and abstract types Class methods Class variables finalize Modules Generics Structs Constants Enums Blocks and Procs Capturing blocks Proc literal Block forwarding Closures alias Exception handling Type grammar Type reflection is_a? nil? responds_to? as as? typeof Macros Macro methods Hooks Fresh variables Annotations Built-in annotations Low-level primitives pointerof sizeof instance_sizeof offsetof Uninitialized variable declaration Compile-time flags Cross-compilation C bindings lib fun out to_unsafe struct union enum Variables Constants type alias Callbacks Unsafe code Guides Performance Concurrency Testing Writing Shards Hosting on GitHub Hosting on GitLab Continuous Integration Using Travis CI Using CircleCI Static Linking Database Connection Connection pool Transactions Tutorials","title":"Summary"},{"location":"platform_support.html","text":"Crystal Platform Support \u00b6 The Crystal compiler runs on, and compiles to, a great number of platforms, though not all platforms are equally supported. Crystal\u2019s support levels are organized into three tiers, each with a different set of guarantees. Platforms are identified by their \u201ctarget triple\u201d which is the string to inform the compiler what kind of output should be produced. The columns below indicate whether the corresponding component works on the specified platform. Tier 1 \u00b6 Tier 1 platforms can be thought of as \u201cguaranteed to work\u201d. Specifically they will each satisfy the following requirements: Official binary releases are provided for the platform. Automated testing is set up to run tests for the platform. Documentation for how to use and how to build the platform is available. Target Compiler Std Description x86_64-darwin \u2713 \u2713 64-bit OSX (10.7+, Lion+) x86_64-linux-gnu \u2713 \u2713 64-bit Linux (2.6.18+) i386-linux-gnu \u2713 \u2713 32-bit Linux (2.6.18+) Tier 2 \u00b6 Tier 2 platforms can be thought of as \u201cexpected to build\u201d. Automated tests are not run so it\u2019s not guaranteed to produce a working build, but platforms often work to quite a good degree and patches are always welcome! Target Compiler Std Description aarch64-linux-gnu \u2713 \u2713 ARM 64-bit Linux (GNU, hardfloat) aarch64-linux-musl \u2713 \u2713 ARM 64-bit Linux (MUSL, hardfloat) arm-linux-gnueabihf \u2713 \u2713 ARM 32-bit Linux (GNU, hardfloat) i386-linux-musl \u2713 \u2713 32-bit Linux (MUSL) x86_64-linux-musl \u2713 \u2713 64-bit Linux (MUSL) x86_64-openbsd \u2713 \u2713 64-bit OpenBSD (6.x) x86_64-freebsd \u2713 \u2713 64-bit FreeBSD (11.x) Tier 3 \u00b6 Tier 3 platforms are those which the Crystal codebase has some sort of support for, but which are not built or tested automatically, and may not work. Official builds are not available. Target Compiler Std Description x86_64-windows-msvc 64-bit MSVC (Windows 7+) aarch64-darwin ARM 64-bit OSX (Apple Silicon) x86_64-unknown-dragonfly 64-bit DragonFlyBSD x86_64-unknown-netbsd 64-bit NetBSD Note: big thanks go to the Rust team for putting together such a clear doc on Rust's platform support. We felt it was so close to what we were needing in Crystal, that we basically copied many chunks of their document. See https://forge.rust-lang.org/platform-support.html .","title":"Platform Support"},{"location":"platform_support.html#crystal-platform-support","text":"The Crystal compiler runs on, and compiles to, a great number of platforms, though not all platforms are equally supported. Crystal\u2019s support levels are organized into three tiers, each with a different set of guarantees. Platforms are identified by their \u201ctarget triple\u201d which is the string to inform the compiler what kind of output should be produced. The columns below indicate whether the corresponding component works on the specified platform.","title":"Crystal Platform Support"},{"location":"platform_support.html#tier-1","text":"Tier 1 platforms can be thought of as \u201cguaranteed to work\u201d. Specifically they will each satisfy the following requirements: Official binary releases are provided for the platform. Automated testing is set up to run tests for the platform. Documentation for how to use and how to build the platform is available. Target Compiler Std Description x86_64-darwin \u2713 \u2713 64-bit OSX (10.7+, Lion+) x86_64-linux-gnu \u2713 \u2713 64-bit Linux (2.6.18+) i386-linux-gnu \u2713 \u2713 32-bit Linux (2.6.18+)","title":"Tier 1"},{"location":"platform_support.html#tier-2","text":"Tier 2 platforms can be thought of as \u201cexpected to build\u201d. Automated tests are not run so it\u2019s not guaranteed to produce a working build, but platforms often work to quite a good degree and patches are always welcome! Target Compiler Std Description aarch64-linux-gnu \u2713 \u2713 ARM 64-bit Linux (GNU, hardfloat) aarch64-linux-musl \u2713 \u2713 ARM 64-bit Linux (MUSL, hardfloat) arm-linux-gnueabihf \u2713 \u2713 ARM 32-bit Linux (GNU, hardfloat) i386-linux-musl \u2713 \u2713 32-bit Linux (MUSL) x86_64-linux-musl \u2713 \u2713 64-bit Linux (MUSL) x86_64-openbsd \u2713 \u2713 64-bit OpenBSD (6.x) x86_64-freebsd \u2713 \u2713 64-bit FreeBSD (11.x)","title":"Tier 2"},{"location":"platform_support.html#tier-3","text":"Tier 3 platforms are those which the Crystal codebase has some sort of support for, but which are not built or tested automatically, and may not work. Official builds are not available. Target Compiler Std Description x86_64-windows-msvc 64-bit MSVC (Windows 7+) aarch64-darwin ARM 64-bit OSX (Apple Silicon) x86_64-unknown-dragonfly 64-bit DragonFlyBSD x86_64-unknown-netbsd 64-bit NetBSD Note: big thanks go to the Rust team for putting together such a clear doc on Rust's platform support. We felt it was so close to what we were needing in Crystal, that we basically copied many chunks of their document. See https://forge.rust-lang.org/platform-support.html .","title":"Tier 3"},{"location":"conventions/coding_style.html","text":"Coding Style \u00b6 This style is used in the standard library. You can use it in your own project to make it familiar to other developers. Naming \u00b6 Type names are camelcased. For example: class ParseError < Exception end module HTTP class RequestHandler end end alias NumericValue = Float32 | Float64 | Int32 | Int64 lib LibYAML end struct TagDirective end enum Time:: DayOfWeek end Method names are underscore-cased. For example: class Person def first_name end def date_of_birth end def homepage_url end end Variable names are underscore-cased. For example: class Greeting @@default_greeting = \"Hello world\" def initialize ( @custom_greeting = nil ) end def print_greeting greeting = @custom_greeting || @@default_greeting puts greeting end end Constants are screaming-cased. For example: LUCKY_NUMBERS = [ 3 , 7 , 11 ] DOCUMENTATION_URL = \"http://crystal-lang.org/docs\" Acronyms \u00b6 In class names, acronyms are all-uppercase . For example, HTTP , and LibXML . In method names, acronyms are all-lowercase . For example #from_json , #to_io . Libs \u00b6 Lib names are prefixed with Lib . For example: LibC , LibEvent2 . Directory and File Names \u00b6 Within a project: / contains a readme, any project configurations (eg, CI or editor configs), and any other project-level documentation (eg, changelog or contributing guide). src/ contains the project's source code. spec/ contains the project's specs , which can be run with crystal spec . bin/ contains any executables. File paths match the namespace of their contents. Files are named after the class or namespace they define, with underscore-case . For example, HTTP::WebSocket is defined in src/http/web_socket.cr . Whitespace \u00b6 Use two spaces to indent code inside namespaces, methods, blocks or other nested contexts. For example: module Scorecard class Parser def parse ( score_text ) begin score_text . scan ( SCORE_PATTERN ) do | match | handle_match ( match ) end rescue err : ParseError # handle error ... end end end end Within a class, separate method definitions, constants and inner class definitions with one newline . For example: module Money CURRENCIES = { \"EUR\" => 1.0 , \"ARS\" => 10.55 , \"USD\" => 1.12 , \"JPY\" => 134.15 , } class Amount getter :currency , :value def initialize ( @currency , @value ) end end class CurrencyConversion def initialize ( @amount , @target_currency ) end def amount # implement conversion ... end end end","title":"Coding style"},{"location":"conventions/coding_style.html#coding-style","text":"This style is used in the standard library. You can use it in your own project to make it familiar to other developers.","title":"Coding Style"},{"location":"conventions/coding_style.html#naming","text":"Type names are camelcased. For example: class ParseError < Exception end module HTTP class RequestHandler end end alias NumericValue = Float32 | Float64 | Int32 | Int64 lib LibYAML end struct TagDirective end enum Time:: DayOfWeek end Method names are underscore-cased. For example: class Person def first_name end def date_of_birth end def homepage_url end end Variable names are underscore-cased. For example: class Greeting @@default_greeting = \"Hello world\" def initialize ( @custom_greeting = nil ) end def print_greeting greeting = @custom_greeting || @@default_greeting puts greeting end end Constants are screaming-cased. For example: LUCKY_NUMBERS = [ 3 , 7 , 11 ] DOCUMENTATION_URL = \"http://crystal-lang.org/docs\"","title":"Naming"},{"location":"conventions/coding_style.html#acronyms","text":"In class names, acronyms are all-uppercase . For example, HTTP , and LibXML . In method names, acronyms are all-lowercase . For example #from_json , #to_io .","title":"Acronyms"},{"location":"conventions/coding_style.html#libs","text":"Lib names are prefixed with Lib . For example: LibC , LibEvent2 .","title":"Libs"},{"location":"conventions/coding_style.html#directory-and-file-names","text":"Within a project: / contains a readme, any project configurations (eg, CI or editor configs), and any other project-level documentation (eg, changelog or contributing guide). src/ contains the project's source code. spec/ contains the project's specs , which can be run with crystal spec . bin/ contains any executables. File paths match the namespace of their contents. Files are named after the class or namespace they define, with underscore-case . For example, HTTP::WebSocket is defined in src/http/web_socket.cr .","title":"Directory and File Names"},{"location":"conventions/coding_style.html#whitespace","text":"Use two spaces to indent code inside namespaces, methods, blocks or other nested contexts. For example: module Scorecard class Parser def parse ( score_text ) begin score_text . scan ( SCORE_PATTERN ) do | match | handle_match ( match ) end rescue err : ParseError # handle error ... end end end end Within a class, separate method definitions, constants and inner class definitions with one newline . For example: module Money CURRENCIES = { \"EUR\" => 1.0 , \"ARS\" => 10.55 , \"USD\" => 1.12 , \"JPY\" => 134.15 , } class Amount getter :currency , :value def initialize ( @currency , @value ) end end class CurrencyConversion def initialize ( @amount , @target_currency ) end def amount # implement conversion ... end end end","title":"Whitespace"},{"location":"database/index.html","text":"Database \u00b6 To access a relational database you will need a shard designed for the database server you want to use. The package crystal-lang/crystal-db offers a unified api across different drivers. The following packages are compliant with crystal-db crystal-lang/crystal-sqlite3 for sqlite crystal-lang/crystal-mysql for mysql & mariadb will/crystal-pg for postgres This guide presents the api of crystal-db, the sql commands might need to be adapted for the concrete driver due to differences between postgres, mysql and sqlite. Also some drivers may offer additional functionality like postgres LISTEN / NOTIFY . Installing the shard \u00b6 Choose the appropriate driver from the list above and add it as any shard to your application's shard.yml There is no need to explicitly require crystal-lang/crystal-db During this guide crystal-lang/crystal-mysql will be used. dependencies : mysql : github : crystal-lang/crystal-mysql Open database \u00b6 DB.open will allow you to easily connect to a database using a connection uri. The schema of the uri determines the expected driver. The following sample connects to a local mysql database named test with user root and password blank. require \"db\" require \"mysql\" DB . open \"mysql://root@localhost/test\" do | db | # ... use db to perform queries end Other connection uris are sqlite3:///path/to/data.db mysql://user:password@server:port/database postgres://server:port/database Alternatively you can use a non yielding DB.open method as long as Database#close is called at the end. require \"db\" require \"mysql\" db = DB . open \"mysql://root@localhost/test\" begin # ... use db to perform queries ensure db . close end Exec \u00b6 To execute sql statements you can use Database#exec db . exec \"create table contacts (name varchar(30), age int)\" To avoid SQL injection values can be provided as query parameters. The syntax for using query parameters depends on the database driver because they are typically just passed through to the database. MySQL uses ? for parameter expansion and assignment is based on argument order. PostgreSQL uses $n where n is the ordinal number of the argument (starting with 1). # MySQL db . exec \"insert into contacts values (?, ?)\" , \"John\" , 30 # Postgres db . exec \"insert into contacts values ($1, $2)\" , \"Sarah\" , 33 Query \u00b6 To perform a query and get the result set use Database#query , arguments can be used as in Database#exec . Database#query returns a ResultSet that needs to be closed. As in Database#open , if called with a block, the ResultSet will be closed implicitly. db . query \"select name, age from contacts order by age desc\" do | rs | rs . each do # ... perform for each row in the ResultSet end end When reading values from the database there is no type information during compile time that crystal can use. You will need to call rs.read(T) with the type T you expect to get from the database. db . query \"select name, age from contacts order by age desc\" do | rs | rs . each do name = rs . read ( String ) age = rs . read ( Int32 ) puts \" #{ name } ( #{ age } )\" # => Sarah (33) # => John Doe (30) end end There are many convenient query methods built on top of #query . You can read multiple columns at once: name , age = rs . read ( String , Int32 ) Or read a single row: name , age = db . query_one \"select name, age from contacts order by age desc limit 1\" , as : { String , Int32 } Or read a scalar value without dealing explicitly with the ResultSet: max_age = db . scalar \"select max(age) from contacts\" All available methods to perform statements in a database are defined in DB::QueryMethods .","title":"Database"},{"location":"database/index.html#database","text":"To access a relational database you will need a shard designed for the database server you want to use. The package crystal-lang/crystal-db offers a unified api across different drivers. The following packages are compliant with crystal-db crystal-lang/crystal-sqlite3 for sqlite crystal-lang/crystal-mysql for mysql & mariadb will/crystal-pg for postgres This guide presents the api of crystal-db, the sql commands might need to be adapted for the concrete driver due to differences between postgres, mysql and sqlite. Also some drivers may offer additional functionality like postgres LISTEN / NOTIFY .","title":"Database"},{"location":"database/index.html#installing-the-shard","text":"Choose the appropriate driver from the list above and add it as any shard to your application's shard.yml There is no need to explicitly require crystal-lang/crystal-db During this guide crystal-lang/crystal-mysql will be used. dependencies : mysql : github : crystal-lang/crystal-mysql","title":"Installing the shard"},{"location":"database/index.html#open-database","text":"DB.open will allow you to easily connect to a database using a connection uri. The schema of the uri determines the expected driver. The following sample connects to a local mysql database named test with user root and password blank. require \"db\" require \"mysql\" DB . open \"mysql://root@localhost/test\" do | db | # ... use db to perform queries end Other connection uris are sqlite3:///path/to/data.db mysql://user:password@server:port/database postgres://server:port/database Alternatively you can use a non yielding DB.open method as long as Database#close is called at the end. require \"db\" require \"mysql\" db = DB . open \"mysql://root@localhost/test\" begin # ... use db to perform queries ensure db . close end","title":"Open database"},{"location":"database/index.html#exec","text":"To execute sql statements you can use Database#exec db . exec \"create table contacts (name varchar(30), age int)\" To avoid SQL injection values can be provided as query parameters. The syntax for using query parameters depends on the database driver because they are typically just passed through to the database. MySQL uses ? for parameter expansion and assignment is based on argument order. PostgreSQL uses $n where n is the ordinal number of the argument (starting with 1). # MySQL db . exec \"insert into contacts values (?, ?)\" , \"John\" , 30 # Postgres db . exec \"insert into contacts values ($1, $2)\" , \"Sarah\" , 33","title":"Exec"},{"location":"database/index.html#query","text":"To perform a query and get the result set use Database#query , arguments can be used as in Database#exec . Database#query returns a ResultSet that needs to be closed. As in Database#open , if called with a block, the ResultSet will be closed implicitly. db . query \"select name, age from contacts order by age desc\" do | rs | rs . each do # ... perform for each row in the ResultSet end end When reading values from the database there is no type information during compile time that crystal can use. You will need to call rs.read(T) with the type T you expect to get from the database. db . query \"select name, age from contacts order by age desc\" do | rs | rs . each do name = rs . read ( String ) age = rs . read ( Int32 ) puts \" #{ name } ( #{ age } )\" # => Sarah (33) # => John Doe (30) end end There are many convenient query methods built on top of #query . You can read multiple columns at once: name , age = rs . read ( String , Int32 ) Or read a single row: name , age = db . query_one \"select name, age from contacts order by age desc limit 1\" , as : { String , Int32 } Or read a scalar value without dealing explicitly with the ResultSet: max_age = db . scalar \"select max(age) from contacts\" All available methods to perform statements in a database are defined in DB::QueryMethods .","title":"Query"},{"location":"database/connection.html","text":"Connection \u00b6 A connection is one of the key parts when working with databases. It represents the runway through which statements travel from our application to the database. In Crystal we have two ways of building this connection. And so, coming up next, we are going to present examples with some advice on when to use each one. DB module \u00b6 Give me a place to stand, and I shall move the earth. Archimedes The DB module, is our place to stand when working with databases in Crystal. As written in the documentation: is a unified interface for database access . One of the methods implemented in this module is DB#connect . Using this method is the first way for creating a connection. Let's see how to use it. DB#connect \u00b6 When using DB#connect we are indeed opening a connection to the database. The uri passed as the argument is used by the module to determine which driver to use (for example: mysql:// , postgres:// , sqlite:// , etc.) i.e. we do not need to specify which database we are using. The uri for this example is mysql://root:root@localhost/test , and so the module will use the mysql driver to connect to the MySQL database. Here is the example: require \"mysql\" cnn = DB . connect ( \"mysql://root:root@localhost/test\" ) puts typeof ( cnn ) # => DB::Connection cnn . close It's worth mentioning that the method returns a DB::Connection object. Although more specifically, it returns a MySql::Connection object, it doesn't matter because all types of connections should be polymorphic. So hereinafter we will work with a DB::Connection instance, helping us to abstract from specific issues of each database engine. When creating a connection manually (as we are doing here) we are responsible for managing this resource, and so we must close the connection when we are done using it. Regarding the latter, this little details can be the cause of huge bugs! Crystal, being a language for humans , give us a more safe way of manually creating a connection using blocks, like this: require \"mysql\" DB . connect \"mysql://root:root@localhost/test\" do | cnn | puts typeof ( cnn ) # => DB::Connection end # the connection will be closed here Ok, now we have a connection, let's use it! require \"mysql\" DB . connect \"mysql://root:root@localhost/test\" do | cnn | puts typeof ( cnn ) # => DB::Connection puts \"Connection closed: #{ cnn . closed? } \" # => false result = cnn . exec ( \"drop table if exists contacts\" ) puts result result = cnn . exec ( \"create table contacts (name varchar(30), age int)\" ) puts result cnn . transaction do | tx | cnn2 = tx . connection puts \"Yep, it is the same connection! #{ cnn == cnn2 } \" cnn2 . exec ( \"insert into contacts values ('Joe', 42)\" ) cnn2 . exec ( \"insert into contacts values (?, ?)\" , \"Sarah\" , 43 ) end cnn . query_each \"select * from contacts\" do | rs | puts \"name: #{ rs . read } , age: #{ rs . read } \" end end First, in this example, we are using a transaction (check the transactions section for more information on this topic) Second, it's important to notice that the connection given by the transaction is the same connection that we were working with, before the transaction begin. That is, there is only one connection at all times in our program. And last, we are using the method #exec and #query . You may read more about executing queries in the database section. Now that we have a good idea about creating a connection, let's present the second way for creating one: DB#open DB#open \u00b6 require \"mysql\" db = DB . open ( \"mysql://root:root@localhost/test\" ) puts typeof ( db ) # DB::Database db . close As with a connection, we should close the database once we don't need it anymore. Or instead, we could use a block and let Crystal close the database for us! But, where is the connection? Well, we should be asking for the connections . When a database is created, a pool of connections is created with connections to the database prepared and ready to use! (Do you want to read more about pool of connections ? In the connection pool section you may read all about this interesting topic!) How do we use a connection from the database object? For this, we could ask the database for a connection using the method Database#checkout . But, doing this will require to explicitly return the connection to the pool using Connection#release . Here is an example: require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | cnn = db . checkout puts typeof ( cnn ) puts \"Connection closed: #{ cnn . closed? } \" # => false cnn . release puts \"Connection closed: #{ cnn . closed? } \" # => false end And we want a safe way (i.e. no need for us to release the connection) to request and use a connection from the database , we could use Database#using_connection : require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | db . using_connection do | cnn | puts typeof ( cnn ) # use cnn end end In the next example we will let the database object to manage the connections by itself , like this: require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | db . exec ( \"drop table if exists contacts\" ) db . exec ( \"create table contacts (name varchar(30), age int)\" ) db . transaction do | tx | cnn = tx . connection cnn . exec ( \"insert into contacts values ('Joe', 42)\" ) cnn . exec ( \"insert into contacts values (?, ?)\" , \"Sarah\" , 43 ) end db . query_each \"select * from contacts\" do | rs | puts \"name: #{ rs . read } , age: #{ rs . read } \" end end As we may notice, the database is polymorphic with a connection object with regard to the #exec / #query / #transaction methods. The database is responsible for the use of the connections. Great! When to use one or the other? \u00b6 Given the examples, it may come to our attention that the number of connections is relevant . If we are programming a short living application with only one user starting requests to the database then a single connection managed by us (i.e. a DB::Connection object) should be enough (think of a command line application that receives parameters, then starts a request to the database and finally displays the result to the user) On the other hand, if we are building a system with many concurrent users and with heavy database access, then we should use a DB::Database object; which by using a connection pool will have a number of connections already prepared and ready to use (no bootstrap/initialization-time penalizations). Or imagine that you are building a long-living application (like a background job) then a connection pool will free you from the responsibility of monitoring the state of the connection: is it alive or does it need to reconnect?","title":"Connection"},{"location":"database/connection.html#connection","text":"A connection is one of the key parts when working with databases. It represents the runway through which statements travel from our application to the database. In Crystal we have two ways of building this connection. And so, coming up next, we are going to present examples with some advice on when to use each one.","title":"Connection"},{"location":"database/connection.html#db-module","text":"Give me a place to stand, and I shall move the earth. Archimedes The DB module, is our place to stand when working with databases in Crystal. As written in the documentation: is a unified interface for database access . One of the methods implemented in this module is DB#connect . Using this method is the first way for creating a connection. Let's see how to use it.","title":"DB module"},{"location":"database/connection.html#dbconnect","text":"When using DB#connect we are indeed opening a connection to the database. The uri passed as the argument is used by the module to determine which driver to use (for example: mysql:// , postgres:// , sqlite:// , etc.) i.e. we do not need to specify which database we are using. The uri for this example is mysql://root:root@localhost/test , and so the module will use the mysql driver to connect to the MySQL database. Here is the example: require \"mysql\" cnn = DB . connect ( \"mysql://root:root@localhost/test\" ) puts typeof ( cnn ) # => DB::Connection cnn . close It's worth mentioning that the method returns a DB::Connection object. Although more specifically, it returns a MySql::Connection object, it doesn't matter because all types of connections should be polymorphic. So hereinafter we will work with a DB::Connection instance, helping us to abstract from specific issues of each database engine. When creating a connection manually (as we are doing here) we are responsible for managing this resource, and so we must close the connection when we are done using it. Regarding the latter, this little details can be the cause of huge bugs! Crystal, being a language for humans , give us a more safe way of manually creating a connection using blocks, like this: require \"mysql\" DB . connect \"mysql://root:root@localhost/test\" do | cnn | puts typeof ( cnn ) # => DB::Connection end # the connection will be closed here Ok, now we have a connection, let's use it! require \"mysql\" DB . connect \"mysql://root:root@localhost/test\" do | cnn | puts typeof ( cnn ) # => DB::Connection puts \"Connection closed: #{ cnn . closed? } \" # => false result = cnn . exec ( \"drop table if exists contacts\" ) puts result result = cnn . exec ( \"create table contacts (name varchar(30), age int)\" ) puts result cnn . transaction do | tx | cnn2 = tx . connection puts \"Yep, it is the same connection! #{ cnn == cnn2 } \" cnn2 . exec ( \"insert into contacts values ('Joe', 42)\" ) cnn2 . exec ( \"insert into contacts values (?, ?)\" , \"Sarah\" , 43 ) end cnn . query_each \"select * from contacts\" do | rs | puts \"name: #{ rs . read } , age: #{ rs . read } \" end end First, in this example, we are using a transaction (check the transactions section for more information on this topic) Second, it's important to notice that the connection given by the transaction is the same connection that we were working with, before the transaction begin. That is, there is only one connection at all times in our program. And last, we are using the method #exec and #query . You may read more about executing queries in the database section. Now that we have a good idea about creating a connection, let's present the second way for creating one: DB#open","title":"DB#connect"},{"location":"database/connection.html#dbopen","text":"require \"mysql\" db = DB . open ( \"mysql://root:root@localhost/test\" ) puts typeof ( db ) # DB::Database db . close As with a connection, we should close the database once we don't need it anymore. Or instead, we could use a block and let Crystal close the database for us! But, where is the connection? Well, we should be asking for the connections . When a database is created, a pool of connections is created with connections to the database prepared and ready to use! (Do you want to read more about pool of connections ? In the connection pool section you may read all about this interesting topic!) How do we use a connection from the database object? For this, we could ask the database for a connection using the method Database#checkout . But, doing this will require to explicitly return the connection to the pool using Connection#release . Here is an example: require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | cnn = db . checkout puts typeof ( cnn ) puts \"Connection closed: #{ cnn . closed? } \" # => false cnn . release puts \"Connection closed: #{ cnn . closed? } \" # => false end And we want a safe way (i.e. no need for us to release the connection) to request and use a connection from the database , we could use Database#using_connection : require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | db . using_connection do | cnn | puts typeof ( cnn ) # use cnn end end In the next example we will let the database object to manage the connections by itself , like this: require \"mysql\" DB . open \"mysql://root:root@localhost/test\" do | db | db . exec ( \"drop table if exists contacts\" ) db . exec ( \"create table contacts (name varchar(30), age int)\" ) db . transaction do | tx | cnn = tx . connection cnn . exec ( \"insert into contacts values ('Joe', 42)\" ) cnn . exec ( \"insert into contacts values (?, ?)\" , \"Sarah\" , 43 ) end db . query_each \"select * from contacts\" do | rs | puts \"name: #{ rs . read } , age: #{ rs . read } \" end end As we may notice, the database is polymorphic with a connection object with regard to the #exec / #query / #transaction methods. The database is responsible for the use of the connections. Great!","title":"DB#open"},{"location":"database/connection.html#when-to-use-one-or-the-other","text":"Given the examples, it may come to our attention that the number of connections is relevant . If we are programming a short living application with only one user starting requests to the database then a single connection managed by us (i.e. a DB::Connection object) should be enough (think of a command line application that receives parameters, then starts a request to the database and finally displays the result to the user) On the other hand, if we are building a system with many concurrent users and with heavy database access, then we should use a DB::Database object; which by using a connection pool will have a number of connections already prepared and ready to use (no bootstrap/initialization-time penalizations). Or imagine that you are building a long-living application (like a background job) then a connection pool will free you from the responsibility of monitoring the state of the connection: is it alive or does it need to reconnect?","title":"When to use one or the other?"},{"location":"database/connection_pool.html","text":"Connection pool \u00b6 When a connection is established it usually means opening a TCP connection or Socket. The socket will handle one statement at a time. If a program needs to perform many queries simultaneously, or if it handles concurrent requests that aim to use a database, it will need more than one active connection. Since databases are separate services from the application using them, the connections might go down, the services might be restarted, and other sort of things the program might not want to care about. To address this issues usually a connection pool is a neat solution. When a database is opened with crystal-db there is already a connection pool working. DB.open returns a DB::Database object which manages the whole connection pool and not just a single connection. DB . open ( \"mysql://root@localhost/test\" ) do | db | # db is a DB::Database end When executing statements using db.query , db.exec , db.scalar , etc. the algorithm goes: Find an available connection in the pool. Create one if needed and possible. If the pool is not allowed to create a new connection, wait a for a connection to become available. But this wait should be aborted if it takes too long. Checkout that connection from the pool. Execute the SQL command. If there is no DB::ResultSet yielded, return the connection to the pool. Otherwise, the connection will be returned to the pool when the ResultSet is closed. Return the statement result. If a connection can't be created, or if a connection loss occurs while the statement is performed the above process is repeated. The retry logic only happens when the statement is sent through the DB::Database . If it is sent through a DB::Connection or DB::Transaction no retry is performed since the code will state that certain connection object was expected to be used. Configuration \u00b6 The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI. Name Default value initial_pool_size 1 max_pool_size 0 (unlimited) max_idle_pool_size 1 checkout_timeout 5.0 (seconds) retry_attempts 1 retry_delay 1.0 (seconds) When DB::Database is opened an initial number of initial_pool_size connections will be created. The pool will never hold more than max_pool_size connections. When returning/releasing a connection to the pool it will be closed if there are already max_idle_pool_size idle connections. If the max_pool_size was reached and a connection is needed, wait up to checkout_timeout seconds for an existing connection to become available. If a connection is lost or can't be established retry at most retry_attempts times waiting retry_delay seconds between each try. Sample \u00b6 The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions. # file: sample.cr require \"mysql\" DB . open \"mysql://root@localhost?retry_attempts=8&retry_delay=3\" do | db | loop do pp db . scalar ( \"SELECT NOW()\" ) sleep 0.5 end end $ crystal sample.cr db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:57 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:57 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:58 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:58 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:59 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:59 # stop mysql server for some seconds db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:06 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:06 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:07","title":"Connection pool"},{"location":"database/connection_pool.html#connection-pool","text":"When a connection is established it usually means opening a TCP connection or Socket. The socket will handle one statement at a time. If a program needs to perform many queries simultaneously, or if it handles concurrent requests that aim to use a database, it will need more than one active connection. Since databases are separate services from the application using them, the connections might go down, the services might be restarted, and other sort of things the program might not want to care about. To address this issues usually a connection pool is a neat solution. When a database is opened with crystal-db there is already a connection pool working. DB.open returns a DB::Database object which manages the whole connection pool and not just a single connection. DB . open ( \"mysql://root@localhost/test\" ) do | db | # db is a DB::Database end When executing statements using db.query , db.exec , db.scalar , etc. the algorithm goes: Find an available connection in the pool. Create one if needed and possible. If the pool is not allowed to create a new connection, wait a for a connection to become available. But this wait should be aborted if it takes too long. Checkout that connection from the pool. Execute the SQL command. If there is no DB::ResultSet yielded, return the connection to the pool. Otherwise, the connection will be returned to the pool when the ResultSet is closed. Return the statement result. If a connection can't be created, or if a connection loss occurs while the statement is performed the above process is repeated. The retry logic only happens when the statement is sent through the DB::Database . If it is sent through a DB::Connection or DB::Transaction no retry is performed since the code will state that certain connection object was expected to be used.","title":"Connection pool"},{"location":"database/connection_pool.html#configuration","text":"The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI. Name Default value initial_pool_size 1 max_pool_size 0 (unlimited) max_idle_pool_size 1 checkout_timeout 5.0 (seconds) retry_attempts 1 retry_delay 1.0 (seconds) When DB::Database is opened an initial number of initial_pool_size connections will be created. The pool will never hold more than max_pool_size connections. When returning/releasing a connection to the pool it will be closed if there are already max_idle_pool_size idle connections. If the max_pool_size was reached and a connection is needed, wait up to checkout_timeout seconds for an existing connection to become available. If a connection is lost or can't be established retry at most retry_attempts times waiting retry_delay seconds between each try.","title":"Configuration"},{"location":"database/connection_pool.html#sample","text":"The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions. # file: sample.cr require \"mysql\" DB . open \"mysql://root@localhost?retry_attempts=8&retry_delay=3\" do | db | loop do pp db . scalar ( \"SELECT NOW()\" ) sleep 0.5 end end $ crystal sample.cr db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:57 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:57 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:58 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:58 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:59 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:36:59 # stop mysql server for some seconds db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:06 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:06 db.scalar(\"SELECT NOW()\") # => 2016-12-16 16:37:07","title":"Sample"},{"location":"database/transactions.html","text":"Transactions \u00b6 When working with databases, it is common to need to group operations in such a way that if one fails, then we can go back to the latest safe state. This solution is described in the transaction paradigm , and is implemented by most database engines as it is necessary to meet ACID properties (Atomicity, Consistency, Isolation, Durability) [^ACID] With this in mind, we present the following example: We have two accounts (each represented by a name and an amount of money). db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 In one moment a transfer is made from one account to the other. For example, John transfers $50 to Sarah We have two accounts (each represented by a name and an amount of money). deposit db , \"Sarah\" , 50 withdraw db , \"John\" , 50 It is important to have in mind that if one of the operations fails then the final state would be inconsistent. So we need to execute the two operations (deposit and withdraw) as one operation . And if an error occurs then we would like to go back in time as if that one operation was never executed. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 db . transaction do | tx | cnn = tx . connection transfer_amount = 1000 deposit cnn , \"Sarah\" , transfer_amount withdraw cnn , \"John\" , transfer_amount end In the above example, we start a transaction simply by calling the method Database#transaction (how we get the database object is encapsulated in the method get_bank_db and is out of the scope of this document). The block is the body of the transaction. When the block gets executed (without any error) then an implicit commit is finally executed to persist the changes in the database. If an exception is raised by one of the operations, then an implicit rollback is executed, bringing the database to the state before the transaction started. Exception handling and rolling back \u00b6 As we mentioned early, an implicit rollback gets executed when an exception is raised, and it\u2019s worth mentioning that the exception may be rescued by us. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 1000 deposit ( cnn , \"Sarah\" , transfer_amount ) # John does not have enough money in his account! withdraw ( cnn , \"John\" , transfer_amount ) end rescue ex puts \"Transfer has been rolled back due to: #{ ex } \" end We may also raise an exception in the body of the transaction: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) raise Exception . new \"Because ...\" end rescue ex puts \"Transfer has been rolled back due to: #{ ex } \" end As the previous example, the exception cause the transaction to rollback and then is rescued by us. There is one exception with a different behaviour. If a DB::Rollback is raised within the block, the implicit rollback will happen, but the exception will not be raised outside the block. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) # rollback exception raise DB :: Rollback . new end rescue ex # ex is never a DB::Rollback end Explicit commit and rollback \u00b6 In all the previous examples, the rolling back is implicit , but we can also tell the transaction to rollback: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) tx . rollback puts \"Rolling Back the changes!\" end rescue ex # Notice that no exception is used in this case. end And we can also use the commit method: db = get_bank_db db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) tx . commit end Note After commit or rollback are used, the transaction is no longer usable. The connection is still open but any statement will be performed outside the context of the terminated transaction. Nested transactions \u00b6 As the name suggests, a nested transaction is a transaction created inside the scope of another transaction. Here is an example: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) end end rescue ex puts \"Exception raised due to: #{ ex } \" end Some observations from the above example: the inner_tx works with the values updated although the outer_tx is pending the commit. The connection used by outer_tx and inner_tx is the same connection . This is because the inner_tx inherits the connection from the outer_tx when created. Rollback nested transactions \u00b6 As we\u2019ve already seen, a rollback may be fired at any time (by an exception or by sending the message rollback explicitly) So let\u2019s present an example with a rollback fired by an exception placed at the outer-transaction : db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) end raise Exception . new ( \"Rollback all the things!\" ) end rescue ex puts \"Exception raised due to: #{ ex } \" end The rollback place in the outer_tx block, rolled back all the changes including the ones in the inner_tx block (the same happens if we use an explicit rollback). If the rollback is fired by an exception at the inner_tx block all the changes including the ones in the outer_tx are rollbacked. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) raise Exception . new ( \"Rollback all the things!\" ) end end rescue ex puts \"Exception raised due to: #{ ex } \" end There is a way to rollback the changes in the inner-transaction but keep the ones in the outer-transaction . Use rollback in the inner_tx object. This will rollback only then inner-transaction. Here is the example: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) inner_tx . rollback end end rescue ex puts \"Exception raised due to: #{ ex } \" end The same happens if a DB::Rollback exception is raised in the inner-transaction block. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) # Rollback exception raise DB :: Rollback . new end end rescue ex puts \"Exception raised due to: #{ ex } \" end [^ACID]: Theo Haerder and Andreas Reuter. 1983. Principles of transaction-oriented database recovery. ACM Comput. Surv. 15, 4 (December 1983), 287-317. DOI= http://dx.doi.org/10.1145/289.291","title":"Transactions"},{"location":"database/transactions.html#transactions","text":"When working with databases, it is common to need to group operations in such a way that if one fails, then we can go back to the latest safe state. This solution is described in the transaction paradigm , and is implemented by most database engines as it is necessary to meet ACID properties (Atomicity, Consistency, Isolation, Durability) [^ACID] With this in mind, we present the following example: We have two accounts (each represented by a name and an amount of money). db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 In one moment a transfer is made from one account to the other. For example, John transfers $50 to Sarah We have two accounts (each represented by a name and an amount of money). deposit db , \"Sarah\" , 50 withdraw db , \"John\" , 50 It is important to have in mind that if one of the operations fails then the final state would be inconsistent. So we need to execute the two operations (deposit and withdraw) as one operation . And if an error occurs then we would like to go back in time as if that one operation was never executed. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 db . transaction do | tx | cnn = tx . connection transfer_amount = 1000 deposit cnn , \"Sarah\" , transfer_amount withdraw cnn , \"John\" , transfer_amount end In the above example, we start a transaction simply by calling the method Database#transaction (how we get the database object is encapsulated in the method get_bank_db and is out of the scope of this document). The block is the body of the transaction. When the block gets executed (without any error) then an implicit commit is finally executed to persist the changes in the database. If an exception is raised by one of the operations, then an implicit rollback is executed, bringing the database to the state before the transaction started.","title":"Transactions"},{"location":"database/transactions.html#exception-handling-and-rolling-back","text":"As we mentioned early, an implicit rollback gets executed when an exception is raised, and it\u2019s worth mentioning that the exception may be rescued by us. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 1000 deposit ( cnn , \"Sarah\" , transfer_amount ) # John does not have enough money in his account! withdraw ( cnn , \"John\" , transfer_amount ) end rescue ex puts \"Transfer has been rolled back due to: #{ ex } \" end We may also raise an exception in the body of the transaction: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) raise Exception . new \"Because ...\" end rescue ex puts \"Transfer has been rolled back due to: #{ ex } \" end As the previous example, the exception cause the transaction to rollback and then is rescued by us. There is one exception with a different behaviour. If a DB::Rollback is raised within the block, the implicit rollback will happen, but the exception will not be raised outside the block. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) # rollback exception raise DB :: Rollback . new end rescue ex # ex is never a DB::Rollback end","title":"Exception handling and rolling back"},{"location":"database/transactions.html#explicit-commit-and-rollback","text":"In all the previous examples, the rolling back is implicit , but we can also tell the transaction to rollback: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 begin db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) tx . rollback puts \"Rolling Back the changes!\" end rescue ex # Notice that no exception is used in this case. end And we can also use the commit method: db = get_bank_db db . transaction do | tx | cnn = tx . connection transfer_amount = 50 deposit ( cnn , \"Sarah\" , transfer_amount ) withdraw ( cnn , \"John\" , transfer_amount ) tx . commit end Note After commit or rollback are used, the transaction is no longer usable. The connection is still open but any statement will be performed outside the context of the terminated transaction.","title":"Explicit commit and rollback"},{"location":"database/transactions.html#nested-transactions","text":"As the name suggests, a nested transaction is a transaction created inside the scope of another transaction. Here is an example: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) end end rescue ex puts \"Exception raised due to: #{ ex } \" end Some observations from the above example: the inner_tx works with the values updated although the outer_tx is pending the commit. The connection used by outer_tx and inner_tx is the same connection . This is because the inner_tx inherits the connection from the outer_tx when created.","title":"Nested transactions"},{"location":"database/transactions.html#rollback-nested-transactions","text":"As we\u2019ve already seen, a rollback may be fired at any time (by an exception or by sending the message rollback explicitly) So let\u2019s present an example with a rollback fired by an exception placed at the outer-transaction : db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) end raise Exception . new ( \"Rollback all the things!\" ) end rescue ex puts \"Exception raised due to: #{ ex } \" end The rollback place in the outer_tx block, rolled back all the changes including the ones in the inner_tx block (the same happens if we use an explicit rollback). If the rollback is fired by an exception at the inner_tx block all the changes including the ones in the outer_tx are rollbacked. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) raise Exception . new ( \"Rollback all the things!\" ) end end rescue ex puts \"Exception raised due to: #{ ex } \" end There is a way to rollback the changes in the inner-transaction but keep the ones in the outer-transaction . Use rollback in the inner_tx object. This will rollback only then inner-transaction. Here is the example: db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) inner_tx . rollback end end rescue ex puts \"Exception raised due to: #{ ex } \" end The same happens if a DB::Rollback exception is raised in the inner-transaction block. db = get_bank_db create_account db , \"John\" , amount : 100 create_account db , \"Sarah\" , amount : 100 create_account db , \"Jack\" , amount : 0 begin db . transaction do | outer_tx | outer_cnn = outer_tx . connection transfer_amount = 50 deposit ( outer_cnn , \"Sarah\" , transfer_amount ) withdraw ( outer_cnn , \"John\" , transfer_amount ) outer_tx . transaction do | inner_tx | inner_cnn = inner_tx . connection # John => 50 (pending commit) # Sarah => 150 (pending commit) # Jack => 0 another_transfer_amount = 150 deposit ( inner_cnn , \"Jack\" , another_transfer_amount ) withdraw ( inner_cnn , \"Sarah\" , another_transfer_amount ) # Rollback exception raise DB :: Rollback . new end end rescue ex puts \"Exception raised due to: #{ ex } \" end [^ACID]: Theo Haerder and Andreas Reuter. 1983. Principles of transaction-oriented database recovery. ACM Comput. Surv. 15, 4 (December 1983), 287-317. DOI= http://dx.doi.org/10.1145/289.291","title":"Rollback nested transactions"},{"location":"getting_started/index.html","text":"Getting started \u00b6 Hi and welcome to Crystal's Reference Book! First let's make sure to install the compiler so that we may try all the examples listed in this book. Once installed, the Crystal compiler should be available as crystal command. Let's try it! Crystal version \u00b6 We may check the Crystal compiler version. If Crystal is installed correctly then we should see something like this: $ crystal --version Crystal 0.34.0 (2020-04-07) LLVM: 10.0.0 Default target: x86_64-apple-macosx Great! Crystal help \u00b6 Now, if we want to list all the options given by the compiler, we may run crystal program without any arguments: $ crystal Usage: crystal [command] [switches] [program file] [--] [arguments] Command: init generate a new project build build an executable docs generate documentation env print Crystal environment information eval eval code from args or standard input play starts Crystal playground server run (default) build and run program spec build and run specs (in spec directory) tool run a tool help, --help, -h show this help version, --version, -v show version Run a command followed by --help to see command specific information, ex: crystal <command> --help More details about using the compiler can be found on the manpage man crystal or in our compiler manual . Hello Crystal \u00b6 The following example is the classic Hello World. In Crystal it looks like this: # hello_world.cr puts \"Hello World!\" We may run our example like this: $ crystal hello_world.cr Hello World! Note The main routine is simply the program itself. There's no need to define a \"main\" function or something similar. Here we have two more examples to continue our first steps in Crystal: HTTP Server Command Line Application","title":"Getting started"},{"location":"getting_started/index.html#getting-started","text":"Hi and welcome to Crystal's Reference Book! First let's make sure to install the compiler so that we may try all the examples listed in this book. Once installed, the Crystal compiler should be available as crystal command. Let's try it!","title":"Getting started"},{"location":"getting_started/index.html#crystal-version","text":"We may check the Crystal compiler version. If Crystal is installed correctly then we should see something like this: $ crystal --version Crystal 0.34.0 (2020-04-07) LLVM: 10.0.0 Default target: x86_64-apple-macosx Great!","title":"Crystal version"},{"location":"getting_started/index.html#crystal-help","text":"Now, if we want to list all the options given by the compiler, we may run crystal program without any arguments: $ crystal Usage: crystal [command] [switches] [program file] [--] [arguments] Command: init generate a new project build build an executable docs generate documentation env print Crystal environment information eval eval code from args or standard input play starts Crystal playground server run (default) build and run program spec build and run specs (in spec directory) tool run a tool help, --help, -h show this help version, --version, -v show version Run a command followed by --help to see command specific information, ex: crystal <command> --help More details about using the compiler can be found on the manpage man crystal or in our compiler manual .","title":"Crystal help"},{"location":"getting_started/index.html#hello-crystal","text":"The following example is the classic Hello World. In Crystal it looks like this: # hello_world.cr puts \"Hello World!\" We may run our example like this: $ crystal hello_world.cr Hello World! Note The main routine is simply the program itself. There's no need to define a \"main\" function or something similar. Here we have two more examples to continue our first steps in Crystal: HTTP Server Command Line Application","title":"Hello Crystal"},{"location":"getting_started/cli.html","text":"Command Line Interface Application \u00b6 Programming Command Line Interface applications (CLI applications) is one of the most entertaining tasks a developer may do. So let\u2019s have some fun building our first CLI application in Crystal. There are two main topics when building a CLI application: input output Input \u00b6 This topic covers all things related to: options passed to the app request for user input Options \u00b6 It is a very common practice to pass options to the application. For example, we may run crystal -v and Crystal will display: $ crystal -v Crystal 0.31.1 (2019-10-02) LLVM: 8.0.1 Default target: x86_64-apple-macosx and if we run: crystal -h , then Crystal will show all the accepted options and how to use them. So now the question would be: do we need to implement an options parser? No need to, Crystal got us covered with the class OptionParser . Let\u2019s build an application using this parser! At start our CLI application will have two options: -v / --version : it will display the application version. -h / --help : it will display the application help. # file: help.cr require \"option_parser\" OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end end So, how does all this work? Well \u2026 magic! No, it\u2019s not really magic! Just Crystal making our life easy. When our application starts, the block passed to OptionParser#parse gets executed. In that block we define all the options. After the block is executed, the parser will start consuming the arguments passed to the application, trying to match each one with the options defined by us. If an option matches then the block passed to parser#on gets executed! We can read all about OptionParser in the official API documentation . And from there we are one click away from the source code ... the actual proof that it is not magic! Now, let's run our application. We have two ways using the compiler : Build the application and then run it. Compile and run the application , all in one command. We are going to use the second way: $ crystal run ./help.cr -- -h Welcome to The Beatles App! -v, --version Show version -h, --help Show help Let's build another fabulous application with the following feature: By default (i.e. no options given) the application will display the names of the Fab Four. But, if we pass the option -t / --twist it will display the names in uppercase: # file: twist_and_shout.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] shout = false option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-t\" , \"--twist\" , \"Twist and SHOUT\" do shout = true end end members = the_beatles members = the_beatles . map &. upcase if shout puts \"\" puts \"Group members:\" puts \"==============\" members . each do | member | puts member end Running the application with the -t option will output: $ crystal run ./twist_and_shout.cr -- -t Group members: ============== JOHN LENNON PAUL MCCARTNEY GEORGE HARRISON RINGO STARR Parameterized options \u00b6 Let\u2019s create another application: when passing the option -g / --goodbye_hello , the application will say hello to a given name passed as a parameter to the option . # file: hello_goodbye.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] say_hi_to = \"\" option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-g NAME\" , \"--goodbye_hello=NAME\" , \"Say hello to whoever you want\" do | name | say_hi_to = name end end unless say_hi_to . empty? puts \"\" puts \"You say goodbye, and #{ the_beatles . sample } says hello to #{ say_hi_to } !\" end In this case, the block receives a parameter that represents the parameter passed to the option. Let\u2019s try it! $ crystal run ./hello_goodbye.cr -- -g \"Penny Lane\" You say goodbye, and Ringo Starr say hello to Penny Lane! Great! These applications look awesome! But, what happens when we pass an option that is not declared? For example -n $ crystal run ./hello_goodbye.cr -- -n Unhandled exception: Invalid option: -n (OptionParser::InvalidOption) from ... Oh no! It\u2019s broken: we need to handle invalid options and invalid parameters given to an option! For these two situations, the OptionParser class has two methods: #invalid_option and #missing_option So, let's add this option handlers and merge all this CLI applications into one fabulous CLI application! All My CLI: The complete application! \u00b6 Here\u2019s the final result, with invalid/missing options handling, plus other new options: # file: all_my_cli.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] shout = false say_hi_to = \"\" strawberry = false option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-t\" , \"--twist\" , \"Twist and SHOUT\" do shout = true end parser . on \"-g NAME\" , \"--goodbye_hello=NAME\" , \"Say hello to whoever you want\" do | name | say_hi_to = name end parser . on \"-r\" , \"--random_goodbye_hello\" , \"Say hello to one random member\" do say_hi_to = the_beatles . sample end parser . on \"-s\" , \"--strawberry\" , \"Strawberry fields forever mode ON\" do strawberry = true end parser . missing_option do | option_flag | STDERR . puts \"ERROR: #{ option_flag } is missing something.\" STDERR . puts \"\" STDERR . puts parser exit ( 1 ) end parser . invalid_option do | option_flag | STDERR . puts \"ERROR: #{ option_flag } is not a valid option.\" STDERR . puts parser exit ( 1 ) end end members = the_beatles members = the_beatles . map &. upcase if shout puts \"Strawberry fields forever mode ON\" if strawberry puts \"\" puts \"Group members:\" puts \"==============\" members . each do | member | puts \" #{ strawberry ? \"\ud83c\udf53\" : \"-\" } #{ member } \" end unless say_hi_to . empty? puts \"\" puts \"You say goodbye, and I say hello to #{ say_hi_to } !\" end Request for user input \u00b6 Sometimes, we may need the user to input a value. How do we read that value? Easy, peasy! Let\u2019s create a new application: the Fab Four will sing with us any phrase we want. When running the application, it will request a phrase to the user and the magic will happen! # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets puts \"The Beatles are singing: \ud83c\udfb5 #{ user_input } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" The method gets will pause the execution of the application, until the user finishes entering the input (pressing the Enter key). When the user presses Enter , then the execution will continue and user_input will have the user value. But what happen if the user doesn\u2019t enter any value? In that case, we would get an empty string (if the user only presses Enter ) or maybe a Nil value (if the input stream id closed, e.g. by pressing Ctrl+D ). To illustrate the problem let\u2019s try the following: we want the input entered by the user to be sang loudly: # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets puts \"The Beatles are singing: \ud83c\udfb5 #{ user_input . upcase } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" When running the example, Crystal will reply: $ crystal run ./let_it_cli.cr Showing last frame. Use --error-trace for full trace. In let_it_cli.cr:5:46 5 | puts \"The Beatles are singing: \ud83c\udfb5#{user_input.upper_case} ^--------- Error: undefined method 'upper_case' for Nil (compile-time type is (String | Nil)) Ah! We should have known better: the type of the user input is the union type String | Nil . So, we have to test for Nil and for empty and act naturally for each case: # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets exit if user_input .nil? # Ctrl+D default_lyrics = \"Na, na, na, na-na-na na\" \\ \" / \" \\ \"Na-na-na na, hey Jude\" lyrics = user_input . presence || default_lyrics puts \"The Beatles are singing: \ud83c\udfb5 #{ lyrics . upcase } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" Output \u00b6 Now, we will focus on the second main topic: our application\u2019s output. For starters, our applications already display information but (I think) we could do better. Let\u2019s add more life (i.e. colors!) to the outputs. And to accomplish this, we will be using the Colorize module. Let\u2019s build a really simple application that shows a string with colors! We will use yellow font on a black background: # file: yellow_cli.cr require \"colorize\" puts \" #{ \"The Beatles\" . colorize ( :yellow ) . on ( :black ) } App\" Great! That was easy! Now imagine using this string as the banner for our All My CLI application, it's easy if you try: parser . banner = \" #{ \"The Beatles\" . colorize ( :yellow ) . on ( :black ) } App\" For our second application, we will add a text decoration ( blink in this case): # file: let_it_cli.cr require \"colorize\" puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets exit if user_input .nil? # Ctrl+D default_lyrics = \"Na, na, na, na-na-na na\" \\ \" / \" \\ \"Na-na-na na, hey Jude\" lyrics = user_input . presence || default_lyrics puts \"The Beatles are singing: #{ \"\ud83c\udfb5 #{ user_input } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" . colorize . mode ( :blink ) } \" Let\u2019s try the renewed application \u2026 and hear the difference!! Now we have two fabulous apps!! You may find a list of available colors and text decorations in the API documentation . Testing \u00b6 As with any other application, at some point we would like to write tests for the different features. Right now the code containing the logic of each of the applications always gets executed with the OptionParser , i.e. there is no way to include that file without running the whole application. So first we would need to refactor the code, separating the code necessary for parsing options from the logic. Once the refactor is done, we could start testing the logic and including the file with the logic in the testing files we need. We leave this as an exercise for the reader. Using Readline and NCurses \u00b6 In case we want to build richer CLI applications, there are libraries that can help us. Here we will name two well-known libraries: Readline and NCurses . As stated in the documentation for the GNU Readline Library , Readline is a library that provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Readline has some great features: filename autocompletion out of the box; custom autocompletion method; keybinding, just to mention a few. If we want to try it then the crystal-lang/crystal-readline shard will give us an easy API to use Readline . On the other hand, we have NCurses (New Curses). This library allows developers to create graphical user interfaces in the terminal. As its name implies, it is an improved version of the library named Curses , which was developed to support a text-based dungeon-crawling adventure game called Rogue! As you can imagine, there are already a couple of shards in the ecosystem that will allow us to use NCurses in Crystal! And so we have reached The End \ud83d\ude0e\ud83c\udfb6","title":"A Command Line Application"},{"location":"getting_started/cli.html#command-line-interface-application","text":"Programming Command Line Interface applications (CLI applications) is one of the most entertaining tasks a developer may do. So let\u2019s have some fun building our first CLI application in Crystal. There are two main topics when building a CLI application: input output","title":"Command Line Interface Application"},{"location":"getting_started/cli.html#input","text":"This topic covers all things related to: options passed to the app request for user input","title":"Input"},{"location":"getting_started/cli.html#options","text":"It is a very common practice to pass options to the application. For example, we may run crystal -v and Crystal will display: $ crystal -v Crystal 0.31.1 (2019-10-02) LLVM: 8.0.1 Default target: x86_64-apple-macosx and if we run: crystal -h , then Crystal will show all the accepted options and how to use them. So now the question would be: do we need to implement an options parser? No need to, Crystal got us covered with the class OptionParser . Let\u2019s build an application using this parser! At start our CLI application will have two options: -v / --version : it will display the application version. -h / --help : it will display the application help. # file: help.cr require \"option_parser\" OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end end So, how does all this work? Well \u2026 magic! No, it\u2019s not really magic! Just Crystal making our life easy. When our application starts, the block passed to OptionParser#parse gets executed. In that block we define all the options. After the block is executed, the parser will start consuming the arguments passed to the application, trying to match each one with the options defined by us. If an option matches then the block passed to parser#on gets executed! We can read all about OptionParser in the official API documentation . And from there we are one click away from the source code ... the actual proof that it is not magic! Now, let's run our application. We have two ways using the compiler : Build the application and then run it. Compile and run the application , all in one command. We are going to use the second way: $ crystal run ./help.cr -- -h Welcome to The Beatles App! -v, --version Show version -h, --help Show help Let's build another fabulous application with the following feature: By default (i.e. no options given) the application will display the names of the Fab Four. But, if we pass the option -t / --twist it will display the names in uppercase: # file: twist_and_shout.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] shout = false option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-t\" , \"--twist\" , \"Twist and SHOUT\" do shout = true end end members = the_beatles members = the_beatles . map &. upcase if shout puts \"\" puts \"Group members:\" puts \"==============\" members . each do | member | puts member end Running the application with the -t option will output: $ crystal run ./twist_and_shout.cr -- -t Group members: ============== JOHN LENNON PAUL MCCARTNEY GEORGE HARRISON RINGO STARR","title":"Options"},{"location":"getting_started/cli.html#parameterized-options","text":"Let\u2019s create another application: when passing the option -g / --goodbye_hello , the application will say hello to a given name passed as a parameter to the option . # file: hello_goodbye.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] say_hi_to = \"\" option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-g NAME\" , \"--goodbye_hello=NAME\" , \"Say hello to whoever you want\" do | name | say_hi_to = name end end unless say_hi_to . empty? puts \"\" puts \"You say goodbye, and #{ the_beatles . sample } says hello to #{ say_hi_to } !\" end In this case, the block receives a parameter that represents the parameter passed to the option. Let\u2019s try it! $ crystal run ./hello_goodbye.cr -- -g \"Penny Lane\" You say goodbye, and Ringo Starr say hello to Penny Lane! Great! These applications look awesome! But, what happens when we pass an option that is not declared? For example -n $ crystal run ./hello_goodbye.cr -- -n Unhandled exception: Invalid option: -n (OptionParser::InvalidOption) from ... Oh no! It\u2019s broken: we need to handle invalid options and invalid parameters given to an option! For these two situations, the OptionParser class has two methods: #invalid_option and #missing_option So, let's add this option handlers and merge all this CLI applications into one fabulous CLI application!","title":"Parameterized options"},{"location":"getting_started/cli.html#all-my-cli-the-complete-application","text":"Here\u2019s the final result, with invalid/missing options handling, plus other new options: # file: all_my_cli.cr require \"option_parser\" the_beatles = [ \"John Lennon\" , \"Paul McCartney\" , \"George Harrison\" , \"Ringo Starr\" ] shout = false say_hi_to = \"\" strawberry = false option_parser = OptionParser . parse do | parser | parser . banner = \"Welcome to The Beatles App!\" parser . on \"-v\" , \"--version\" , \"Show version\" do puts \"version 1.0\" exit end parser . on \"-h\" , \"--help\" , \"Show help\" do puts parser exit end parser . on \"-t\" , \"--twist\" , \"Twist and SHOUT\" do shout = true end parser . on \"-g NAME\" , \"--goodbye_hello=NAME\" , \"Say hello to whoever you want\" do | name | say_hi_to = name end parser . on \"-r\" , \"--random_goodbye_hello\" , \"Say hello to one random member\" do say_hi_to = the_beatles . sample end parser . on \"-s\" , \"--strawberry\" , \"Strawberry fields forever mode ON\" do strawberry = true end parser . missing_option do | option_flag | STDERR . puts \"ERROR: #{ option_flag } is missing something.\" STDERR . puts \"\" STDERR . puts parser exit ( 1 ) end parser . invalid_option do | option_flag | STDERR . puts \"ERROR: #{ option_flag } is not a valid option.\" STDERR . puts parser exit ( 1 ) end end members = the_beatles members = the_beatles . map &. upcase if shout puts \"Strawberry fields forever mode ON\" if strawberry puts \"\" puts \"Group members:\" puts \"==============\" members . each do | member | puts \" #{ strawberry ? \"\ud83c\udf53\" : \"-\" } #{ member } \" end unless say_hi_to . empty? puts \"\" puts \"You say goodbye, and I say hello to #{ say_hi_to } !\" end","title":"All My CLI: The complete application!"},{"location":"getting_started/cli.html#request-for-user-input","text":"Sometimes, we may need the user to input a value. How do we read that value? Easy, peasy! Let\u2019s create a new application: the Fab Four will sing with us any phrase we want. When running the application, it will request a phrase to the user and the magic will happen! # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets puts \"The Beatles are singing: \ud83c\udfb5 #{ user_input } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" The method gets will pause the execution of the application, until the user finishes entering the input (pressing the Enter key). When the user presses Enter , then the execution will continue and user_input will have the user value. But what happen if the user doesn\u2019t enter any value? In that case, we would get an empty string (if the user only presses Enter ) or maybe a Nil value (if the input stream id closed, e.g. by pressing Ctrl+D ). To illustrate the problem let\u2019s try the following: we want the input entered by the user to be sang loudly: # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets puts \"The Beatles are singing: \ud83c\udfb5 #{ user_input . upcase } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" When running the example, Crystal will reply: $ crystal run ./let_it_cli.cr Showing last frame. Use --error-trace for full trace. In let_it_cli.cr:5:46 5 | puts \"The Beatles are singing: \ud83c\udfb5#{user_input.upper_case} ^--------- Error: undefined method 'upper_case' for Nil (compile-time type is (String | Nil)) Ah! We should have known better: the type of the user input is the union type String | Nil . So, we have to test for Nil and for empty and act naturally for each case: # file: let_it_cli.cr puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets exit if user_input .nil? # Ctrl+D default_lyrics = \"Na, na, na, na-na-na na\" \\ \" / \" \\ \"Na-na-na na, hey Jude\" lyrics = user_input . presence || default_lyrics puts \"The Beatles are singing: \ud83c\udfb5 #{ lyrics . upcase } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\"","title":"Request for user input"},{"location":"getting_started/cli.html#output","text":"Now, we will focus on the second main topic: our application\u2019s output. For starters, our applications already display information but (I think) we could do better. Let\u2019s add more life (i.e. colors!) to the outputs. And to accomplish this, we will be using the Colorize module. Let\u2019s build a really simple application that shows a string with colors! We will use yellow font on a black background: # file: yellow_cli.cr require \"colorize\" puts \" #{ \"The Beatles\" . colorize ( :yellow ) . on ( :black ) } App\" Great! That was easy! Now imagine using this string as the banner for our All My CLI application, it's easy if you try: parser . banner = \" #{ \"The Beatles\" . colorize ( :yellow ) . on ( :black ) } App\" For our second application, we will add a text decoration ( blink in this case): # file: let_it_cli.cr require \"colorize\" puts \"Welcome to The Beatles Sing Along version 1.0!\" puts \"Enter a phrase you want The Beatles to sing\" print \"> \" user_input = gets exit if user_input .nil? # Ctrl+D default_lyrics = \"Na, na, na, na-na-na na\" \\ \" / \" \\ \"Na-na-na na, hey Jude\" lyrics = user_input . presence || default_lyrics puts \"The Beatles are singing: #{ \"\ud83c\udfb5 #{ user_input } \ud83c\udfb6\ud83c\udfb8\ud83e\udd41\" . colorize . mode ( :blink ) } \" Let\u2019s try the renewed application \u2026 and hear the difference!! Now we have two fabulous apps!! You may find a list of available colors and text decorations in the API documentation .","title":"Output"},{"location":"getting_started/cli.html#testing","text":"As with any other application, at some point we would like to write tests for the different features. Right now the code containing the logic of each of the applications always gets executed with the OptionParser , i.e. there is no way to include that file without running the whole application. So first we would need to refactor the code, separating the code necessary for parsing options from the logic. Once the refactor is done, we could start testing the logic and including the file with the logic in the testing files we need. We leave this as an exercise for the reader.","title":"Testing"},{"location":"getting_started/cli.html#using-readline-and-ncurses","text":"In case we want to build richer CLI applications, there are libraries that can help us. Here we will name two well-known libraries: Readline and NCurses . As stated in the documentation for the GNU Readline Library , Readline is a library that provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Readline has some great features: filename autocompletion out of the box; custom autocompletion method; keybinding, just to mention a few. If we want to try it then the crystal-lang/crystal-readline shard will give us an easy API to use Readline . On the other hand, we have NCurses (New Curses). This library allows developers to create graphical user interfaces in the terminal. As its name implies, it is an improved version of the library named Curses , which was developed to support a text-based dungeon-crawling adventure game called Rogue! As you can imagine, there are already a couple of shards in the ecosystem that will allow us to use NCurses in Crystal! And so we have reached The End \ud83d\ude0e\ud83c\udfb6","title":"Using Readline and NCurses"},{"location":"getting_started/http_server.html","text":"HTTP Server \u00b6 A slightly more interesting example is an HTTP Server: require \"http/server\" server = HTTP :: Server . new do | context | context . response . content_type = \"text/plain\" context . response . print \"Hello world! The time is #{ Time . local } \" end address = server . bind_tcp 8080 puts \"Listening on http:// #{ address } \" server . listen The above code will make sense once you read the whole language reference, but we can already learn some things. You can require code defined in other files: require \"http/server\" You can define local variables without the need to specify their type: server = HTTP :: Server . new ... The port of the HTTP server is set by using the method bind_tcp on the object HTTP::Server (the port set to 8080). address = server . bind_tcp 8080 You program by invoking methods (or sending messages) to objects. HTTP :: Server . new ... ... Time . local ... address = server . bind_tcp 8080 ... puts \"Listening on http:// #{ address } \" ... server . listen You can use code blocks, or simply blocks , which are a very convenient way to reuse code and get some features from the functional world: HTTP :: Server . new do | context | ... end You can easily create strings with embedded content, known as string interpolation. The language comes with other syntax as well to create arrays, hashes, ranges, tuples and more: \"Hello world! The time is #{ Time . local } \"","title":"An HTTP Server"},{"location":"getting_started/http_server.html#http-server","text":"A slightly more interesting example is an HTTP Server: require \"http/server\" server = HTTP :: Server . new do | context | context . response . content_type = \"text/plain\" context . response . print \"Hello world! The time is #{ Time . local } \" end address = server . bind_tcp 8080 puts \"Listening on http:// #{ address } \" server . listen The above code will make sense once you read the whole language reference, but we can already learn some things. You can require code defined in other files: require \"http/server\" You can define local variables without the need to specify their type: server = HTTP :: Server . new ... The port of the HTTP server is set by using the method bind_tcp on the object HTTP::Server (the port set to 8080). address = server . bind_tcp 8080 You program by invoking methods (or sending messages) to objects. HTTP :: Server . new ... ... Time . local ... address = server . bind_tcp 8080 ... puts \"Listening on http:// #{ address } \" ... server . listen You can use code blocks, or simply blocks , which are a very convenient way to reuse code and get some features from the functional world: HTTP :: Server . new do | context | ... end You can easily create strings with embedded content, known as string interpolation. The language comes with other syntax as well to create arrays, hashes, ranges, tuples and more: \"Hello world! The time is #{ Time . local } \"","title":"HTTP Server"},{"location":"guides/index.html","text":"Guides \u00b6 Read these guides to get the best out of Crystal.","title":"Guides"},{"location":"guides/index.html#guides","text":"Read these guides to get the best out of Crystal.","title":"Guides"},{"location":"guides/concurrency.html","text":"Concurrency \u00b6 Concurrency vs. Parallelism \u00b6 The definitions of \"concurrency\" and \"parallelism\" sometimes get mixed up, but they are not the same. A concurrent system is one that can be in charge of many tasks, although not necessarily it is executing them at the same time. You can think of yourself being in the kitchen cooking: you chop an onion, put it to fry, and while it's being fried you chop a tomato, but you are not doing all of those things at the same time: you distribute your time between those tasks. Parallelism would be to stir fry onions with one hand while with the other one you chop a tomato. At the moment of this writing, Crystal has concurrency support but not parallelism: several tasks can be executed, and a bit of time will be spent on each of these, but two code paths are never executed at the same exact time. A Crystal program executes in a single operating system thread, except the Garbage Collector (GC) which implements a concurrent mark-and-sweep (currently Boehm GC ). Fibers \u00b6 To achieve concurrency, Crystal has fibers. A fiber is in a way similar to an operating system thread except that it's much more lightweight and its execution is managed internally by the process. So, a program will spawn multiple fibers and Crystal will make sure to execute them when the time is right. Event loop \u00b6 For everything I/O related there's an event loop. Some time-consuming operations are delegated to it, and while the event loop waits for that operation to finish the program can continue executing other fibers. A simple example of this is waiting for data to come through a socket. Channels \u00b6 Crystal has Channels inspired by CSP . They allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures. Execution of a program \u00b6 When a program starts, it fires up a main fiber that will execute your top-level code. There, one can spawn many other fibers. The components of a program are: The Runtime Scheduler, in charge of executing all fibers when the time is right. The Event Loop, which is just another fiber, being in charge of async tasks, like for example files, sockets, pipes, signals and timers (like doing a sleep ). Channels, to communicate data between fibers. The Runtime Scheduler will coordinate fibers and channels for their communication. Garbage Collector: to clean up \"no longer used\" memory. A Fiber \u00b6 A fiber is an execution unit that is more lightweight than a thread. It's a small object that has an associated stack of 8MB, which is what is usually assigned to an operating system thread. Fibers, unlike threads, are cooperative. Threads are pre-emptive: the operating system might interrupt a thread at any time and start executing another one. A fiber must explicitly tell the Runtime Scheduler to switch to another fiber. For example if there's I/O to be waited on, a fiber will tell the scheduler \"Look, I have to wait for this I/O to be available, you continue executing other fibers and come back to me when that I/O is ready\". The advantage of being cooperative is that a lot of the overhead of doing a context switch (switching between threads) is gone. A Fiber is much more lightweight than a thread: even though it's assigned 8MB, it starts with a small stack of 4KB. On a 64-bit machine it lets us spawn millions and millions of fibers. In a 32-bit machine we can only spawn 512 fibers, which is not a lot. But because 32-bit machines are starting to become obsolete, we'll bet on the future and focus more on 64-bit machines. The Runtime Scheduler \u00b6 The scheduler has a queue of: Fibers ready to be executed: for example when you spawn a fiber, it's ready to be executed. The event loop: which is another fiber. When there are no other fibers ready to be executed, the event loop checks if there is any async operation that is ready, and then executes the fiber waiting for that operation. The event loop is currently implemented with libevent , which is an abstraction of other event mechanisms like epoll and kqueue . Fibers that voluntarily asked to wait: this is done with Fiber.yield , which means \"I can continue executing, but I'll give you some time to execute other fibers if you want\". Communicating data \u00b6 Because at this moment there's only a single thread executing your code, accessing and modifying a class variable in different fibers will work just fine. However, once multiple threads (parallelism) is introduced in the language, it might break. That's why the recommended mechanism to communicate data is using channels and sending messages between them. Internally, a channel implements all the locking mechanisms to avoid data races, but from the outside you use them as communication primitives, so you (the user) don't have to use locks. Sample code \u00b6 Spawning a fiber \u00b6 To spawn a fiber you use spawn with a block: spawn do # ... socket . gets # ... end spawn do # ... sleep 5 . seconds # ... end Here we have two fibers: one reads from a socket and the other does a sleep . When the first fiber reaches the socket.gets line, it gets suspended, the Event Loop is told to continue executing this fiber when there's data in the socket, and the program continues with the second fiber. This fiber wants to sleep for 5 seconds, so the Event Loop is told to continue with this fiber in 5 seconds. If there aren't other fibers to execute, the Event Loop will wait until either of these events happen, without consuming CPU time. The reason why socket.gets and sleep behave like this is because their implementations talk directly with the Runtime Scheduler and the Event Loop, there's nothing magical about it. In general, the standard library already takes care of doing all of this so you don't have to. Note, however, that fibers don't get executed right away. For example: spawn do loop do puts \"Hello!\" end end Running the above code will produce no output and exit immediately. The reason for this is that a fiber is not executed as soon as it is spawned. So, the main fiber, the one that spawns the above fiber, finishes its execution and the program exits. One way to solve it is to do a sleep : spawn do loop do puts \"Hello!\" end end sleep 1 . second This program will now print \"Hello!\" for one second and then exit. This is because the sleep call will schedule the main fiber to be executed in a second, and then executes another \"ready to execute\" fiber, which in this case is the one above. Another way is this: spawn do loop do puts \"Hello!\" end end Fiber . yield This time Fiber.yield will tell the scheduler to execute the other fiber. This will print \"Hello!\" until the standard output blocks (the system call will tell us we have to wait until the output is ready), and then execution continues with the main fiber and the program exits. Here the standard output might never block so the program will continue executing forever. If we want to execute the spawned fiber for ever, we can use sleep without arguments: spawn do loop do puts \"Hello!\" end end sleep Of course the above program can be written without spawn at all, just with a loop. sleep is more useful when spawning more than one fiber. Spawning a call \u00b6 You can also spawn by passing a method call instead of a block. To understand why this is useful, let's look at this example: i = 0 while i < 10 spawn do puts ( i ) end i += 1 end Fiber . yield The above program prints \"10\" ten times. The problem is that there's only one variable i that all spawned fibers refer to, and when Fiber.yield is executed its value is 10. To solve this, we can do this: i = 0 while i < 10 proc = -> ( x : Int32 ) do spawn do puts ( x ) end end proc . call ( i ) i += 1 end Fiber . yield Now it works because we are creating a Proc and we invoke it passing i , so the value gets copied and now the spawned fiber receives a copy. To avoid all this boilerplate, the standard library provides a spawn macro that accepts a call expression and basically rewrites it to do the above. Using it, we end up with: i = 0 while i < 10 spawn puts ( i ) i += 1 end Fiber . yield This is mostly useful with local variables that change at iterations. This doesn't happen with block arguments. For example, this works as expected: 10 . times do | i | spawn do puts i end end Fiber . yield Spawning a fiber and waiting for it to complete \u00b6 We can use a channel for this: channel = Channel ( Nil ) . new spawn do puts \"Before send\" channel . send ( nil ) puts \"After send\" end puts \"Before receive\" channel . receive puts \"After receive\" This prints: Before receive Before send After receive First, the program spawns a fiber but doesn't execute it yet. When we invoke channel.receive , the main fiber blocks and execution continues with the spawned fiber. Then channel.send(nil) is invoked, and so execution continues at channel.receive , which was waiting for a value. Then the main fiber continues executing and finishes, so the program exits without giving the other fiber a chance to print \"After send\". In the above example we used nil just to communicate that the fiber ended. We can also use channels to communicate values between fibers: channel = Channel ( Int32 ) . new spawn do puts \"Before first send\" channel . send ( 1 ) puts \"Before second send\" channel . send ( 2 ) end puts \"Before first receive\" value = channel . receive puts value # => 1 puts \"Before second receive\" value = channel . receive puts value # => 2 Output: Before first receive Before first send 1 Before second receive Before second send 2 Note that when the program executes a receive , that fiber blocks and execution continues with the other fiber. When send is executed, execution continues with the fiber that was waiting on that channel. Here we are sending literal values, but the spawned fiber might compute this value by, for example, reading a file, or getting it from a socket. When this fiber will have to wait for I/O, other fibers will be able to continue executing code until I/O is ready, and finally when the value is ready and sent through the channel, the main fiber will receive it. For example: require \"socket\" channel = Channel ( String ) . new spawn do server = TCPServer . new ( \"0.0.0.0\" , 8080 ) socket = server . accept while line = socket . gets channel . send ( line ) end end spawn do while line = gets channel . send ( line ) end end 3 . times do puts channel . receive end The above program spawns two fibers. The first one creates a TCPServer, accepts one connection and reads lines from it, sending them to the channel. There's a second fiber reading lines from standard input. The main fiber reads the first 3 messages sent to the channel, either from the socket or stdin, then the program exits. The gets calls will block the fibers and tell the Event Loop to continue from there if data comes. Likewise, we can wait for multiple fibers to complete execution, and gather their values: channel = Channel ( Int32 ) . new 10 . times do | i | spawn do channel . send ( i * 2 ) end end sum = 0 10 . times do sum += channel . receive end puts sum # => 90 You can, of course, use receive inside a spawned fiber: channel = Channel ( Int32 ) . new spawn do puts \"Before send\" channel . send ( 1 ) puts \"After send\" end spawn do puts \"Before receive\" puts channel . receive puts \"After receive\" end puts \"Before yield\" Fiber . yield puts \"After yield\" Output: Before yield Before send Before receive 1 After receive After send After yield Here channel.send is executed first, but since there's no one waiting for a value (yet), execution continues in other fibers. The second fiber is executed, there's a value on the channel, it's obtained, and execution continues, first with the first fiber, then with the main fiber, because Fiber.yield puts a fiber at the end of the execution queue. Buffered channels \u00b6 The above examples use unbuffered channels: when sending a value, if a fiber is waiting on that channel then execution continues on that fiber. With a buffered channel, invoking send won't switch to another fiber unless the buffer is full: # A buffered channel of capacity 2 channel = Channel ( Int32 ) . new ( 2 ) spawn do puts \"Before send 1\" channel . send ( 1 ) puts \"Before send 2\" channel . send ( 2 ) puts \"Before send 3\" channel . send ( 3 ) puts \"After send\" end 3 . times do | i | puts channel . receive end Output: Before send 1 Before send 2 Before send 3 1 2 After send 3 Note that the first 2 sends are executed without switching to another fiber. However, in the third send the channel's buffer is full, so execution goes to the main fiber. Here the two values are received and the channel is depleted. At the third receive the main fiber blocks and execution goes to the other fiber, which sends more values, finishes, etc.","title":"Concurrency"},{"location":"guides/concurrency.html#concurrency","text":"","title":"Concurrency"},{"location":"guides/concurrency.html#concurrency-vs-parallelism","text":"The definitions of \"concurrency\" and \"parallelism\" sometimes get mixed up, but they are not the same. A concurrent system is one that can be in charge of many tasks, although not necessarily it is executing them at the same time. You can think of yourself being in the kitchen cooking: you chop an onion, put it to fry, and while it's being fried you chop a tomato, but you are not doing all of those things at the same time: you distribute your time between those tasks. Parallelism would be to stir fry onions with one hand while with the other one you chop a tomato. At the moment of this writing, Crystal has concurrency support but not parallelism: several tasks can be executed, and a bit of time will be spent on each of these, but two code paths are never executed at the same exact time. A Crystal program executes in a single operating system thread, except the Garbage Collector (GC) which implements a concurrent mark-and-sweep (currently Boehm GC ).","title":"Concurrency vs. Parallelism"},{"location":"guides/concurrency.html#fibers","text":"To achieve concurrency, Crystal has fibers. A fiber is in a way similar to an operating system thread except that it's much more lightweight and its execution is managed internally by the process. So, a program will spawn multiple fibers and Crystal will make sure to execute them when the time is right.","title":"Fibers"},{"location":"guides/concurrency.html#event-loop","text":"For everything I/O related there's an event loop. Some time-consuming operations are delegated to it, and while the event loop waits for that operation to finish the program can continue executing other fibers. A simple example of this is waiting for data to come through a socket.","title":"Event loop"},{"location":"guides/concurrency.html#channels","text":"Crystal has Channels inspired by CSP . They allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures.","title":"Channels"},{"location":"guides/concurrency.html#execution-of-a-program","text":"When a program starts, it fires up a main fiber that will execute your top-level code. There, one can spawn many other fibers. The components of a program are: The Runtime Scheduler, in charge of executing all fibers when the time is right. The Event Loop, which is just another fiber, being in charge of async tasks, like for example files, sockets, pipes, signals and timers (like doing a sleep ). Channels, to communicate data between fibers. The Runtime Scheduler will coordinate fibers and channels for their communication. Garbage Collector: to clean up \"no longer used\" memory.","title":"Execution of a program"},{"location":"guides/concurrency.html#a-fiber","text":"A fiber is an execution unit that is more lightweight than a thread. It's a small object that has an associated stack of 8MB, which is what is usually assigned to an operating system thread. Fibers, unlike threads, are cooperative. Threads are pre-emptive: the operating system might interrupt a thread at any time and start executing another one. A fiber must explicitly tell the Runtime Scheduler to switch to another fiber. For example if there's I/O to be waited on, a fiber will tell the scheduler \"Look, I have to wait for this I/O to be available, you continue executing other fibers and come back to me when that I/O is ready\". The advantage of being cooperative is that a lot of the overhead of doing a context switch (switching between threads) is gone. A Fiber is much more lightweight than a thread: even though it's assigned 8MB, it starts with a small stack of 4KB. On a 64-bit machine it lets us spawn millions and millions of fibers. In a 32-bit machine we can only spawn 512 fibers, which is not a lot. But because 32-bit machines are starting to become obsolete, we'll bet on the future and focus more on 64-bit machines.","title":"A Fiber"},{"location":"guides/concurrency.html#the-runtime-scheduler","text":"The scheduler has a queue of: Fibers ready to be executed: for example when you spawn a fiber, it's ready to be executed. The event loop: which is another fiber. When there are no other fibers ready to be executed, the event loop checks if there is any async operation that is ready, and then executes the fiber waiting for that operation. The event loop is currently implemented with libevent , which is an abstraction of other event mechanisms like epoll and kqueue . Fibers that voluntarily asked to wait: this is done with Fiber.yield , which means \"I can continue executing, but I'll give you some time to execute other fibers if you want\".","title":"The Runtime Scheduler"},{"location":"guides/concurrency.html#communicating-data","text":"Because at this moment there's only a single thread executing your code, accessing and modifying a class variable in different fibers will work just fine. However, once multiple threads (parallelism) is introduced in the language, it might break. That's why the recommended mechanism to communicate data is using channels and sending messages between them. Internally, a channel implements all the locking mechanisms to avoid data races, but from the outside you use them as communication primitives, so you (the user) don't have to use locks.","title":"Communicating data"},{"location":"guides/concurrency.html#sample-code","text":"","title":"Sample code"},{"location":"guides/concurrency.html#spawning-a-fiber","text":"To spawn a fiber you use spawn with a block: spawn do # ... socket . gets # ... end spawn do # ... sleep 5 . seconds # ... end Here we have two fibers: one reads from a socket and the other does a sleep . When the first fiber reaches the socket.gets line, it gets suspended, the Event Loop is told to continue executing this fiber when there's data in the socket, and the program continues with the second fiber. This fiber wants to sleep for 5 seconds, so the Event Loop is told to continue with this fiber in 5 seconds. If there aren't other fibers to execute, the Event Loop will wait until either of these events happen, without consuming CPU time. The reason why socket.gets and sleep behave like this is because their implementations talk directly with the Runtime Scheduler and the Event Loop, there's nothing magical about it. In general, the standard library already takes care of doing all of this so you don't have to. Note, however, that fibers don't get executed right away. For example: spawn do loop do puts \"Hello!\" end end Running the above code will produce no output and exit immediately. The reason for this is that a fiber is not executed as soon as it is spawned. So, the main fiber, the one that spawns the above fiber, finishes its execution and the program exits. One way to solve it is to do a sleep : spawn do loop do puts \"Hello!\" end end sleep 1 . second This program will now print \"Hello!\" for one second and then exit. This is because the sleep call will schedule the main fiber to be executed in a second, and then executes another \"ready to execute\" fiber, which in this case is the one above. Another way is this: spawn do loop do puts \"Hello!\" end end Fiber . yield This time Fiber.yield will tell the scheduler to execute the other fiber. This will print \"Hello!\" until the standard output blocks (the system call will tell us we have to wait until the output is ready), and then execution continues with the main fiber and the program exits. Here the standard output might never block so the program will continue executing forever. If we want to execute the spawned fiber for ever, we can use sleep without arguments: spawn do loop do puts \"Hello!\" end end sleep Of course the above program can be written without spawn at all, just with a loop. sleep is more useful when spawning more than one fiber.","title":"Spawning a fiber"},{"location":"guides/concurrency.html#spawning-a-call","text":"You can also spawn by passing a method call instead of a block. To understand why this is useful, let's look at this example: i = 0 while i < 10 spawn do puts ( i ) end i += 1 end Fiber . yield The above program prints \"10\" ten times. The problem is that there's only one variable i that all spawned fibers refer to, and when Fiber.yield is executed its value is 10. To solve this, we can do this: i = 0 while i < 10 proc = -> ( x : Int32 ) do spawn do puts ( x ) end end proc . call ( i ) i += 1 end Fiber . yield Now it works because we are creating a Proc and we invoke it passing i , so the value gets copied and now the spawned fiber receives a copy. To avoid all this boilerplate, the standard library provides a spawn macro that accepts a call expression and basically rewrites it to do the above. Using it, we end up with: i = 0 while i < 10 spawn puts ( i ) i += 1 end Fiber . yield This is mostly useful with local variables that change at iterations. This doesn't happen with block arguments. For example, this works as expected: 10 . times do | i | spawn do puts i end end Fiber . yield","title":"Spawning a call"},{"location":"guides/concurrency.html#spawning-a-fiber-and-waiting-for-it-to-complete","text":"We can use a channel for this: channel = Channel ( Nil ) . new spawn do puts \"Before send\" channel . send ( nil ) puts \"After send\" end puts \"Before receive\" channel . receive puts \"After receive\" This prints: Before receive Before send After receive First, the program spawns a fiber but doesn't execute it yet. When we invoke channel.receive , the main fiber blocks and execution continues with the spawned fiber. Then channel.send(nil) is invoked, and so execution continues at channel.receive , which was waiting for a value. Then the main fiber continues executing and finishes, so the program exits without giving the other fiber a chance to print \"After send\". In the above example we used nil just to communicate that the fiber ended. We can also use channels to communicate values between fibers: channel = Channel ( Int32 ) . new spawn do puts \"Before first send\" channel . send ( 1 ) puts \"Before second send\" channel . send ( 2 ) end puts \"Before first receive\" value = channel . receive puts value # => 1 puts \"Before second receive\" value = channel . receive puts value # => 2 Output: Before first receive Before first send 1 Before second receive Before second send 2 Note that when the program executes a receive , that fiber blocks and execution continues with the other fiber. When send is executed, execution continues with the fiber that was waiting on that channel. Here we are sending literal values, but the spawned fiber might compute this value by, for example, reading a file, or getting it from a socket. When this fiber will have to wait for I/O, other fibers will be able to continue executing code until I/O is ready, and finally when the value is ready and sent through the channel, the main fiber will receive it. For example: require \"socket\" channel = Channel ( String ) . new spawn do server = TCPServer . new ( \"0.0.0.0\" , 8080 ) socket = server . accept while line = socket . gets channel . send ( line ) end end spawn do while line = gets channel . send ( line ) end end 3 . times do puts channel . receive end The above program spawns two fibers. The first one creates a TCPServer, accepts one connection and reads lines from it, sending them to the channel. There's a second fiber reading lines from standard input. The main fiber reads the first 3 messages sent to the channel, either from the socket or stdin, then the program exits. The gets calls will block the fibers and tell the Event Loop to continue from there if data comes. Likewise, we can wait for multiple fibers to complete execution, and gather their values: channel = Channel ( Int32 ) . new 10 . times do | i | spawn do channel . send ( i * 2 ) end end sum = 0 10 . times do sum += channel . receive end puts sum # => 90 You can, of course, use receive inside a spawned fiber: channel = Channel ( Int32 ) . new spawn do puts \"Before send\" channel . send ( 1 ) puts \"After send\" end spawn do puts \"Before receive\" puts channel . receive puts \"After receive\" end puts \"Before yield\" Fiber . yield puts \"After yield\" Output: Before yield Before send Before receive 1 After receive After send After yield Here channel.send is executed first, but since there's no one waiting for a value (yet), execution continues in other fibers. The second fiber is executed, there's a value on the channel, it's obtained, and execution continues, first with the first fiber, then with the main fiber, because Fiber.yield puts a fiber at the end of the execution queue.","title":"Spawning a fiber and waiting for it to complete"},{"location":"guides/concurrency.html#buffered-channels","text":"The above examples use unbuffered channels: when sending a value, if a fiber is waiting on that channel then execution continues on that fiber. With a buffered channel, invoking send won't switch to another fiber unless the buffer is full: # A buffered channel of capacity 2 channel = Channel ( Int32 ) . new ( 2 ) spawn do puts \"Before send 1\" channel . send ( 1 ) puts \"Before send 2\" channel . send ( 2 ) puts \"Before send 3\" channel . send ( 3 ) puts \"After send\" end 3 . times do | i | puts channel . receive end Output: Before send 1 Before send 2 Before send 3 1 2 After send 3 Note that the first 2 sends are executed without switching to another fiber. However, in the third send the channel's buffer is full, so execution goes to the main fiber. Here the two values are received and the channel is depleted. At the third receive the main fiber blocks and execution goes to the other fiber, which sends more values, finishes, etc.","title":"Buffered channels"},{"location":"guides/performance.html","text":"Performance \u00b6 Follow these tips to get the best out of your programs, both in speed and memory terms. Premature optimization \u00b6 Donald Knuth once said: We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. However, if you are writing a program and you realize that writing a semantically equivalent, faster version involves just minor changes, you shouldn't miss that opportunity. And always be sure to profile your program to learn what its bottlenecks are. For profiling, on macOS you can use Instruments Time Profiler , which comes with XCode, or one of the sampling profilers . On Linux, any program that can profile C/C++ programs, like perf or Callgrind , should work. For both Linux and OS X, you can detect most hotspots by running your program within a debugger then hitting \"ctrl+c\" to interrupt it occasionally and issuing a gdb backtrace command to look for patterns in backtraces (or use the gdb poor man's profiler which does the same thing for you, or OS X sample command. Make sure to always profile programs by compiling or running them with the --release flag, which turns on optimizations. Avoiding memory allocations \u00b6 One of the best optimizations you can do in a program is avoiding extra/useless memory allocation. A memory allocation happens when you create an instance of a class , which ends up allocating heap memory. Creating an instance of a struct uses stack memory and doesn't incur a performance penalty. If you don't know the difference between stack and heap memory, be sure to read this . Allocating heap memory is slow, and it puts more pressure on the Garbage Collector (GC) as it will later have to free that memory. There are several ways to avoid heap memory allocations. The standard library is designed in a way to help you do that. Don't create intermediate strings when writing to an IO \u00b6 To print a number to the standard output you write: puts 123 In many programming languages what will happen is that to_s , or a similar method for converting the object to its string representation, will be invoked, and then that string will be written to the standard output. This works, but it has a flaw: it creates an intermediate string, in heap memory, only to write it and then discard it. This, involves a heap memory allocation and gives a bit of work to the GC. In Crystal, puts will invoke to_s(io) on the object, passing it the IO to which the string representation should be written. So, you should never do this: puts 123 . to_s as it will create an intermediate string. Always append an object directly to an IO. When writing custom types, always be sure to override to_s(io) , not to_s , and avoid creating intermediate strings in that method. For example: class MyClass # Good def to_s ( io ) # appends \"1, 2\" to IO without creating intermediate strings x = 1 y = 2 io << x << \", \" << y end # Bad def to_s ( io ) x = 1 y = 2 # using a string interpolation creates an intermediate string. # this should be avoided io << \" #{ x } , #{ y } \" end end This philosophy of appending to an IO instead of returning an intermediate string results in better performance than handling intermediate strings. You should use this strategy in your API definitions too. Let's compare the times: # io_benchmark.cr require \"benchmark\" io = IO :: Memory . new Benchmark . ips do | x | x . report ( \"without to_s\" ) do io << 123 io . clear end x . report ( \"with to_s\" ) do io << 123 . to_s io . clear end end Output: $ crystal run --release io_benchmark.cr without to_s 77.11M ( 12.97ns) (\u00b1 1.05%) fastest with to_s 18.15M ( 55.09ns) (\u00b1 7.99%) 4.25\u00d7 slower Always remember that it's not just the time that has improved: memory usage is also decreased. Use string interpolation instead of concatenation \u00b6 Sometimes you need to work directly with strings built from combining string literals with other values. You shouldn't just concatenate these strings with String#+(String) but rather use string interpolation which allows to embed expressions into a string literal: \"Hello, #{name}\" is better than \"Hello, \" + name.to_s . Interpolated strings are transformed by the compiler to append to a string IO so that it automatically avoids intermediate strings. The example above translates to: String . build do | io | io << \"Hello, \" << name end Avoid IO allocation for string building \u00b6 Prefer to use the dedicated String.build optimized for building strings, instead of creating an intermediate IO::Memory allocation. require \"benchmark\" Benchmark . ips do | bm | bm . report ( \"String.build\" ) do String . build do | io | 99 . times do io << \"hello world\" end end end bm . report ( \"IO::Memory\" ) do io = IO :: Memory . new 99 . times do io << \"hello world\" end io . to_s end end Output: $ crystal run --release str_benchmark.cr String.build 597.57k ( 1.67\u00b5s) (\u00b1 5.52%) fastest IO::Memory 423.82k ( 2.36\u00b5s) (\u00b1 3.76%) 1.41\u00d7 slower Avoid creating temporary objects over and over \u00b6 Consider this program: lines_with_language_reference = 0 while line = gets if [ \"crystal\" , \"ruby\" , \"java\" ]. any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" The above program works but has a big performance problem: on every iteration a new array is created for [\"crystal\", \"ruby\", \"java\"] . Remember: an array literal is just syntax sugar for creating an instance of an array and adding some values to it, and this will happen over and over on each iteration. There are two ways to solve this: Use a tuple. If you use {\"crystal\", \"ruby\", \"java\"} in the above program it will work the same way, but since a tuple doesn't involve heap memory it will be faster, consume less memory, and give more chances for the compiler to optimize the program. lines_with_language_reference = 0 while line = gets if { \"crystal\" , \"ruby\" , \"java\" } . any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" Move the array to a constant. LANGS = [ \"crystal\" , \"ruby\" , \"java\" ] lines_with_language_reference = 0 while line = gets if LANGS . any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" Using tuples is the preferred way. Explicit array literals in loops is one way to create temporary objects, but these can also be created via method calls. For example Hash#keys will return a new array with the keys each time it's invoked. Instead of doing that, you can use Hash#each_key , Hash#has_key? and other methods. Use structs when possible \u00b6 If you declare your type as a struct instead of a class , creating an instance of it will use stack memory, which is much cheaper than heap memory and doesn't put pressure on the GC. You shouldn't always use a struct, though. Structs are passed by value, so if you pass one to a method and the method makes changes to it, the caller won't see those changes, so they can be bug-prone. The best thing to do is to only use structs with immutable objects, especially if they are small. For example: # class_vs_struct.cr require \"benchmark\" class PointClass getter x getter y def initialize ( @x : Int32 , @y : Int32 ) end end struct PointStruct getter x getter y def initialize ( @x : Int32 , @y : Int32 ) end end Benchmark . ips do | x | x . report ( \"class\" ) { PointClass . new ( 1 , 2 ) } x . report ( \"struct\" ) { PointStruct . new ( 1 , 2 ) } end Output: $ crystal run --release class_vs_struct.cr class 28.17M (\u00b1 2.86%) 15.29\u00d7 slower struct 430.82M (\u00b1 6.58%) fastest Iterating strings \u00b6 Strings in Crystal always contain UTF-8 encoded bytes. UTF-8 is a variable-length encoding: a character may be represented by several bytes, although characters in the ASCII range are always represented by a single byte. Because of this, indexing a string with String#[] is not an O(1) operation, as the bytes need to be decoded each time to find the character at the given position. There's an optimization that Crystal's String does here: if it knows all the characters in the string are ASCII, then String#[] can be implemented in O(1) . However, this isn't generally true. For this reason, iterating a String in this way is not optimal, and in fact has a complexity of O(n^2) : string = \"foo\" while i < string . size char = string [ i ] # ... end There's a second problem with the above: computing the size of a String is also slow, because it's not simply the number of bytes in the string (the bytesize ). However, once a String's size has been computed, it is cached. The way to improve performance in this case is to either use one of the iteration methods ( each_char , each_byte , each_codepoint ), or use the more low-level Char::Reader struct. For example, using each_char : string = \"foo\" string . each_char do | char | # ... end","title":"Performance"},{"location":"guides/performance.html#performance","text":"Follow these tips to get the best out of your programs, both in speed and memory terms.","title":"Performance"},{"location":"guides/performance.html#premature-optimization","text":"Donald Knuth once said: We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. However, if you are writing a program and you realize that writing a semantically equivalent, faster version involves just minor changes, you shouldn't miss that opportunity. And always be sure to profile your program to learn what its bottlenecks are. For profiling, on macOS you can use Instruments Time Profiler , which comes with XCode, or one of the sampling profilers . On Linux, any program that can profile C/C++ programs, like perf or Callgrind , should work. For both Linux and OS X, you can detect most hotspots by running your program within a debugger then hitting \"ctrl+c\" to interrupt it occasionally and issuing a gdb backtrace command to look for patterns in backtraces (or use the gdb poor man's profiler which does the same thing for you, or OS X sample command. Make sure to always profile programs by compiling or running them with the --release flag, which turns on optimizations.","title":"Premature optimization"},{"location":"guides/performance.html#avoiding-memory-allocations","text":"One of the best optimizations you can do in a program is avoiding extra/useless memory allocation. A memory allocation happens when you create an instance of a class , which ends up allocating heap memory. Creating an instance of a struct uses stack memory and doesn't incur a performance penalty. If you don't know the difference between stack and heap memory, be sure to read this . Allocating heap memory is slow, and it puts more pressure on the Garbage Collector (GC) as it will later have to free that memory. There are several ways to avoid heap memory allocations. The standard library is designed in a way to help you do that.","title":"Avoiding memory allocations"},{"location":"guides/performance.html#dont-create-intermediate-strings-when-writing-to-an-io","text":"To print a number to the standard output you write: puts 123 In many programming languages what will happen is that to_s , or a similar method for converting the object to its string representation, will be invoked, and then that string will be written to the standard output. This works, but it has a flaw: it creates an intermediate string, in heap memory, only to write it and then discard it. This, involves a heap memory allocation and gives a bit of work to the GC. In Crystal, puts will invoke to_s(io) on the object, passing it the IO to which the string representation should be written. So, you should never do this: puts 123 . to_s as it will create an intermediate string. Always append an object directly to an IO. When writing custom types, always be sure to override to_s(io) , not to_s , and avoid creating intermediate strings in that method. For example: class MyClass # Good def to_s ( io ) # appends \"1, 2\" to IO without creating intermediate strings x = 1 y = 2 io << x << \", \" << y end # Bad def to_s ( io ) x = 1 y = 2 # using a string interpolation creates an intermediate string. # this should be avoided io << \" #{ x } , #{ y } \" end end This philosophy of appending to an IO instead of returning an intermediate string results in better performance than handling intermediate strings. You should use this strategy in your API definitions too. Let's compare the times: # io_benchmark.cr require \"benchmark\" io = IO :: Memory . new Benchmark . ips do | x | x . report ( \"without to_s\" ) do io << 123 io . clear end x . report ( \"with to_s\" ) do io << 123 . to_s io . clear end end Output: $ crystal run --release io_benchmark.cr without to_s 77.11M ( 12.97ns) (\u00b1 1.05%) fastest with to_s 18.15M ( 55.09ns) (\u00b1 7.99%) 4.25\u00d7 slower Always remember that it's not just the time that has improved: memory usage is also decreased.","title":"Don't create intermediate strings when writing to an IO"},{"location":"guides/performance.html#use-string-interpolation-instead-of-concatenation","text":"Sometimes you need to work directly with strings built from combining string literals with other values. You shouldn't just concatenate these strings with String#+(String) but rather use string interpolation which allows to embed expressions into a string literal: \"Hello, #{name}\" is better than \"Hello, \" + name.to_s . Interpolated strings are transformed by the compiler to append to a string IO so that it automatically avoids intermediate strings. The example above translates to: String . build do | io | io << \"Hello, \" << name end","title":"Use string interpolation instead of concatenation"},{"location":"guides/performance.html#avoid-io-allocation-for-string-building","text":"Prefer to use the dedicated String.build optimized for building strings, instead of creating an intermediate IO::Memory allocation. require \"benchmark\" Benchmark . ips do | bm | bm . report ( \"String.build\" ) do String . build do | io | 99 . times do io << \"hello world\" end end end bm . report ( \"IO::Memory\" ) do io = IO :: Memory . new 99 . times do io << \"hello world\" end io . to_s end end Output: $ crystal run --release str_benchmark.cr String.build 597.57k ( 1.67\u00b5s) (\u00b1 5.52%) fastest IO::Memory 423.82k ( 2.36\u00b5s) (\u00b1 3.76%) 1.41\u00d7 slower","title":"Avoid IO allocation for string building"},{"location":"guides/performance.html#avoid-creating-temporary-objects-over-and-over","text":"Consider this program: lines_with_language_reference = 0 while line = gets if [ \"crystal\" , \"ruby\" , \"java\" ]. any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" The above program works but has a big performance problem: on every iteration a new array is created for [\"crystal\", \"ruby\", \"java\"] . Remember: an array literal is just syntax sugar for creating an instance of an array and adding some values to it, and this will happen over and over on each iteration. There are two ways to solve this: Use a tuple. If you use {\"crystal\", \"ruby\", \"java\"} in the above program it will work the same way, but since a tuple doesn't involve heap memory it will be faster, consume less memory, and give more chances for the compiler to optimize the program. lines_with_language_reference = 0 while line = gets if { \"crystal\" , \"ruby\" , \"java\" } . any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" Move the array to a constant. LANGS = [ \"crystal\" , \"ruby\" , \"java\" ] lines_with_language_reference = 0 while line = gets if LANGS . any? { | string | line . includes? ( string ) } lines_with_language_reference += 1 end end puts \"Lines that mention crystal, ruby or java: #{ lines_with_language_reference } \" Using tuples is the preferred way. Explicit array literals in loops is one way to create temporary objects, but these can also be created via method calls. For example Hash#keys will return a new array with the keys each time it's invoked. Instead of doing that, you can use Hash#each_key , Hash#has_key? and other methods.","title":"Avoid creating temporary objects over and over"},{"location":"guides/performance.html#use-structs-when-possible","text":"If you declare your type as a struct instead of a class , creating an instance of it will use stack memory, which is much cheaper than heap memory and doesn't put pressure on the GC. You shouldn't always use a struct, though. Structs are passed by value, so if you pass one to a method and the method makes changes to it, the caller won't see those changes, so they can be bug-prone. The best thing to do is to only use structs with immutable objects, especially if they are small. For example: # class_vs_struct.cr require \"benchmark\" class PointClass getter x getter y def initialize ( @x : Int32 , @y : Int32 ) end end struct PointStruct getter x getter y def initialize ( @x : Int32 , @y : Int32 ) end end Benchmark . ips do | x | x . report ( \"class\" ) { PointClass . new ( 1 , 2 ) } x . report ( \"struct\" ) { PointStruct . new ( 1 , 2 ) } end Output: $ crystal run --release class_vs_struct.cr class 28.17M (\u00b1 2.86%) 15.29\u00d7 slower struct 430.82M (\u00b1 6.58%) fastest","title":"Use structs when possible"},{"location":"guides/performance.html#iterating-strings","text":"Strings in Crystal always contain UTF-8 encoded bytes. UTF-8 is a variable-length encoding: a character may be represented by several bytes, although characters in the ASCII range are always represented by a single byte. Because of this, indexing a string with String#[] is not an O(1) operation, as the bytes need to be decoded each time to find the character at the given position. There's an optimization that Crystal's String does here: if it knows all the characters in the string are ASCII, then String#[] can be implemented in O(1) . However, this isn't generally true. For this reason, iterating a String in this way is not optimal, and in fact has a complexity of O(n^2) : string = \"foo\" while i < string . size char = string [ i ] # ... end There's a second problem with the above: computing the size of a String is also slow, because it's not simply the number of bytes in the string (the bytesize ). However, once a String's size has been computed, it is cached. The way to improve performance in this case is to either use one of the iteration methods ( each_char , each_byte , each_codepoint ), or use the more low-level Char::Reader struct. For example, using each_char : string = \"foo\" string . each_char do | char | # ... end","title":"Iterating strings"},{"location":"guides/static_linking.html","text":"Static Linking \u00b6 Crystal supports static linking, i.e. it can link a binary with static libraries so that these libraries don't need to be available as runtime dependencies. Static linking can be enabled using the --static compiler flag. See the usage instructions in the language reference. When --static is given, linking static libraries is enabled, but it's not exclusive. The produced binary won't be fully static linked if the dynamic version of a library is higher in the compiler's library lookup chain than the static variant (or if the static library is entirely missing). In order to build a static binary you need to make sure that static versions of the linked libraries are available and the compiler can find them. The compiler uses the CRYSTAL_LIBRARY_PATH environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries. Not all libraries work well with being statically linked, so there may be some issues. openssl for example is known for complications, as well as glibc (see Fully Static Linking ). Some package managers provide specific packages for static libraries, where foo provides the dynamic library and foo-static for example provides the static library. Sometimes static libraries are also included in development packages. Fully Static Linking \u00b6 A fully statically linked program has no dynamic library dependencies at all. Prominent examples of fully statically linked Crystal programs are the crystal and shards binaries from the official distribution packages. In order to link a program fully statically, all dependencies need to be available as static libraries at compiler time. This can be tricky sometimes, especially with common libc libraries. Linux \u00b6 glibc \u00b6 glibc is the most common libc implementation on Linux systems. Unfortunately, it doesn't play nicely with static linking and it's highly discouraged. Instead, static linking against musl-libc is the recommended option on Linux. Since it's statically linked, a binary linked against musl-libc will also run on a glibc system. That's the entire point of it. musl-libc \u00b6 musl-libc is a clean, efficient libc implementation with excellent static linking support. The recommended way to build a statically linked Crystal program is Alpine Linux , a minimal Linux distribution based on musl-libc . Official Docker Images based on Alpine Linux are available on Docker Hub at crystallang/crystal . The latest release is tagged as crystallang/crystal:latest-alpine . The Dockerfile source is available at crystal-lang/distribution-scripts . With pre-installed crystal compiler, shards , and static libraries of all of stdlib's dependencies these Docker images allow to easily build static Crystal binaries even from glibc -based systems. The official Crystal compiler builds for Linux are created using these images. Here's an example how the Docker image can be used to build a statically linked Hello World program: $ echo 'puts \"Hello World!\"' > hello-world.cr $ docker run --rm -it -v $( pwd ) :/workspace -w /workspace crystallang/crystal:latest-alpine \\ crystal build hello-world.cr --static $ ./hello-world Hello World! $ ldd hello-world statically linked Alpine\u2019s package manager APK is als easy to work with to install static libraries. Available packages can be found at pkgs.alpinelinux.org . macOS \u00b6 macOS doesn't officially support fully static linking because the required system libraries are not available as static libraries.","title":"Static Linking"},{"location":"guides/static_linking.html#static-linking","text":"Crystal supports static linking, i.e. it can link a binary with static libraries so that these libraries don't need to be available as runtime dependencies. Static linking can be enabled using the --static compiler flag. See the usage instructions in the language reference. When --static is given, linking static libraries is enabled, but it's not exclusive. The produced binary won't be fully static linked if the dynamic version of a library is higher in the compiler's library lookup chain than the static variant (or if the static library is entirely missing). In order to build a static binary you need to make sure that static versions of the linked libraries are available and the compiler can find them. The compiler uses the CRYSTAL_LIBRARY_PATH environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries. Not all libraries work well with being statically linked, so there may be some issues. openssl for example is known for complications, as well as glibc (see Fully Static Linking ). Some package managers provide specific packages for static libraries, where foo provides the dynamic library and foo-static for example provides the static library. Sometimes static libraries are also included in development packages.","title":"Static Linking"},{"location":"guides/static_linking.html#fully-static-linking","text":"A fully statically linked program has no dynamic library dependencies at all. Prominent examples of fully statically linked Crystal programs are the crystal and shards binaries from the official distribution packages. In order to link a program fully statically, all dependencies need to be available as static libraries at compiler time. This can be tricky sometimes, especially with common libc libraries.","title":"Fully Static Linking"},{"location":"guides/static_linking.html#linux","text":"","title":"Linux"},{"location":"guides/static_linking.html#glibc","text":"glibc is the most common libc implementation on Linux systems. Unfortunately, it doesn't play nicely with static linking and it's highly discouraged. Instead, static linking against musl-libc is the recommended option on Linux. Since it's statically linked, a binary linked against musl-libc will also run on a glibc system. That's the entire point of it.","title":"glibc"},{"location":"guides/static_linking.html#musl-libc","text":"musl-libc is a clean, efficient libc implementation with excellent static linking support. The recommended way to build a statically linked Crystal program is Alpine Linux , a minimal Linux distribution based on musl-libc . Official Docker Images based on Alpine Linux are available on Docker Hub at crystallang/crystal . The latest release is tagged as crystallang/crystal:latest-alpine . The Dockerfile source is available at crystal-lang/distribution-scripts . With pre-installed crystal compiler, shards , and static libraries of all of stdlib's dependencies these Docker images allow to easily build static Crystal binaries even from glibc -based systems. The official Crystal compiler builds for Linux are created using these images. Here's an example how the Docker image can be used to build a statically linked Hello World program: $ echo 'puts \"Hello World!\"' > hello-world.cr $ docker run --rm -it -v $( pwd ) :/workspace -w /workspace crystallang/crystal:latest-alpine \\ crystal build hello-world.cr --static $ ./hello-world Hello World! $ ldd hello-world statically linked Alpine\u2019s package manager APK is als easy to work with to install static libraries. Available packages can be found at pkgs.alpinelinux.org .","title":"musl-libc"},{"location":"guides/static_linking.html#macos","text":"macOS doesn't officially support fully static linking because the required system libraries are not available as static libraries.","title":"macOS"},{"location":"guides/testing.html","text":"Testing Crystal Code \u00b6 Crystal comes with a fully-featured spec library in the Spec module . It provides a structure for writing executable examples of how your code should behave. Inspired by Rspec , it includes a domain specific language (DSL) that allows you to write examples in a way similar to plain english. A basic spec looks something like this: require \"spec\" describe Array do describe \"#size\" do it \"correctly reports the number of elements in the Array\" do [ 1 , 2 , 3 ]. size . should eq 3 end end describe \"#empty?\" do it \"is true when no elements are in the array\" do ( [] of Int32 ) . empty? . should be_true end it \"is false if there are elements in the array\" do [ 1 ]. empty? . should be_false end end end Anatomy of a spec file \u00b6 To use the spec module and DSL, you need to add require \"spec\" to your spec files. Many projects use a custom spec helper which organizes these includes. Concrete test cases are defined in it blocks. An optional (but strongly recommended) descriptive string states it's purpose and a block contains the main logic performing the test. Test cases that have been defined or outlined but are not yet expected to work can be defined using pending instead of it . They will not be run but show up in the spec report as pending. An it block contains an example that should invoke the code to be tested and define what is expected of it. Each example can contain multiple expectations, but it should test only one specific behaviour. When spec is included, every object has the instance methods #should and #should_not . These methods are invoked on the value being tested with an expectation as argument. If the expectation is met, code execution continues. Otherwise the example has failed and other code in this block will not be executed. In test files, specs are structured by example groups which are defined by describe and context sections. Typically a top level describe defines the outer unit (such as a class) to be tested by the spec. Further describe sections can be nested within the outer unit to specify smaller units under test (such as individual methods). For unit tests, it is recommended to follow the conventions for method names: Outer describe is the name of the class, inner describe targets methods. Instance methods are prefixed with # , class methods with . . To establish certain contexts - think empty array versus array with elements - the context method may be used to communicate this to the reader. It has a different name, but behaves exactly like describe . describe and context take a description as argument (which should usually be a string) and a block containing the individual specs or nested groupings. Expectations \u00b6 Expectations define if the value being tested ( actual ) matches a certain value or specific criteria. Equivalence, Identity and Type \u00b6 There are methods to create expectations which test for equivalence ( eq ), identity ( be ), type ( be_a ), and nil ( be_nil ). Note that the identity expectation uses .same? which tests if #object_id are identical. This is only true if the expected value points to the same object instead of an equivalent one . This is only possible for reference types and won't work for value types like structs or numbers. actual . should eq ( expected ) # passes if actual == expected actual . should be ( expected ) # passes if actual.same?(expected) actual . should be_a ( expected ) # passes if actual.is_a?(expected) actual . should be_nil # passes if actual.nil? Truthiness \u00b6 actual . should be_true # passes if actual == true actual . should be_false # passes if actual == false actual . should be_truthy # passes if actual is truthy (neither nil nor false nor Pointer.null) actual . should be_falsey # passes if actual is falsey (nil, false or Pointer.null) Comparisons \u00b6 actual . should be < expected # passes if actual < expected actual . should be <= expected # passes if actual <= expected actual . should be > expected # passes if actual > expected actual . should be >= expected # passes if actual >= expected Other matchers \u00b6 actual . should be_close ( expected , delta ) # passes if actual is within delta of expected: # (actual - expected).abs <= delta actual . should contain ( expected ) # passes if actual.includes?(expected) actual . should match ( expected ) # passes if actual =~ expected Expecting errors \u00b6 These matchers run a block and pass if it raises a certain exception. expect_raises ( MyError ) do # Passes if this block raises an exception of type MyError. end expect_raises ( MyError , \"error message\" ) do # Passes if this block raises an exception of type MyError # and the error message contains \"error message\". end expect_raises ( MyError , /error \\w{7}/ ) do # Passes if this block raises an exception of type MyError # and the error message matches the regular expression. end They return the rescued exception so it can be used for further expectations, for example to verify specific properties of the exception. Focusing on a group of specs \u00b6 describe , context and it blocks can be marked with focus: true , like this: it \"adds\" , focus : true do ( 2 + 2 ) . should_not eq ( 5 ) end If any such thing is marked with focus: true then only those examples will run. Tagging specs \u00b6 Tags can be used to group specs, allowing to only run a subset of specs when providing a --tag argument to the spec runner (see Using the compiler ). describe , context and it blocks can be tagged, like this: it \"is slow\" , tags : \"slow\" do sleep 60 true . should be ( true ) end it \"is fast\" , tags : \"fast\" do true . should be ( true ) end Tagging an example group ( describe or context ) extends to all of the contained examples. Multiple tags can be specified by giving an Enumerable , such as Array or Set . Running specs \u00b6 The Crystal compiler has a spec command with tools to constrain which examples get run and tailor the output. All specs of a project are compiled and executed through the command crystal spec . By convention, specs live in the spec/ directory of a project. Spec files must end with _spec.cr to be recognizable as such by the compiler command. You can compile and run specs from folder trees, individual files, or specific lines in a file. If the specified line is the beginning of a describe or context section, all specs inside that group are run. The default formatter outputs the file and line style command for failing specs which makes it easy to rerun just this individual spec. You can turn off colors with the switch --no-color . Randomizing order of specs \u00b6 Specs, by default, run in the order defined, but can be run in a random order by passing --order random to crystal spec . Specs run in random order will display a seed value upon completion. This seed value can be used to rerun the specs in that same order by passing the seed value to --order . Examples \u00b6 # Run all specs in files matching spec/**/*_spec.cr crystal spec # Run all specs in files matching spec/**/*_spec.cr without colors crystal spec --no-color # Run all specs in files matching spec/my/test/**/*_spec.cr crystal spec spec/my/test/ # Run all specs in spec/my/test/file_spec.cr crystal spec spec/my/test/file_spec.cr # Run the spec or group defined in line 14 of spec/my/test/file_spec.cr crystal spec spec/my/test/file_spec.cr:14 # Run all specs tagged with \"fast\" crystal spec --tag 'fast' # Run all specs not tagged with \"slow\" crystal spec --tag '~slow' Spec helper \u00b6 Many projects use a custom spec helper file, usually named spec/spec_helper.cr . This file is used to require spec and other includes like code from the project needed for every spec file. This is also a good place to define global helper methods that make writing specs easier and avoid code duplication. # spec/spec_helper.cr require \"spec\" require \"../src/my_project.cr\" def create_test_object ( name ) project = MyProject . new ( option : false ) object = project . create_object ( name ) object end # spec/my_project_spec.cr require \"./spec_helper\" describe \"MyProject::Object\" do it \"is created\" do object = create_test_object ( name ) object . should_not be_nil end end","title":"Testing"},{"location":"guides/testing.html#testing-crystal-code","text":"Crystal comes with a fully-featured spec library in the Spec module . It provides a structure for writing executable examples of how your code should behave. Inspired by Rspec , it includes a domain specific language (DSL) that allows you to write examples in a way similar to plain english. A basic spec looks something like this: require \"spec\" describe Array do describe \"#size\" do it \"correctly reports the number of elements in the Array\" do [ 1 , 2 , 3 ]. size . should eq 3 end end describe \"#empty?\" do it \"is true when no elements are in the array\" do ( [] of Int32 ) . empty? . should be_true end it \"is false if there are elements in the array\" do [ 1 ]. empty? . should be_false end end end","title":"Testing Crystal Code"},{"location":"guides/testing.html#anatomy-of-a-spec-file","text":"To use the spec module and DSL, you need to add require \"spec\" to your spec files. Many projects use a custom spec helper which organizes these includes. Concrete test cases are defined in it blocks. An optional (but strongly recommended) descriptive string states it's purpose and a block contains the main logic performing the test. Test cases that have been defined or outlined but are not yet expected to work can be defined using pending instead of it . They will not be run but show up in the spec report as pending. An it block contains an example that should invoke the code to be tested and define what is expected of it. Each example can contain multiple expectations, but it should test only one specific behaviour. When spec is included, every object has the instance methods #should and #should_not . These methods are invoked on the value being tested with an expectation as argument. If the expectation is met, code execution continues. Otherwise the example has failed and other code in this block will not be executed. In test files, specs are structured by example groups which are defined by describe and context sections. Typically a top level describe defines the outer unit (such as a class) to be tested by the spec. Further describe sections can be nested within the outer unit to specify smaller units under test (such as individual methods). For unit tests, it is recommended to follow the conventions for method names: Outer describe is the name of the class, inner describe targets methods. Instance methods are prefixed with # , class methods with . . To establish certain contexts - think empty array versus array with elements - the context method may be used to communicate this to the reader. It has a different name, but behaves exactly like describe . describe and context take a description as argument (which should usually be a string) and a block containing the individual specs or nested groupings.","title":"Anatomy of a spec file"},{"location":"guides/testing.html#expectations","text":"Expectations define if the value being tested ( actual ) matches a certain value or specific criteria.","title":"Expectations"},{"location":"guides/testing.html#equivalence-identity-and-type","text":"There are methods to create expectations which test for equivalence ( eq ), identity ( be ), type ( be_a ), and nil ( be_nil ). Note that the identity expectation uses .same? which tests if #object_id are identical. This is only true if the expected value points to the same object instead of an equivalent one . This is only possible for reference types and won't work for value types like structs or numbers. actual . should eq ( expected ) # passes if actual == expected actual . should be ( expected ) # passes if actual.same?(expected) actual . should be_a ( expected ) # passes if actual.is_a?(expected) actual . should be_nil # passes if actual.nil?","title":"Equivalence, Identity and Type"},{"location":"guides/testing.html#truthiness","text":"actual . should be_true # passes if actual == true actual . should be_false # passes if actual == false actual . should be_truthy # passes if actual is truthy (neither nil nor false nor Pointer.null) actual . should be_falsey # passes if actual is falsey (nil, false or Pointer.null)","title":"Truthiness"},{"location":"guides/testing.html#comparisons","text":"actual . should be < expected # passes if actual < expected actual . should be <= expected # passes if actual <= expected actual . should be > expected # passes if actual > expected actual . should be >= expected # passes if actual >= expected","title":"Comparisons"},{"location":"guides/testing.html#other-matchers","text":"actual . should be_close ( expected , delta ) # passes if actual is within delta of expected: # (actual - expected).abs <= delta actual . should contain ( expected ) # passes if actual.includes?(expected) actual . should match ( expected ) # passes if actual =~ expected","title":"Other matchers"},{"location":"guides/testing.html#expecting-errors","text":"These matchers run a block and pass if it raises a certain exception. expect_raises ( MyError ) do # Passes if this block raises an exception of type MyError. end expect_raises ( MyError , \"error message\" ) do # Passes if this block raises an exception of type MyError # and the error message contains \"error message\". end expect_raises ( MyError , /error \\w{7}/ ) do # Passes if this block raises an exception of type MyError # and the error message matches the regular expression. end They return the rescued exception so it can be used for further expectations, for example to verify specific properties of the exception.","title":"Expecting errors"},{"location":"guides/testing.html#focusing-on-a-group-of-specs","text":"describe , context and it blocks can be marked with focus: true , like this: it \"adds\" , focus : true do ( 2 + 2 ) . should_not eq ( 5 ) end If any such thing is marked with focus: true then only those examples will run.","title":"Focusing on a group of specs"},{"location":"guides/testing.html#tagging-specs","text":"Tags can be used to group specs, allowing to only run a subset of specs when providing a --tag argument to the spec runner (see Using the compiler ). describe , context and it blocks can be tagged, like this: it \"is slow\" , tags : \"slow\" do sleep 60 true . should be ( true ) end it \"is fast\" , tags : \"fast\" do true . should be ( true ) end Tagging an example group ( describe or context ) extends to all of the contained examples. Multiple tags can be specified by giving an Enumerable , such as Array or Set .","title":"Tagging specs"},{"location":"guides/testing.html#running-specs","text":"The Crystal compiler has a spec command with tools to constrain which examples get run and tailor the output. All specs of a project are compiled and executed through the command crystal spec . By convention, specs live in the spec/ directory of a project. Spec files must end with _spec.cr to be recognizable as such by the compiler command. You can compile and run specs from folder trees, individual files, or specific lines in a file. If the specified line is the beginning of a describe or context section, all specs inside that group are run. The default formatter outputs the file and line style command for failing specs which makes it easy to rerun just this individual spec. You can turn off colors with the switch --no-color .","title":"Running specs"},{"location":"guides/testing.html#randomizing-order-of-specs","text":"Specs, by default, run in the order defined, but can be run in a random order by passing --order random to crystal spec . Specs run in random order will display a seed value upon completion. This seed value can be used to rerun the specs in that same order by passing the seed value to --order .","title":"Randomizing order of specs"},{"location":"guides/testing.html#examples","text":"# Run all specs in files matching spec/**/*_spec.cr crystal spec # Run all specs in files matching spec/**/*_spec.cr without colors crystal spec --no-color # Run all specs in files matching spec/my/test/**/*_spec.cr crystal spec spec/my/test/ # Run all specs in spec/my/test/file_spec.cr crystal spec spec/my/test/file_spec.cr # Run the spec or group defined in line 14 of spec/my/test/file_spec.cr crystal spec spec/my/test/file_spec.cr:14 # Run all specs tagged with \"fast\" crystal spec --tag 'fast' # Run all specs not tagged with \"slow\" crystal spec --tag '~slow'","title":"Examples"},{"location":"guides/testing.html#spec-helper","text":"Many projects use a custom spec helper file, usually named spec/spec_helper.cr . This file is used to require spec and other includes like code from the project needed for every spec file. This is also a good place to define global helper methods that make writing specs easier and avoid code duplication. # spec/spec_helper.cr require \"spec\" require \"../src/my_project.cr\" def create_test_object ( name ) project = MyProject . new ( option : false ) object = project . create_object ( name ) object end # spec/my_project_spec.cr require \"./spec_helper\" describe \"MyProject::Object\" do it \"is created\" do object = create_test_object ( name ) object . should_not be_nil end end","title":"Spec helper"},{"location":"guides/writing_shards.html","text":"Writing Shards \u00b6 How to write and release Crystal Shards. What's a Shard? \u00b6 Simply put, a Shard is a package of Crystal code, made to be shared-with and used-by other projects. See the Shards command for details. Introduction \u00b6 In this tutorial, we'll be making a Crystal library called palindrome-example . For those who don't know, a palindrome is a word which is spelled the same way forwards as it is backwards. e.g. racecar, mom, dad, kayak, madam Requirements \u00b6 In order to release a Crystal Shard, and follow along with this tutorial, you will need the following: A working installation of the Crystal compiler A working installation of Git A GitHub or GitLab account Creating the Project \u00b6 Begin by using the Crystal compiler 's init lib command to create a Crystal library with the standard directory structure. In your terminal: crystal init lib <YOUR-SHARD-NAME> e.g. $ crystal init lib palindrome-example create palindrome-example/.gitignore create palindrome-example/.editorconfig create palindrome-example/LICENSE create palindrome-example/README.md create palindrome-example/.travis.yml create palindrome-example/shard.yml create palindrome-example/src/palindrome-example.cr create palindrome-example/src/palindrome-example/version.cr create palindrome-example/spec/spec_helper.cr create palindrome-example/spec/palindrome-example_spec.cr Initialized empty Git repository in /<YOUR-DIRECTORY>/.../palindrome-example/.git/ ...and cd into the directory: e.g. cd palindrome-example Then add & commit to start tracking the files with Git: $ git add -A $ git commit -am \"First Commit\" [master (root-commit) 77bad84] First Commit 10 files changed, 102 insertions(+) create mode 100644 .editorconfig create mode 100644 .gitignore create mode 100644 .travis.yml create mode 100644 LICENSE create mode 100644 README.md create mode 100644 shard.yml create mode 100644 spec/palindrome-example_spec.cr create mode 100644 spec/spec_helper.cr create mode 100644 src/palindrome-example.cr create mode 100644 src/palindrome-example/version.cr Writing the Code \u00b6 The code you write is up to you, but how you write it impacts whether people want to use your library and/or help you maintain it. Testing the Code \u00b6 Test your code. All of it. It's the only way for anyone, including you, to know if it works. Crystal has a built-in testing library . Use it! Documentation \u00b6 Document your code with comments. All of it. Even the private methods. Crystal has a built-in documentation generator . Use it! Run crystal docs to convert your code and comments into interlinking API documentation. Open the files in the /docs/ directory with a web browser to see how your documentation is looking along the way. See below for instructions on hosting your compiler-generated docs on GitHub/GitLab Pages. Once your documentation is ready and available, you can add a documentation badge to your repository so users know that it exists. In GitLab this badge belongs to the project so we'll cover it in the GitLab instructions below, for GitHub it is common to place it below the description in your README.md like so: (Be sure to replace <LINK-TO-YOUR-DOCUMENTATION> accordingly) [![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](<LINK-TO-YOUR-DOCUMENTATION>) Writing a README \u00b6 A good README can make or break your project. Awesome README is a nice curation of examples and resources on the topic. Most importantly, your README should explain: What your library is What it does How to use it This explanation should include a few examples along with subheadings. Note Be sure to replace all instances of [your-github-name] in the Crystal-generated README template with your GitHub/GitLab username. If you're using GitLab, you'll also want to change all instances of github with gitlab . Coding Style \u00b6 It's fine to have your own style, but sticking to some core rubrics defined by the Crystal team can help keep your code consistent, readable and usable for other developers. Utilize Crystal's built-in code formatter to automatically format all .cr files in a directory. e.g. crystal tool format To check if your code is formatted correctly, or to check if using the formatter wouldn't produce any changes, simply add --check to the end of this command. e.g. crystal tool format --check See the Travis CI section below to implement this in your build. Writing a shard.yml \u00b6 The spec is your rulebook. Follow it. Name \u00b6 Your shard.yml 's name property should be concise and descriptive. Search crystalshards.xyz to check if your name is already taken. e.g. name : palindrome-example Description \u00b6 Add a description to your shard.yml . A description is a single line description used to search for and find your shard. A description should be: Informative Discoverable Optimizing \u00b6 It's hard for anyone to use your project if they can't find it. crystalshards.xyz is currently the go-to place for Crystal libraries, so that's what we'll optimize for. There are people looking for the exact functionality of our library and the general functionality of our library. e.g. Bob needs a palindrome library, but Felipe is just looking for libraries involving text and Susan is looking for libraries involving spelling. Our name is already descriptive enough for Bob's search of \"palindrome\". We don't need to repeat the palindrome keyword. Instead, we'll catch Susan's search for \"spelling\" and Felipe's search for \"text\". description : | A textual algorithm to tell if a word is spelled the same way forwards as it is backwards. Hosting \u00b6 From here the guide differs depending on whether you are hosting your repo on GitHub or GitLab. If you're hosting somewhere else, please feel free to write up a guide and add it to this book! Hosting on GitHub Hosting on GitLab","title":"Writing Shards"},{"location":"guides/writing_shards.html#writing-shards","text":"How to write and release Crystal Shards.","title":"Writing Shards"},{"location":"guides/writing_shards.html#whats-a-shard","text":"Simply put, a Shard is a package of Crystal code, made to be shared-with and used-by other projects. See the Shards command for details.","title":"What's a Shard?"},{"location":"guides/writing_shards.html#introduction","text":"In this tutorial, we'll be making a Crystal library called palindrome-example . For those who don't know, a palindrome is a word which is spelled the same way forwards as it is backwards. e.g. racecar, mom, dad, kayak, madam","title":"Introduction"},{"location":"guides/writing_shards.html#requirements","text":"In order to release a Crystal Shard, and follow along with this tutorial, you will need the following: A working installation of the Crystal compiler A working installation of Git A GitHub or GitLab account","title":"Requirements"},{"location":"guides/writing_shards.html#creating-the-project","text":"Begin by using the Crystal compiler 's init lib command to create a Crystal library with the standard directory structure. In your terminal: crystal init lib <YOUR-SHARD-NAME> e.g. $ crystal init lib palindrome-example create palindrome-example/.gitignore create palindrome-example/.editorconfig create palindrome-example/LICENSE create palindrome-example/README.md create palindrome-example/.travis.yml create palindrome-example/shard.yml create palindrome-example/src/palindrome-example.cr create palindrome-example/src/palindrome-example/version.cr create palindrome-example/spec/spec_helper.cr create palindrome-example/spec/palindrome-example_spec.cr Initialized empty Git repository in /<YOUR-DIRECTORY>/.../palindrome-example/.git/ ...and cd into the directory: e.g. cd palindrome-example Then add & commit to start tracking the files with Git: $ git add -A $ git commit -am \"First Commit\" [master (root-commit) 77bad84] First Commit 10 files changed, 102 insertions(+) create mode 100644 .editorconfig create mode 100644 .gitignore create mode 100644 .travis.yml create mode 100644 LICENSE create mode 100644 README.md create mode 100644 shard.yml create mode 100644 spec/palindrome-example_spec.cr create mode 100644 spec/spec_helper.cr create mode 100644 src/palindrome-example.cr create mode 100644 src/palindrome-example/version.cr","title":"Creating the Project"},{"location":"guides/writing_shards.html#writing-the-code","text":"The code you write is up to you, but how you write it impacts whether people want to use your library and/or help you maintain it.","title":"Writing the Code"},{"location":"guides/writing_shards.html#testing-the-code","text":"Test your code. All of it. It's the only way for anyone, including you, to know if it works. Crystal has a built-in testing library . Use it!","title":"Testing the Code"},{"location":"guides/writing_shards.html#documentation","text":"Document your code with comments. All of it. Even the private methods. Crystal has a built-in documentation generator . Use it! Run crystal docs to convert your code and comments into interlinking API documentation. Open the files in the /docs/ directory with a web browser to see how your documentation is looking along the way. See below for instructions on hosting your compiler-generated docs on GitHub/GitLab Pages. Once your documentation is ready and available, you can add a documentation badge to your repository so users know that it exists. In GitLab this badge belongs to the project so we'll cover it in the GitLab instructions below, for GitHub it is common to place it below the description in your README.md like so: (Be sure to replace <LINK-TO-YOUR-DOCUMENTATION> accordingly) [![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](<LINK-TO-YOUR-DOCUMENTATION>)","title":"Documentation"},{"location":"guides/writing_shards.html#writing-a-readme","text":"A good README can make or break your project. Awesome README is a nice curation of examples and resources on the topic. Most importantly, your README should explain: What your library is What it does How to use it This explanation should include a few examples along with subheadings. Note Be sure to replace all instances of [your-github-name] in the Crystal-generated README template with your GitHub/GitLab username. If you're using GitLab, you'll also want to change all instances of github with gitlab .","title":"Writing a README"},{"location":"guides/writing_shards.html#coding-style","text":"It's fine to have your own style, but sticking to some core rubrics defined by the Crystal team can help keep your code consistent, readable and usable for other developers. Utilize Crystal's built-in code formatter to automatically format all .cr files in a directory. e.g. crystal tool format To check if your code is formatted correctly, or to check if using the formatter wouldn't produce any changes, simply add --check to the end of this command. e.g. crystal tool format --check See the Travis CI section below to implement this in your build.","title":"Coding Style"},{"location":"guides/writing_shards.html#writing-a-shardyml","text":"The spec is your rulebook. Follow it.","title":"Writing a shard.yml"},{"location":"guides/writing_shards.html#name","text":"Your shard.yml 's name property should be concise and descriptive. Search crystalshards.xyz to check if your name is already taken. e.g. name : palindrome-example","title":"Name"},{"location":"guides/writing_shards.html#description","text":"Add a description to your shard.yml . A description is a single line description used to search for and find your shard. A description should be: Informative Discoverable","title":"Description"},{"location":"guides/writing_shards.html#optimizing","text":"It's hard for anyone to use your project if they can't find it. crystalshards.xyz is currently the go-to place for Crystal libraries, so that's what we'll optimize for. There are people looking for the exact functionality of our library and the general functionality of our library. e.g. Bob needs a palindrome library, but Felipe is just looking for libraries involving text and Susan is looking for libraries involving spelling. Our name is already descriptive enough for Bob's search of \"palindrome\". We don't need to repeat the palindrome keyword. Instead, we'll catch Susan's search for \"spelling\" and Felipe's search for \"text\". description : | A textual algorithm to tell if a word is spelled the same way forwards as it is backwards.","title":"Optimizing"},{"location":"guides/writing_shards.html#hosting","text":"From here the guide differs depending on whether you are hosting your repo on GitHub or GitLab. If you're hosting somewhere else, please feel free to write up a guide and add it to this book! Hosting on GitHub Hosting on GitLab","title":"Hosting"},{"location":"guides/ci/index.html","text":"Continuous Integration \u00b6 The ability of having immediate feedback on what we are working should be one of the most important characteristics in software development. Imagine making one change to our source code and having to wait 2 weeks to see if it broke something? oh! That would be a nightmare! For this, Continuous Integration will help a team to have immediate and frequent feedback about the status of what they are building. Martin Fowler defines Continuous Integration as a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. In the next subsections, we are going to present 2 continuous integration tools: Travis CI and Circle CI and use them with a Crystal example application. These tools not only will let us build and test our code each time the source has changed but also deploy the result (if the build was successful) or use automatic builds, and maybe test against different platforms, to mention a few. The example application \u00b6 We are going to use Conway's Game of Life as the example application. More precisely, we are going to use only the first iterations in Conway's Game of Life Kata solution using TDD . Note that we won't be using TDD in the example itself, but we will mimic as if the example code is the result of the first iterations. Another important thing to mention is that we are using crystal init to create the application . And here's the implementation: # src/game_of_life.cr class Location getter x : Int32 getter y : Int32 def self . random Location . new ( Random . rand ( 10 ), Random . rand ( 10 )) end def initialize ( @x , @y ) end end class World @living_cells : Array ( Location ) def self . empty new end def initialize ( living_cells = [] of Location ) @living_cells = living_cells end def set_living_at ( a_location ) @living_cells << a_location end def is_empty? @living_cells . size == 0 end end And the specs: # spec/game_of_life_spec.cr require \"./spec_helper\" describe \"a new world\" do it \"should be empty\" do world = World . new world . is_empty? . should be_true end end describe \"an empty world\" do it \"should not be empty after adding a cell\" do world = World . empty world . set_living_at ( Location . random ) world . is_empty? . should be_false end end And this is all we need for our continuous integration examples! Let's start! Continuous Integration step by step \u00b6 Here's the list of items we want to achieve: Build and run specs using 3 different Crystal's versions: latest nightly 0.31.1 (using a Docker image) Install shards packages Install binary dependencies Use a database (for example MySQL) Cache dependencies to make the build run faster From here choose your next steps: I want to use Travis CI I want to use CircleCI","title":"Continuous Integration"},{"location":"guides/ci/index.html#continuous-integration","text":"The ability of having immediate feedback on what we are working should be one of the most important characteristics in software development. Imagine making one change to our source code and having to wait 2 weeks to see if it broke something? oh! That would be a nightmare! For this, Continuous Integration will help a team to have immediate and frequent feedback about the status of what they are building. Martin Fowler defines Continuous Integration as a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. In the next subsections, we are going to present 2 continuous integration tools: Travis CI and Circle CI and use them with a Crystal example application. These tools not only will let us build and test our code each time the source has changed but also deploy the result (if the build was successful) or use automatic builds, and maybe test against different platforms, to mention a few.","title":"Continuous Integration"},{"location":"guides/ci/index.html#the-example-application","text":"We are going to use Conway's Game of Life as the example application. More precisely, we are going to use only the first iterations in Conway's Game of Life Kata solution using TDD . Note that we won't be using TDD in the example itself, but we will mimic as if the example code is the result of the first iterations. Another important thing to mention is that we are using crystal init to create the application . And here's the implementation: # src/game_of_life.cr class Location getter x : Int32 getter y : Int32 def self . random Location . new ( Random . rand ( 10 ), Random . rand ( 10 )) end def initialize ( @x , @y ) end end class World @living_cells : Array ( Location ) def self . empty new end def initialize ( living_cells = [] of Location ) @living_cells = living_cells end def set_living_at ( a_location ) @living_cells << a_location end def is_empty? @living_cells . size == 0 end end And the specs: # spec/game_of_life_spec.cr require \"./spec_helper\" describe \"a new world\" do it \"should be empty\" do world = World . new world . is_empty? . should be_true end end describe \"an empty world\" do it \"should not be empty after adding a cell\" do world = World . empty world . set_living_at ( Location . random ) world . is_empty? . should be_false end end And this is all we need for our continuous integration examples! Let's start!","title":"The example application"},{"location":"guides/ci/index.html#continuous-integration-step-by-step","text":"Here's the list of items we want to achieve: Build and run specs using 3 different Crystal's versions: latest nightly 0.31.1 (using a Docker image) Install shards packages Install binary dependencies Use a database (for example MySQL) Cache dependencies to make the build run faster From here choose your next steps: I want to use Travis CI I want to use CircleCI","title":"Continuous Integration step by step"},{"location":"guides/ci/circleci.html","text":"CircleCI \u00b6 In this section we are going to use CircleCI as our continuous-integration service. In a few words CircleCI automates your software builds, tests, and deployments. It supports different programming languages and for our particular case, it supports the Crystal language . In this section we are going to present some configuration examples to see how CircleCI implements some continuous integration concepts . CircleCI orbs \u00b6 Before showing some examples, it\u2019s worth mentioning CircleCI orbs . As defined in the official docs: Orbs define reusable commands, executors, and jobs so that commonly used pieces of configuration can be condensed into a single line of code. In our case, we are going to use Crystal\u2019s Orb Build and run specs \u00b6 Simple example using latest \u00b6 Let\u2019s start with a simple example. We are going to run the tests using latest Crystal release: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test orbs: crystal: manastech/crystal@1.0 version: 2.1 Yeah! That was simple! With Orbs an abstraction layer is built so that the configuration file is more readable and intuitive. In case we are wondering what the job crystal/test does, we always may see the source code. Using nightly \u00b6 Using nightly Crystal release is as easy as: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: name: test-on-nightly executor: name: crystal/default tag: nightly orbs: crystal: manastech/crystal@1.0 version: 2.1 Using a specific Crystal release \u00b6 # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: name: test-on-0.30 executor: name: crystal/default tag: 0.30.0 orbs: crystal: manastech/crystal@1.0 version: 2.1 Installing shards packages \u00b6 You need not worry about it since the crystal/test job runs the crystal/shard-install orb command. Installing binary dependencies \u00b6 Our application or maybe some shards may require libraries and packages. This binary dependencies may be installed using the Apt command. Here is an example installing the libsqlite3 development package: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: pre-steps: - run: apt-get update && apt-get install -y libsqlite3-dev orbs: crystal: manastech/crystal@1.0 version: 2.1 Using services \u00b6 Now, let\u2019s run specs using an external service (for example MySQL): # .circleci/config.yml executors: crystal_mysql: docker: - image: 'crystallang/crystal:latest' environment: DATABASE_URL: 'mysql://root@localhost/db' - image: 'mysql:5.7' environment: MYSQL_DATABASE: db MYSQL_ALLOW_EMPTY_PASSWORD: 'yes' workflows: version: 2 build: jobs: - crystal/test: executor: crystal_mysql pre-steps: - run: name: Waiting for service to start (check dockerize) command: sleep 1m - checkout - run: name: Install MySQL CLI; Import dummy data command: | apt-get update && apt-get install -y mysql-client mysql -h 127.0.0.1 -u root --password=\"\" db < test-data/setup.sql orbs: crystal: manastech/crystal@1.0 version: 2.1 Note The explicit checkout in the pre-steps is to have the test-data/setup.sql file available. Caching \u00b6 Caching is enabled by default when using the job crystal/test , because internally it uses the command with-shards-cache","title":"Using CircleCI"},{"location":"guides/ci/circleci.html#circleci","text":"In this section we are going to use CircleCI as our continuous-integration service. In a few words CircleCI automates your software builds, tests, and deployments. It supports different programming languages and for our particular case, it supports the Crystal language . In this section we are going to present some configuration examples to see how CircleCI implements some continuous integration concepts .","title":"CircleCI"},{"location":"guides/ci/circleci.html#circleci-orbs","text":"Before showing some examples, it\u2019s worth mentioning CircleCI orbs . As defined in the official docs: Orbs define reusable commands, executors, and jobs so that commonly used pieces of configuration can be condensed into a single line of code. In our case, we are going to use Crystal\u2019s Orb","title":"CircleCI orbs"},{"location":"guides/ci/circleci.html#build-and-run-specs","text":"","title":"Build and run specs"},{"location":"guides/ci/circleci.html#simple-example-using-latest","text":"Let\u2019s start with a simple example. We are going to run the tests using latest Crystal release: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test orbs: crystal: manastech/crystal@1.0 version: 2.1 Yeah! That was simple! With Orbs an abstraction layer is built so that the configuration file is more readable and intuitive. In case we are wondering what the job crystal/test does, we always may see the source code.","title":"Simple example using latest"},{"location":"guides/ci/circleci.html#using-nightly","text":"Using nightly Crystal release is as easy as: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: name: test-on-nightly executor: name: crystal/default tag: nightly orbs: crystal: manastech/crystal@1.0 version: 2.1","title":"Using nightly"},{"location":"guides/ci/circleci.html#using-a-specific-crystal-release","text":"# .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: name: test-on-0.30 executor: name: crystal/default tag: 0.30.0 orbs: crystal: manastech/crystal@1.0 version: 2.1","title":"Using a specific Crystal release"},{"location":"guides/ci/circleci.html#installing-shards-packages","text":"You need not worry about it since the crystal/test job runs the crystal/shard-install orb command.","title":"Installing shards packages"},{"location":"guides/ci/circleci.html#installing-binary-dependencies","text":"Our application or maybe some shards may require libraries and packages. This binary dependencies may be installed using the Apt command. Here is an example installing the libsqlite3 development package: # .circleci/config.yml workflows: version: 2 build: jobs: - crystal/test: pre-steps: - run: apt-get update && apt-get install -y libsqlite3-dev orbs: crystal: manastech/crystal@1.0 version: 2.1","title":"Installing binary dependencies"},{"location":"guides/ci/circleci.html#using-services","text":"Now, let\u2019s run specs using an external service (for example MySQL): # .circleci/config.yml executors: crystal_mysql: docker: - image: 'crystallang/crystal:latest' environment: DATABASE_URL: 'mysql://root@localhost/db' - image: 'mysql:5.7' environment: MYSQL_DATABASE: db MYSQL_ALLOW_EMPTY_PASSWORD: 'yes' workflows: version: 2 build: jobs: - crystal/test: executor: crystal_mysql pre-steps: - run: name: Waiting for service to start (check dockerize) command: sleep 1m - checkout - run: name: Install MySQL CLI; Import dummy data command: | apt-get update && apt-get install -y mysql-client mysql -h 127.0.0.1 -u root --password=\"\" db < test-data/setup.sql orbs: crystal: manastech/crystal@1.0 version: 2.1 Note The explicit checkout in the pre-steps is to have the test-data/setup.sql file available.","title":"Using services"},{"location":"guides/ci/circleci.html#caching","text":"Caching is enabled by default when using the job crystal/test , because internally it uses the command with-shards-cache","title":"Caching"},{"location":"guides/ci/travis.html","text":"Travis CI \u00b6 In this section we are going to use Travis CI as our continuous-integration service. Travis CI is mostly used for building and running tests for projects hosted at GitHub. It supports different programming languages and for our particular case, it supports the Crystal language . Note If you are new to continuous integration (or you want to refresh the basic concepts) we may start reading the core concepts guide . Now let's see some examples! Build and run specs \u00b6 Using latest and nightly \u00b6 A first (and very basic) Travis CI config file could be: # .travis.yml language : crystal That's it! With this config file, Travis CI by default will run crystal spec . Now, we just need to go to Travis CI dashboard to add the GitHub repository . Let's see another example: # .travis.yml language : crystal crystal : - latest - nightly script : - crystal spec - crystal tool format --check With this configuration, Travis CI will run the tests using both Crystal latest and nightly releases on every push to a branch on your Github repository. Note When creating a Crystal project using crystal init , Crystal creates a .travis.yml file for us. Using a specific Crystal release \u00b6 Let's suppose we want to pin a specific Crystal release (maybe we want to make sure the shard compiles and works with that version) for example Crystal 0.31.1 . Travis CI only provides runners to latest and nightly releases directly and so, we need to install the requested Crystal release manually. For this we are going to use Docker . First we need to add Docker as a service in .travis.yml , and then we can use docker commands in our build steps, like this: # .travis.yml language: minimal services: - docker script: - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec Note We may read about different (languages)[ https://docs.travis-ci.com/user/languages/ ] supported by Travis CI, included minimal . Note A list with the different official Crystal docker images is available at DockerHub . Using latest , nightly and a specific Crystal release all together! \u00b6 Supported runners can be combined with Docker-based runners using a Build Matrix . This will allow us to run tests against latest and nightly and pinned releases. Here is the example: # .travis.yml matrix : include : - language : crystal crystal : - latest script : - crystal spec - language : crystal crystal : - nightly script : - crystal spec - language : bash services : - docker script : - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec Installing shards packages \u00b6 In native runners ( language: crystal ), Travis CI already automatically installs shards dependencies using shards install . To improve build performance we may add caching on top of that. Using Docker \u00b6 In a Docker-based runner we need to run shards install explicitly, like this: # .travis.yml language: bash services: - docker script: - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 shards install - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec Note Since the shards will be installed in ./lib/ folder, it will be preserved for the second docker run command. Installing binary dependencies \u00b6 Our application or maybe some shards may required libraries and packages. This binary dependencies may be installed using different methods. Here we are going to show an example using the Apt command (since the Docker image we are using is based on Ubuntu) Here is a first example installing the libsqlite3 development package using the APT addon : # .travis.yml language : crystal crystal : - latest before_install : - sudo apt-get -y install libsqlite3-dev addons : apt : update : true script : - crystal spec Using Docker \u00b6 We are going to build a new docker image based on crystallang/crystal , and in this new image we will be installing the binary dependencies. To accomplish this we are going to use a Dockerfile : # Dockerfile FROM crystallang/crystal:latest # install binary dependencies: RUN apt-get update && apt-get install -y libsqlite3-dev And here is the Travis CI configuration file: # .travis.yml language: bash services: - docker before_install: # build image using Dockerfile: - docker build -t testing . script: # run specs in the container - docker run -v $PWD:/src -w /src testing crystal spec Note Dockerfile arguments can be used to use the same Dockerfile for latest, nightly or a specific version. Using services \u00b6 Travis CI may start services as requested. For example, we can start a MySQL database service by adding a services: section to our .travis.yml : # .travis.yml language : crystal crystal : - latest services : - mysql script : - crystal spec Here is the new test file for testing against the database: # spec/simple_db_spec.cr require \"./spec_helper\" require \"mysql\" it \"connects to the database\" do DB . connect ENV [ \"DATABASE_URL\" ] do | cnn | cnn . query_one ( \"SELECT 'foo'\" , as : String ) . should eq \"foo\" end end When pushing this changes Travis CI will report the following error: Unknown database 'test' (Exception) , showing that we need to configure the MySQL service and also setup the database : # .travis.yml language : crystal crystal : - latest env : global : - DATABASE_NAME=test - DATABASE_URL=mysql://root@localhost/$DATABASE_NAME services : - mysql before_install : - mysql -e \"CREATE DATABASE IF NOT EXISTS $DATABASE_NAME;\" - mysql -u root --password=\"\" $DATABASE_NAME < db/schema.sql script : - crystal spec We are using a schema.sql script to create a more readable .travis.yml . The file ./db/schema.sql looks like this: -- schema.sql CREATE TABLE ... etc ... Pushing these changes will trigger Travis CI and the build should be successful! Caching \u00b6 If we read Travis CI job log, we will find that every time the job runs, Travis CI needs to fetch the libraries needed to run the application: Fetching https://github.com/crystal-lang/crystal-mysql.git Fetching https://github.com/crystal-lang/crystal-db.git This takes time and, on the other hand, these libraries might not change as often as our application, so it looks like we may cache them and save time. Travis CI uses caching to improve some parts of the building path. Here is the new configuration file with cache enabled : # .travis.yml language: crystal crystal: - latest cache: shards script: - crystal spec Let's push these changes. Travis CI will run, and it will install dependencies, but then it will cache the shards cache folder which, usually, is ~/.cache/shards . The following runs will use the cached dependencies.","title":"Using Travis CI"},{"location":"guides/ci/travis.html#travis-ci","text":"In this section we are going to use Travis CI as our continuous-integration service. Travis CI is mostly used for building and running tests for projects hosted at GitHub. It supports different programming languages and for our particular case, it supports the Crystal language . Note If you are new to continuous integration (or you want to refresh the basic concepts) we may start reading the core concepts guide . Now let's see some examples!","title":"Travis CI"},{"location":"guides/ci/travis.html#build-and-run-specs","text":"","title":"Build and run specs"},{"location":"guides/ci/travis.html#using-latest-and-nightly","text":"A first (and very basic) Travis CI config file could be: # .travis.yml language : crystal That's it! With this config file, Travis CI by default will run crystal spec . Now, we just need to go to Travis CI dashboard to add the GitHub repository . Let's see another example: # .travis.yml language : crystal crystal : - latest - nightly script : - crystal spec - crystal tool format --check With this configuration, Travis CI will run the tests using both Crystal latest and nightly releases on every push to a branch on your Github repository. Note When creating a Crystal project using crystal init , Crystal creates a .travis.yml file for us.","title":"Using latest and nightly"},{"location":"guides/ci/travis.html#using-a-specific-crystal-release","text":"Let's suppose we want to pin a specific Crystal release (maybe we want to make sure the shard compiles and works with that version) for example Crystal 0.31.1 . Travis CI only provides runners to latest and nightly releases directly and so, we need to install the requested Crystal release manually. For this we are going to use Docker . First we need to add Docker as a service in .travis.yml , and then we can use docker commands in our build steps, like this: # .travis.yml language: minimal services: - docker script: - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec Note We may read about different (languages)[ https://docs.travis-ci.com/user/languages/ ] supported by Travis CI, included minimal . Note A list with the different official Crystal docker images is available at DockerHub .","title":"Using a specific Crystal release"},{"location":"guides/ci/travis.html#using-latest-nightly-and-a-specific-crystal-release-all-together","text":"Supported runners can be combined with Docker-based runners using a Build Matrix . This will allow us to run tests against latest and nightly and pinned releases. Here is the example: # .travis.yml matrix : include : - language : crystal crystal : - latest script : - crystal spec - language : crystal crystal : - nightly script : - crystal spec - language : bash services : - docker script : - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec","title":"Using latest, nightly and a specific Crystal release all together!"},{"location":"guides/ci/travis.html#installing-shards-packages","text":"In native runners ( language: crystal ), Travis CI already automatically installs shards dependencies using shards install . To improve build performance we may add caching on top of that.","title":"Installing shards packages"},{"location":"guides/ci/travis.html#using-docker","text":"In a Docker-based runner we need to run shards install explicitly, like this: # .travis.yml language: bash services: - docker script: - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 shards install - docker run -v $PWD:/src -w /src crystallang/crystal:0.31.1 crystal spec Note Since the shards will be installed in ./lib/ folder, it will be preserved for the second docker run command.","title":"Using Docker"},{"location":"guides/ci/travis.html#installing-binary-dependencies","text":"Our application or maybe some shards may required libraries and packages. This binary dependencies may be installed using different methods. Here we are going to show an example using the Apt command (since the Docker image we are using is based on Ubuntu) Here is a first example installing the libsqlite3 development package using the APT addon : # .travis.yml language : crystal crystal : - latest before_install : - sudo apt-get -y install libsqlite3-dev addons : apt : update : true script : - crystal spec","title":"Installing binary dependencies"},{"location":"guides/ci/travis.html#using-docker_1","text":"We are going to build a new docker image based on crystallang/crystal , and in this new image we will be installing the binary dependencies. To accomplish this we are going to use a Dockerfile : # Dockerfile FROM crystallang/crystal:latest # install binary dependencies: RUN apt-get update && apt-get install -y libsqlite3-dev And here is the Travis CI configuration file: # .travis.yml language: bash services: - docker before_install: # build image using Dockerfile: - docker build -t testing . script: # run specs in the container - docker run -v $PWD:/src -w /src testing crystal spec Note Dockerfile arguments can be used to use the same Dockerfile for latest, nightly or a specific version.","title":"Using Docker"},{"location":"guides/ci/travis.html#using-services","text":"Travis CI may start services as requested. For example, we can start a MySQL database service by adding a services: section to our .travis.yml : # .travis.yml language : crystal crystal : - latest services : - mysql script : - crystal spec Here is the new test file for testing against the database: # spec/simple_db_spec.cr require \"./spec_helper\" require \"mysql\" it \"connects to the database\" do DB . connect ENV [ \"DATABASE_URL\" ] do | cnn | cnn . query_one ( \"SELECT 'foo'\" , as : String ) . should eq \"foo\" end end When pushing this changes Travis CI will report the following error: Unknown database 'test' (Exception) , showing that we need to configure the MySQL service and also setup the database : # .travis.yml language : crystal crystal : - latest env : global : - DATABASE_NAME=test - DATABASE_URL=mysql://root@localhost/$DATABASE_NAME services : - mysql before_install : - mysql -e \"CREATE DATABASE IF NOT EXISTS $DATABASE_NAME;\" - mysql -u root --password=\"\" $DATABASE_NAME < db/schema.sql script : - crystal spec We are using a schema.sql script to create a more readable .travis.yml . The file ./db/schema.sql looks like this: -- schema.sql CREATE TABLE ... etc ... Pushing these changes will trigger Travis CI and the build should be successful!","title":"Using services"},{"location":"guides/ci/travis.html#caching","text":"If we read Travis CI job log, we will find that every time the job runs, Travis CI needs to fetch the libraries needed to run the application: Fetching https://github.com/crystal-lang/crystal-mysql.git Fetching https://github.com/crystal-lang/crystal-db.git This takes time and, on the other hand, these libraries might not change as often as our application, so it looks like we may cache them and save time. Travis CI uses caching to improve some parts of the building path. Here is the new configuration file with cache enabled : # .travis.yml language: crystal crystal: - latest cache: shards script: - crystal spec Let's push these changes. Travis CI will run, and it will install dependencies, but then it will cache the shards cache folder which, usually, is ~/.cache/shards . The following runs will use the cached dependencies.","title":"Caching"},{"location":"guides/hosting/github.html","text":"Hosting on GitHub \u00b6 Create a repository with the same name and description as specified in your shard.yml . Add and commit everything: $ git add -A && git commit -am \"shard complete\" Add the remote: (Be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) Note If you like, feel free to replace public with origin , or a remote name of your choosing. $ git remote add public https://github.com/<YOUR-GITHUB-NAME>/<YOUR-REPOSITORY-NAME>.git Push it: $ git push public master GitHub Releases \u00b6 It's good practice to do GitHub Releases. Add the following markdown build badge below the description in your README to inform users what the most current release is: (Be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) [![GitHub release](https://img.shields.io/github/release/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>.svg)](https://github.com/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>/releases) Start by navigating to your repository's releases page. This can be found at https://github.com/<YOUR-GITHUB-NAME>/<YOUR-REPOSITORY-NAME>/releases Click \"Create a new release\". According to the Crystal Shards README , When libraries are installed from Git repositories, the repository is expected to have version tags following a semver-like format, prefixed with a v . Examples: v1.2.3, v2.0.0-rc1 or v2017.04.1 Accordingly, in the input that says tag version , type v0.1.0 . Make sure this matches the version in shard.yml . Title it v0.1.0 and write a short description for the release. Click \"Publish release\" and you're done! You'll now notice that the GitHub Release badge has updated in your README. Follow Semantic Versioning and create a new release every time your push new code to master . Travis CI and .travis.yml \u00b6 If you haven't already, sign up for Travis CI . Insert the following markdown build badge below the description in your README.md: (be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) [![Build Status](https://travis-ci.org/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>.svg?branch=master)](https://travis-ci.org/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>) Build badges are a simple way to tell people whether your Travis CI build passes. Add the following lines to your .travis.yml : script : - crystal spec This tells Travis CI to run your tests. Accordingly with the outcome of this command, Travis CI will return a build status of \"passed\", \"errored\", \"failed\" or \"canceled\". If you want to verify that all your code has been formatted with crystal tool format , add a script for crystal tool format --check . If the code is not formatted correctly, this will break the build just as failing tests would. e.g. script : - crystal spec - crystal tool format --check Commit and push to GitHub. Follow these guidelines to get your repo up & running on Travis CI. Once you're up and running, and the build is passing, the build badge will update in your README. Hosting your docs on GitHub-Pages \u00b6 Add the following script to your .travis.yml : - crystal docs This tells Travis CI to generate your documentation. Next, add the following lines to your .travis.yml . (Be sure to replace all instances of <YOUR-GITHUB-REPOSITORY-NAME> accordingly) deploy : provider : pages skip_cleanup : true github_token : $GITHUB_TOKEN project_name : <YOUR-GITHUB-REPOSITORY-NAME> on : branch : master local_dir : docs Set the Environment Variable , GITHUB_TOKEN , with your personal access token . If you've been following along, your .travis.yml file should look something like this: language : crystal script : - crystal spec - crystal docs deploy : provider : pages skip_cleanup : true github_token : $GITHUB_TOKEN project_name : <YOUR-GITHUB-REPOSITORY-NAME> on : branch : master local_dir : docs Click Here for the official documentation on deploying to GitHub-Pages with Travis CI.","title":"Hosting on GitHub"},{"location":"guides/hosting/github.html#hosting-on-github","text":"Create a repository with the same name and description as specified in your shard.yml . Add and commit everything: $ git add -A && git commit -am \"shard complete\" Add the remote: (Be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) Note If you like, feel free to replace public with origin , or a remote name of your choosing. $ git remote add public https://github.com/<YOUR-GITHUB-NAME>/<YOUR-REPOSITORY-NAME>.git Push it: $ git push public master","title":"Hosting on GitHub"},{"location":"guides/hosting/github.html#github-releases","text":"It's good practice to do GitHub Releases. Add the following markdown build badge below the description in your README to inform users what the most current release is: (Be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) [![GitHub release](https://img.shields.io/github/release/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>.svg)](https://github.com/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>/releases) Start by navigating to your repository's releases page. This can be found at https://github.com/<YOUR-GITHUB-NAME>/<YOUR-REPOSITORY-NAME>/releases Click \"Create a new release\". According to the Crystal Shards README , When libraries are installed from Git repositories, the repository is expected to have version tags following a semver-like format, prefixed with a v . Examples: v1.2.3, v2.0.0-rc1 or v2017.04.1 Accordingly, in the input that says tag version , type v0.1.0 . Make sure this matches the version in shard.yml . Title it v0.1.0 and write a short description for the release. Click \"Publish release\" and you're done! You'll now notice that the GitHub Release badge has updated in your README. Follow Semantic Versioning and create a new release every time your push new code to master .","title":"GitHub Releases"},{"location":"guides/hosting/github.html#travis-ci-and-travisyml","text":"If you haven't already, sign up for Travis CI . Insert the following markdown build badge below the description in your README.md: (be sure to replace <YOUR-GITHUB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) [![Build Status](https://travis-ci.org/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>.svg?branch=master)](https://travis-ci.org/<YOUR-GITHUB-USERNAME>/<YOUR-REPOSITORY-NAME>) Build badges are a simple way to tell people whether your Travis CI build passes. Add the following lines to your .travis.yml : script : - crystal spec This tells Travis CI to run your tests. Accordingly with the outcome of this command, Travis CI will return a build status of \"passed\", \"errored\", \"failed\" or \"canceled\". If you want to verify that all your code has been formatted with crystal tool format , add a script for crystal tool format --check . If the code is not formatted correctly, this will break the build just as failing tests would. e.g. script : - crystal spec - crystal tool format --check Commit and push to GitHub. Follow these guidelines to get your repo up & running on Travis CI. Once you're up and running, and the build is passing, the build badge will update in your README.","title":"Travis CI and .travis.yml"},{"location":"guides/hosting/github.html#hosting-your-docs-on-github-pages","text":"Add the following script to your .travis.yml : - crystal docs This tells Travis CI to generate your documentation. Next, add the following lines to your .travis.yml . (Be sure to replace all instances of <YOUR-GITHUB-REPOSITORY-NAME> accordingly) deploy : provider : pages skip_cleanup : true github_token : $GITHUB_TOKEN project_name : <YOUR-GITHUB-REPOSITORY-NAME> on : branch : master local_dir : docs Set the Environment Variable , GITHUB_TOKEN , with your personal access token . If you've been following along, your .travis.yml file should look something like this: language : crystal script : - crystal spec - crystal docs deploy : provider : pages skip_cleanup : true github_token : $GITHUB_TOKEN project_name : <YOUR-GITHUB-REPOSITORY-NAME> on : branch : master local_dir : docs Click Here for the official documentation on deploying to GitHub-Pages with Travis CI.","title":"Hosting your docs on GitHub-Pages"},{"location":"guides/hosting/gitlab.html","text":"Hosting on GitLab \u00b6 Go ahead and delete the default travis.yml that comes with the project. We won't be needing it. Add and commit everything: $ git add -A && git commit -am \"shard complete\" Create a GitLab project with the same name and description as specified in your shard.yml . Add the remote: (Be sure to replace <YOUR-GITLAB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) $ git remote add origin https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>.git or if you use SSH $ git remote add origin git@gitlab.com:<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>.git Push it: $ git push origin master Pipelines \u00b6 Next, let's setup a GitLab Pipeline that can run our tests and build/deploy the docs when we push code to the repo. Simply, you can just add the following file to the root of the repo and name it .gitlab-ci.yml image : \"crystallang/crystal:latest\" before_script : - shards install cache : paths : - lib/ spec & format : script : - crystal spec - crystal tool format --check pages : stage : deploy script : - crystal docs -o public src/palindrome-example.cr artifacts : paths : - public only : - master This creates two jobs. The first one is titled \"spec & format\" (you can use any name you like) and by default goes in the \"test\" stage of the pipeline. It just runs the array of commands in script on a brand new instance of the docker container specified by image . You'll probably want to lock that container to the version of crystal you're using (the one specified in your shard.yml) but for this example we'll just use the latest tag. The test stage of the pipeline will either pass (each element of the array returned a healthy exit code) or it will fail (one of the elements returned an error). If it passes, then the pipeline will move onto the second job we defined here which we must name \"pages\". This is a special job just for deploying content to your gitlab pages site! This one is executed after tests have passed because we specified that it should occur in the \"deploy\" stage. It again runs the commands in script (this time building the docs), but this time we tell it to preserve the path public (where we stashed the docs) as an artifact of the job. The result of naming this job pages and putting our docs in the public directory and specifying it as an artifact is that GitLab will deploy the site in that directory to the default URL https://<YOUR-GITLAB-USERNAME>.gitlab.io/<YOUR-REPOSITORY-NAME> . The before_script and cache keys in the file are for running the same script in every job ( shards install ) and for hanging onto the files that were created ( cache ). They're not necessary if your shard doesn't have any dependencies. If you commit the above file to your project and push, you'll trigger your first run of the new pipeline. $ git add -A && git commit -am 'Add .gitlab-ci.yml' && git push origin master Some Badges \u00b6 While that pipeline is running, let's attach some badges to the project to show off our docs and the (hopefully) successful state of our pipeline. (You might want to read the badges docs .) A badge is just a link with an image. So let's create a link to our pipeline and fetch a badge image from the Gitlab Pipeline Badges API . In the Badges section of the General settings, we'll first add a release badge. The link is: https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>/pipelines and the Badge Image URL is: https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>/badges/master/pipeline.svg . And now if the pipleline has finished we'll have docs and we can link to them with a generic badge from shields.io . Link: https://<YOUR-GITLAB-USERNAME>.gitlab.io/<YOUR-REPOSITORY-NAME> Image: https://img.shields.io/badge/docs-available-brightgreen.svg Releases \u00b6 A release is just a special commit in your history with a name (see tagging ). According to the Crystal Shards README , When libraries are installed from Git repositories, the repository is expected to have version tags following a semver-like format, prefixed with a v . Examples: v1.2.3, v2.0.0-rc1 or v2017.04.1 GitLab also has a releases feature that let's you associate files and a description with this tag. That way you can (for example) distribute binaries. As you'll see from the releases docs , you can either create an annotated tag along with release notes/files in the UI: or you can create the tag from the command line like so: $ git tag -a v0.1.0 -m \"Release v0.1.0\" push it up $ git push origin master --follow-tags and then use the UI to add/edit the release note and attach files. Best Practices Use the -a option to create an annotated tag for releases. Follow Semantic Versioning . Release Badge \u00b6 If you'd like you can also add a shields.io badge for the release. GitLab doesn't have full support for this kind of thing, and until someone adds a version badge for gitlab to shields.io, we'll have to just code in the version number in the URLs directly. Link: https://img.shields.io/badge/release-<VERSION>-brightgreen.svg Image: https://img.shields.io/badge/release-<VERSION>-brightgreen.svg where <VERSION> is the version number prefixed with a v like this: v0.1.0 . Mirror to GitHub \u00b6 At the moment, crystalshards.xyz only uses the GitHub API, so if you want your library to be indexed on that service you can set up a \"push mirror\" from GitLab to GitHub. Create a GitHub repository with the same name as your project. Follow the instructions here: https://docs.gitlab.com/ee/workflow/repository_mirroring.html#setting-up-a-push-mirror-from-gitlab-to-github-core Edit your GitHub description. The first few words of this description will show up in the search results of crystalshards.xyz but not the whole string, so for example, you could use the following Description: Words that are the same forwards and backwards. This is a mirror of: Link: https://gitlab.com/ / / This is a push mirror and that means changes will only propagate one way. So be sure to let potential collaborators know that pull requests and issues should be submitted to your GitLab project.","title":"Hosting on GitLab"},{"location":"guides/hosting/gitlab.html#hosting-on-gitlab","text":"Go ahead and delete the default travis.yml that comes with the project. We won't be needing it. Add and commit everything: $ git add -A && git commit -am \"shard complete\" Create a GitLab project with the same name and description as specified in your shard.yml . Add the remote: (Be sure to replace <YOUR-GITLAB-USERNAME> and <YOUR-REPOSITORY-NAME> accordingly) $ git remote add origin https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>.git or if you use SSH $ git remote add origin git@gitlab.com:<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>.git Push it: $ git push origin master","title":"Hosting on GitLab"},{"location":"guides/hosting/gitlab.html#pipelines","text":"Next, let's setup a GitLab Pipeline that can run our tests and build/deploy the docs when we push code to the repo. Simply, you can just add the following file to the root of the repo and name it .gitlab-ci.yml image : \"crystallang/crystal:latest\" before_script : - shards install cache : paths : - lib/ spec & format : script : - crystal spec - crystal tool format --check pages : stage : deploy script : - crystal docs -o public src/palindrome-example.cr artifacts : paths : - public only : - master This creates two jobs. The first one is titled \"spec & format\" (you can use any name you like) and by default goes in the \"test\" stage of the pipeline. It just runs the array of commands in script on a brand new instance of the docker container specified by image . You'll probably want to lock that container to the version of crystal you're using (the one specified in your shard.yml) but for this example we'll just use the latest tag. The test stage of the pipeline will either pass (each element of the array returned a healthy exit code) or it will fail (one of the elements returned an error). If it passes, then the pipeline will move onto the second job we defined here which we must name \"pages\". This is a special job just for deploying content to your gitlab pages site! This one is executed after tests have passed because we specified that it should occur in the \"deploy\" stage. It again runs the commands in script (this time building the docs), but this time we tell it to preserve the path public (where we stashed the docs) as an artifact of the job. The result of naming this job pages and putting our docs in the public directory and specifying it as an artifact is that GitLab will deploy the site in that directory to the default URL https://<YOUR-GITLAB-USERNAME>.gitlab.io/<YOUR-REPOSITORY-NAME> . The before_script and cache keys in the file are for running the same script in every job ( shards install ) and for hanging onto the files that were created ( cache ). They're not necessary if your shard doesn't have any dependencies. If you commit the above file to your project and push, you'll trigger your first run of the new pipeline. $ git add -A && git commit -am 'Add .gitlab-ci.yml' && git push origin master","title":"Pipelines"},{"location":"guides/hosting/gitlab.html#some-badges","text":"While that pipeline is running, let's attach some badges to the project to show off our docs and the (hopefully) successful state of our pipeline. (You might want to read the badges docs .) A badge is just a link with an image. So let's create a link to our pipeline and fetch a badge image from the Gitlab Pipeline Badges API . In the Badges section of the General settings, we'll first add a release badge. The link is: https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>/pipelines and the Badge Image URL is: https://gitlab.com/<YOUR-GITLAB-USERNAME>/<YOUR-REPOSITORY-NAME>/badges/master/pipeline.svg . And now if the pipleline has finished we'll have docs and we can link to them with a generic badge from shields.io . Link: https://<YOUR-GITLAB-USERNAME>.gitlab.io/<YOUR-REPOSITORY-NAME> Image: https://img.shields.io/badge/docs-available-brightgreen.svg","title":"Some Badges"},{"location":"guides/hosting/gitlab.html#releases","text":"A release is just a special commit in your history with a name (see tagging ). According to the Crystal Shards README , When libraries are installed from Git repositories, the repository is expected to have version tags following a semver-like format, prefixed with a v . Examples: v1.2.3, v2.0.0-rc1 or v2017.04.1 GitLab also has a releases feature that let's you associate files and a description with this tag. That way you can (for example) distribute binaries. As you'll see from the releases docs , you can either create an annotated tag along with release notes/files in the UI: or you can create the tag from the command line like so: $ git tag -a v0.1.0 -m \"Release v0.1.0\" push it up $ git push origin master --follow-tags and then use the UI to add/edit the release note and attach files. Best Practices Use the -a option to create an annotated tag for releases. Follow Semantic Versioning .","title":"Releases"},{"location":"guides/hosting/gitlab.html#release-badge","text":"If you'd like you can also add a shields.io badge for the release. GitLab doesn't have full support for this kind of thing, and until someone adds a version badge for gitlab to shields.io, we'll have to just code in the version number in the URLs directly. Link: https://img.shields.io/badge/release-<VERSION>-brightgreen.svg Image: https://img.shields.io/badge/release-<VERSION>-brightgreen.svg where <VERSION> is the version number prefixed with a v like this: v0.1.0 .","title":"Release Badge"},{"location":"guides/hosting/gitlab.html#mirror-to-github","text":"At the moment, crystalshards.xyz only uses the GitHub API, so if you want your library to be indexed on that service you can set up a \"push mirror\" from GitLab to GitHub. Create a GitHub repository with the same name as your project. Follow the instructions here: https://docs.gitlab.com/ee/workflow/repository_mirroring.html#setting-up-a-push-mirror-from-gitlab-to-github-core Edit your GitHub description. The first few words of this description will show up in the search results of crystalshards.xyz but not the whole string, so for example, you could use the following Description: Words that are the same forwards and backwards. This is a mirror of: Link: https://gitlab.com/ / / This is a push mirror and that means changes will only propagate one way. So be sure to let potential collaborators know that pull requests and issues should be submitted to your GitLab project.","title":"Mirror to GitHub"},{"location":"overview/index.html","text":"Overview \u00b6 You can read this document from top to bottom, but it\u2019s advisable to jump through sections because some concepts are interrelated and can\u2019t be explained in isolation. In code examples, the comment #=> is used to show the value of an expression. For example: a = 1 + 2 a #=> 3 A comment using : is used for showing the type of a variable. s = \"hello\" # s : String Let's start with two examples to familiarize ourselves with the language.","title":"About this guide"},{"location":"overview/index.html#overview","text":"You can read this document from top to bottom, but it\u2019s advisable to jump through sections because some concepts are interrelated and can\u2019t be explained in isolation. In code examples, the comment #=> is used to show the value of an expression. For example: a = 1 + 2 a #=> 3 A comment using : is used for showing the type of a variable. s = \"hello\" # s : String Let's start with two examples to familiarize ourselves with the language.","title":"Overview"},{"location":"syntax_and_semantics/index.html","text":"Syntax and Semantics \u00b6 The program\u2019s source code must be encoded in UTF-8.","title":"Language Specification"},{"location":"syntax_and_semantics/index.html#syntax-and-semantics","text":"The program\u2019s source code must be encoded in UTF-8.","title":"Syntax and Semantics"},{"location":"syntax_and_semantics/alias.html","text":"alias \u00b6 With alias you can give a type a different name: alias PInt32 = Pointer ( Int32 ) ptr = PInt32 . malloc ( 1 ) # : Pointer(Int32) Every time you use an alias the compiler replaces it with the type it refers to. Aliases are useful to avoid writing long type names, but also to be able to talk about recursive types: alias RecArray = Array ( Int32 ) | Array ( RecArray ) ary = [] of RecArray ary . push [ 1 , 2 , 3 ] ary . push ary ary # => [[1, 2, 3], [...]] A real-world example of a recursive type is json: module Json alias Type = Nil | Bool | Int64 | Float64 | String | Array ( Type ) | Hash ( String , Type ) end","title":"alias"},{"location":"syntax_and_semantics/alias.html#alias","text":"With alias you can give a type a different name: alias PInt32 = Pointer ( Int32 ) ptr = PInt32 . malloc ( 1 ) # : Pointer(Int32) Every time you use an alias the compiler replaces it with the type it refers to. Aliases are useful to avoid writing long type names, but also to be able to talk about recursive types: alias RecArray = Array ( Int32 ) | Array ( RecArray ) ary = [] of RecArray ary . push [ 1 , 2 , 3 ] ary . push ary ary # => [[1, 2, 3], [...]] A real-world example of a recursive type is json: module Json alias Type = Nil | Bool | Int64 | Float64 | String | Array ( Type ) | Hash ( String , Type ) end","title":"alias"},{"location":"syntax_and_semantics/and.html","text":"&& - Logical AND Operator \u00b6 An && (and) evaluates its left hand side. If it's truthy , it evaluates its right hand side and has that value. Otherwise it has the value of the left hand side. Its type is the union of the types of both sides. You can think an && as syntax sugar of an if : some_exp1 && some_exp2 # The above is the same as: tmp = some_exp1 if tmp some_exp2 else tmp end","title":"&&"},{"location":"syntax_and_semantics/and.html#-logical-and-operator","text":"An && (and) evaluates its left hand side. If it's truthy , it evaluates its right hand side and has that value. Otherwise it has the value of the left hand side. Its type is the union of the types of both sides. You can think an && as syntax sugar of an if : some_exp1 && some_exp2 # The above is the same as: tmp = some_exp1 if tmp some_exp2 else tmp end","title":"&amp;&amp; - Logical AND Operator"},{"location":"syntax_and_semantics/as.html","text":"as \u00b6 The as pseudo-method restricts the types of an expression. For example: if some_condition a = 1 else a = \"hello\" end # a : Int32 | String In the above code, a is a union of Int32 | String . If for some reason we are sure a is an Int32 after the if , we can force the compiler to treat it like one: a_as_int = a .as ( Int32 ) a_as_int . abs # works, compiler knows that a_as_int is Int32 The as pseudo-method performs a runtime check: if a wasn't an Int32 , an exception is raised. The argument to the expression is a type . If it is impossible for a type to be restricted by another type, a compile-time error is issued: 1 .as ( String ) # Compile-time error Note You can't use as to convert a type to an unrelated type: as is not like a cast in other languages. Methods on integers, floats and chars are provided for these conversions. Alternatively, use pointer casts as explained below. Converting between pointer types \u00b6 The as pseudo-method also allows to cast between pointer types: ptr = Pointer ( Int32 ) . malloc ( 1 ) ptr .as ( Int8 * ) # :: Pointer(Int8) In this case, no runtime checks are done: pointers are unsafe and this type of casting is usually only needed in C bindings and low-level code. Converting between pointer types and other types \u00b6 Conversion between pointer types and Reference types is also possible: array = [ 1 , 2 , 3 ] # object_id returns the address of an object in memory, # so we create a pointer with that address ptr = Pointer ( Void ) . new ( array . object_id ) # Now we cast that pointer to the same type, and # we should get the same value array2 = ptr .as ( Array ( Int32 )) array2 . same? ( array ) # => true No runtime checks are performed in these cases because, again, pointers are involved. The need for this cast is even more rare than the previous one, but allows to implement some core types (like String) in Crystal itself, and it also allows passing a Reference type to C functions by casting it to a void pointer. Usage for casting to a bigger type \u00b6 The as pseudo-method can be used to cast an expression to a \"bigger\" type. For example: a = 1 b = a .as ( Int32 | Float64 ) b # :: Int32 | Float64 The above might not seem to be useful, but it is when, for example, mapping an array of elements: ary = [ 1 , 2 , 3 ] # We want to create an array 1, 2, 3 of Int32 | Float64 ary2 = ary . map { | x | x .as ( Int32 | Float64 ) } ary2 # :: Array(Int32 | Float64) ary2 << 1.5 # OK The Array#map method uses the block's type as the generic type for the Array. Without the as pseudo-method, the inferred type would have been Int32 and we wouldn't have been able to add a Float64 into it. Usage for when the compiler can't infer the type of a block \u00b6 Sometimes the compiler can't infer the type of a block. This can happen in recursive calls that depend on each other. In those cases you can use as to let it know the type: some_call { | v | v . method .as ( ExpectedType ) }","title":"as"},{"location":"syntax_and_semantics/as.html#as","text":"The as pseudo-method restricts the types of an expression. For example: if some_condition a = 1 else a = \"hello\" end # a : Int32 | String In the above code, a is a union of Int32 | String . If for some reason we are sure a is an Int32 after the if , we can force the compiler to treat it like one: a_as_int = a .as ( Int32 ) a_as_int . abs # works, compiler knows that a_as_int is Int32 The as pseudo-method performs a runtime check: if a wasn't an Int32 , an exception is raised. The argument to the expression is a type . If it is impossible for a type to be restricted by another type, a compile-time error is issued: 1 .as ( String ) # Compile-time error Note You can't use as to convert a type to an unrelated type: as is not like a cast in other languages. Methods on integers, floats and chars are provided for these conversions. Alternatively, use pointer casts as explained below.","title":"as"},{"location":"syntax_and_semantics/as.html#converting-between-pointer-types","text":"The as pseudo-method also allows to cast between pointer types: ptr = Pointer ( Int32 ) . malloc ( 1 ) ptr .as ( Int8 * ) # :: Pointer(Int8) In this case, no runtime checks are done: pointers are unsafe and this type of casting is usually only needed in C bindings and low-level code.","title":"Converting between pointer types"},{"location":"syntax_and_semantics/as.html#converting-between-pointer-types-and-other-types","text":"Conversion between pointer types and Reference types is also possible: array = [ 1 , 2 , 3 ] # object_id returns the address of an object in memory, # so we create a pointer with that address ptr = Pointer ( Void ) . new ( array . object_id ) # Now we cast that pointer to the same type, and # we should get the same value array2 = ptr .as ( Array ( Int32 )) array2 . same? ( array ) # => true No runtime checks are performed in these cases because, again, pointers are involved. The need for this cast is even more rare than the previous one, but allows to implement some core types (like String) in Crystal itself, and it also allows passing a Reference type to C functions by casting it to a void pointer.","title":"Converting between pointer types and other types"},{"location":"syntax_and_semantics/as.html#usage-for-casting-to-a-bigger-type","text":"The as pseudo-method can be used to cast an expression to a \"bigger\" type. For example: a = 1 b = a .as ( Int32 | Float64 ) b # :: Int32 | Float64 The above might not seem to be useful, but it is when, for example, mapping an array of elements: ary = [ 1 , 2 , 3 ] # We want to create an array 1, 2, 3 of Int32 | Float64 ary2 = ary . map { | x | x .as ( Int32 | Float64 ) } ary2 # :: Array(Int32 | Float64) ary2 << 1.5 # OK The Array#map method uses the block's type as the generic type for the Array. Without the as pseudo-method, the inferred type would have been Int32 and we wouldn't have been able to add a Float64 into it.","title":"Usage for casting to a bigger type"},{"location":"syntax_and_semantics/as.html#usage-for-when-the-compiler-cant-infer-the-type-of-a-block","text":"Sometimes the compiler can't infer the type of a block. This can happen in recursive calls that depend on each other. In those cases you can use as to let it know the type: some_call { | v | v . method .as ( ExpectedType ) }","title":"Usage for when the compiler can't infer the type of a block"},{"location":"syntax_and_semantics/as_a_suffix.html","text":"As a suffix \u00b6 An if can be written as an expression\u2019s suffix: a = 2 if some_condition # The above is the same as: if some_condition a = 2 end This sometimes leads to code that is more natural to read.","title":"As a suffix"},{"location":"syntax_and_semantics/as_a_suffix.html#as-a-suffix","text":"An if can be written as an expression\u2019s suffix: a = 2 if some_condition # The above is the same as: if some_condition a = 2 end This sometimes leads to code that is more natural to read.","title":"As a suffix"},{"location":"syntax_and_semantics/as_an_expression.html","text":"As an expression \u00b6 The value of an if is the value of the last expression found in each of its branches: a = if 2 > 1 3 else 4 end a # => 3 If an if branch is empty, or it\u2019s missing, it\u2019s considered as if it had nil in it: if 1 > 2 3 end # The above is the same as: if 1 > 2 3 else nil end # Another example: if 1 > 2 else 3 end # The above is the same as: if 1 > 2 nil else 3 end","title":"As an expression"},{"location":"syntax_and_semantics/as_an_expression.html#as-an-expression","text":"The value of an if is the value of the last expression found in each of its branches: a = if 2 > 1 3 else 4 end a # => 3 If an if branch is empty, or it\u2019s missing, it\u2019s considered as if it had nil in it: if 1 > 2 3 end # The above is the same as: if 1 > 2 3 else nil end # Another example: if 1 > 2 else 3 end # The above is the same as: if 1 > 2 nil else 3 end","title":"As an expression"},{"location":"syntax_and_semantics/as_question.html","text":"as? \u00b6 The as? pseudo-method is similar to as , except that it returns nil instead of raising an exception when the type doesn't match. It also can't be used to cast between pointer types and other types. Example: value = rand < 0.5 ? - 3 : nil result = value .as? ( Int32 ) || 10 value .as? ( Int32 ) . try &. abs","title":"as?"},{"location":"syntax_and_semantics/as_question.html#as","text":"The as? pseudo-method is similar to as , except that it returns nil instead of raising an exception when the type doesn't match. It also can't be used to cast between pointer types and other types. Example: value = rand < 0.5 ? - 3 : nil result = value .as? ( Int32 ) || 10 value .as? ( Int32 ) . try &. abs","title":"as?"},{"location":"syntax_and_semantics/assignment.html","text":"Assignment \u00b6 Assignment is done using the equals sign ( = ). # Assigns to a local variable local = 1 # Assigns to an instance variable @instance = 2 # Assigns to a class variable @@class = 3 Each of the above kinds of variables will be explained later on. Some syntax sugar that contains the = character is available: local += 1 # same as: local = local + 1 # The above is valid with these operators: # +, -, *, /, %, |, &, ^, **, <<, >> local ||= 1 # same as: local || (local = 1) local &&= 1 # same as: local && (local = 1) A method invocation that ends with = has syntax sugar: # A setter person . name = ( \"John\" ) # The above can be written as: person . name = \"John\" # An indexed assignment objects . []= ( 2 , 3 ) # The above can be written as: objects [ 2 ] = 3 # Not assignment-related, but also syntax sugar: objects . [] ( 2 , 3 ) # The above can be written as: objects [ 2 , 3 ] The = operator syntax sugar is also available to setters and indexers. Note that || and && use the []? method to check for key presence. person . age += 1 # same as: person.age = person.age + 1 person . name ||= \"John\" # same as: person.name || (person.name = \"John\") person . name &&= \"John\" # same as: person.name && (person.name = \"John\") objects [ 1 ] += 2 # same as: objects[1] = objects[1] + 2 objects [ 1 ] ||= 2 # same as: objects[1]? || (objects[1] = 2) objects [ 1 ] &&= 2 # same as: objects[1]? && (objects[1] = 2) Chained assignment \u00b6 You can assign the same value to multiple variables using chained assignment: a = b = c = 123 # Now a, b and c have the same value: a # => 123 b # => 123 c # => 123 The chained assignment is not only available to local variables but also to instance variables , class variables and setter methods (methods that end with = ). Multiple assignment \u00b6 You can declare/assign multiple variables at the same time by separating expressions with a comma ( , ): name , age = \"Crystal\" , 1 # The above is the same as this: temp1 = \"Crystal\" temp2 = 1 name = temp1 age = temp2 Note that because expressions are assigned to temporary variables it is possible to exchange variables\u2019 contents in a single line: a = 1 b = 2 a , b = b , a a # => 2 b # => 1 If the right-hand side contains just one expression, the type is indexed for each variable on the left-hand side like so: name , age , source = \"Crystal, 123, GitHub\" . split ( \", \" ) # The above is the same as this: temp = \"Crystal, 123, GitHub\" . split ( \", \" ) name = temp [ 0 ] age = temp [ 1 ] source = temp [ 2 ] Multiple assignment is also available to methods that end with = : person . name , person . age = \"John\" , 32 # Same as: temp1 = \"John\" temp2 = 32 person . name = temp1 person . age = temp2 And it is also available to index assignments ( []= ): objects [ 1 ] , objects [ 2 ] = 3 , 4 # Same as: temp1 = 3 temp2 = 4 objects [ 1 ] = temp1 objects [ 2 ] = temp2","title":"Assignment"},{"location":"syntax_and_semantics/assignment.html#assignment","text":"Assignment is done using the equals sign ( = ). # Assigns to a local variable local = 1 # Assigns to an instance variable @instance = 2 # Assigns to a class variable @@class = 3 Each of the above kinds of variables will be explained later on. Some syntax sugar that contains the = character is available: local += 1 # same as: local = local + 1 # The above is valid with these operators: # +, -, *, /, %, |, &, ^, **, <<, >> local ||= 1 # same as: local || (local = 1) local &&= 1 # same as: local && (local = 1) A method invocation that ends with = has syntax sugar: # A setter person . name = ( \"John\" ) # The above can be written as: person . name = \"John\" # An indexed assignment objects . []= ( 2 , 3 ) # The above can be written as: objects [ 2 ] = 3 # Not assignment-related, but also syntax sugar: objects . [] ( 2 , 3 ) # The above can be written as: objects [ 2 , 3 ] The = operator syntax sugar is also available to setters and indexers. Note that || and && use the []? method to check for key presence. person . age += 1 # same as: person.age = person.age + 1 person . name ||= \"John\" # same as: person.name || (person.name = \"John\") person . name &&= \"John\" # same as: person.name && (person.name = \"John\") objects [ 1 ] += 2 # same as: objects[1] = objects[1] + 2 objects [ 1 ] ||= 2 # same as: objects[1]? || (objects[1] = 2) objects [ 1 ] &&= 2 # same as: objects[1]? && (objects[1] = 2)","title":"Assignment"},{"location":"syntax_and_semantics/assignment.html#chained-assignment","text":"You can assign the same value to multiple variables using chained assignment: a = b = c = 123 # Now a, b and c have the same value: a # => 123 b # => 123 c # => 123 The chained assignment is not only available to local variables but also to instance variables , class variables and setter methods (methods that end with = ).","title":"Chained assignment"},{"location":"syntax_and_semantics/assignment.html#multiple-assignment","text":"You can declare/assign multiple variables at the same time by separating expressions with a comma ( , ): name , age = \"Crystal\" , 1 # The above is the same as this: temp1 = \"Crystal\" temp2 = 1 name = temp1 age = temp2 Note that because expressions are assigned to temporary variables it is possible to exchange variables\u2019 contents in a single line: a = 1 b = 2 a , b = b , a a # => 2 b # => 1 If the right-hand side contains just one expression, the type is indexed for each variable on the left-hand side like so: name , age , source = \"Crystal, 123, GitHub\" . split ( \", \" ) # The above is the same as this: temp = \"Crystal, 123, GitHub\" . split ( \", \" ) name = temp [ 0 ] age = temp [ 1 ] source = temp [ 2 ] Multiple assignment is also available to methods that end with = : person . name , person . age = \"John\" , 32 # Same as: temp1 = \"John\" temp2 = 32 person . name = temp1 person . age = temp2 And it is also available to index assignments ( []= ): objects [ 1 ] , objects [ 2 ] = 3 , 4 # Same as: temp1 = 3 temp2 = 4 objects [ 1 ] = temp1 objects [ 2 ] = temp2","title":"Multiple assignment"},{"location":"syntax_and_semantics/block_forwarding.html","text":"Block forwarding \u00b6 To forward captured blocks, you use a block argument, prefixing an expression with & : def capture ( & block ) block end def invoke ( & block ) block . call end proc = capture { puts \"Hello\" } invoke ( & proc ) # prints \"Hello\" In the above example, invoke receives a block. We can't pass proc directly to it because invoke doesn't receive regular arguments, just a block argument. We use & to specify that we really want to pass proc as the block argument. Otherwise: invoke ( proc ) # Error: wrong number of arguments for 'invoke' (1 for 0) You can actually pass a proc to a method that yields: def capture ( & block ) block end def twice yield yield end proc = capture { puts \"Hello\" } twice & proc The above is simply rewritten to: proc = capture { puts \"Hello\" } twice do proc . call end Or, combining the & and -> syntaxes: twice &-> { puts \"Hello\" } Or: def say_hello puts \"Hello\" end twice &-> say_hello Forwarding non-captured blocks \u00b6 To forward non-captured blocks, you must use yield : def foo yield 1 end def wrap_foo puts \"Before foo\" foo do | x | yield x end puts \"After foo\" end wrap_foo do | i | puts i end # Output: # Before foo # 1 # After foo You can also use the &block syntax to forward blocks, but then you have to at least specify the input types, and the generated code will involve closures and will be slower: def foo yield 1 end def wrap_foo ( & block : Int32 -> _ ) puts \"Before foo\" foo ( & block ) puts \"After foo\" end wrap_foo do | i | puts i end # Output: # Before foo # 1 # After foo Try to avoid forwarding blocks like this if doing yield is enough. There's also the issue that break and next are not allowed inside captured blocks, so the following won't work when using &block forwarding: foo_forward do | i | break # error end In short, avoid &block forwarding when yield is involved.","title":"Block forwarding"},{"location":"syntax_and_semantics/block_forwarding.html#block-forwarding","text":"To forward captured blocks, you use a block argument, prefixing an expression with & : def capture ( & block ) block end def invoke ( & block ) block . call end proc = capture { puts \"Hello\" } invoke ( & proc ) # prints \"Hello\" In the above example, invoke receives a block. We can't pass proc directly to it because invoke doesn't receive regular arguments, just a block argument. We use & to specify that we really want to pass proc as the block argument. Otherwise: invoke ( proc ) # Error: wrong number of arguments for 'invoke' (1 for 0) You can actually pass a proc to a method that yields: def capture ( & block ) block end def twice yield yield end proc = capture { puts \"Hello\" } twice & proc The above is simply rewritten to: proc = capture { puts \"Hello\" } twice do proc . call end Or, combining the & and -> syntaxes: twice &-> { puts \"Hello\" } Or: def say_hello puts \"Hello\" end twice &-> say_hello","title":"Block forwarding"},{"location":"syntax_and_semantics/block_forwarding.html#forwarding-non-captured-blocks","text":"To forward non-captured blocks, you must use yield : def foo yield 1 end def wrap_foo puts \"Before foo\" foo do | x | yield x end puts \"After foo\" end wrap_foo do | i | puts i end # Output: # Before foo # 1 # After foo You can also use the &block syntax to forward blocks, but then you have to at least specify the input types, and the generated code will involve closures and will be slower: def foo yield 1 end def wrap_foo ( & block : Int32 -> _ ) puts \"Before foo\" foo ( & block ) puts \"After foo\" end wrap_foo do | i | puts i end # Output: # Before foo # 1 # After foo Try to avoid forwarding blocks like this if doing yield is enough. There's also the issue that break and next are not allowed inside captured blocks, so the following won't work when using &block forwarding: foo_forward do | i | break # error end In short, avoid &block forwarding when yield is involved.","title":"Forwarding non-captured blocks"},{"location":"syntax_and_semantics/blocks_and_procs.html","text":"Blocks and Procs \u00b6 Methods can accept a block of code that is executed with the yield keyword. For example: def twice yield yield end twice do puts \"Hello!\" end The above program prints \"Hello!\" twice, once for each yield . To define a method that receives a block, simply use yield inside it and the compiler will know. You can make this more evident by declaring a dummy block parameter, indicated as a last parameter prefixed with ampersand ( & ): def twice ( & block ) yield yield end To invoke a method and pass a block, you use do ... end or { ... } . All of these are equivalent: twice () do puts \"Hello!\" end twice do puts \"Hello!\" end twice { puts \"Hello!\" } The difference between using do ... end and { ... } is that do ... end binds to the left-most call, while { ... } binds to the right-most call: foo bar do something end # The above is the same as foo ( bar ) do something end foo bar { something } # The above is the same as foo ( bar { something }) The reason for this is to allow creating Domain Specific Languages (DSLs) using do ... end to have them be read as plain English: open file \"foo.cr\" do something end # Same as: open ( file ( \"foo.cr\" )) do end You wouldn't want the above to be: open ( file ( \"foo.cr\" ) do end ) Overloads \u00b6 Two methods, one that yields and another that doesn't, are considered different overloads, as explained in the overloading section. Yield arguments \u00b6 The yield expression is similar to a call and can receive arguments. For example: def twice yield 1 yield 2 end twice do | i | puts \"Got #{ i } \" end The above prints \"Got 1\" and \"Got 2\". A curly braces notation is also available: twice { | i | puts \"Got #{ i } \" } You can yield many values: def many yield 1 , 2 , 3 end many do | x , y , z | puts x + y + z end # Output: 6 A block can specify fewer parameters than the arguments yielded: def many yield 1 , 2 , 3 end many do | x , y | puts x + y end # Output: 3 It's an error specifying more block parameters than the arguments yielded: def twice yield yield end twice do | i | # Error: too many block parameters end Each block parameter has the type of every yield expression in that position. For example: def some yield 1 , 'a' yield true , \"hello\" yield 2 , nil end some do | first , second | # first is Int32 | Bool # second is Char | String | Nil end Short one-parameter syntax \u00b6 If a block has a single parameter and invokes a method on it, the block can be replaced with the short syntax argument. This: method do | param | param . some_method end and method { | param | param . some_method } can both be written as: method &. some_method Or like: method ( &. some_method ) In either case, &.some_method is an argument passed to method . This argument is syntactically equivalent to the block variants. It is only syntactic sugar and does not have any performance penalty. If the method has other required arguments, the short syntax argument should also be supplied in the method's argument list. [ \"a\" , \"b\" ]. join ( \",\" , &. upcase ) Is equivalent to: [ \"a\" , \"b\" ]. join ( \",\" ) { | s | s . upcase } Arguments can be used with the short syntax argument as well: [ \"i\" , \"o\" ]. join ( \",\" , &. upcase ( Unicode :: CaseOptions :: Turkic )) Operators can be invoked too: method &. + ( 2 ) method ( &. [index ] ) yield value \u00b6 The yield expression itself has a value: the last expression of the block. For example: def twice v1 = yield 1 puts v1 v2 = yield 2 puts v2 end twice do | i | i + 1 end The above prints \"2\" and \"3\". A yield expression's value is mostly useful for transforming and filtering values. The best examples of this are Enumerable#map and Enumerable#select : ary = [ 1 , 2 , 3 ] ary . map { | x | x + 1 } # => [2, 3, 4] ary . select { | x | x % 2 == 1 } # => [1, 3] A dummy transformation method: def transform ( value ) yield value end transform ( 1 ) { | x | x + 1 } # => 2 The result of the last expression is 2 because the last expression of the transform method is yield , whose value is the last expression of the block. Type restrictions \u00b6 The type of the block in a method that uses yield can be restricted using the &block syntax. For example: def transform_int ( start : Int32 , & block : Int32 -> Int32 ) result = yield start result * 2 end transform_int ( 3 ) { | x | x + 2 } # => 10 transform_int ( 3 ) { | x | \"foo\" } # Error: expected block to return Int32, not String break \u00b6 A break expression inside a block exits early from the method: def thrice puts \"Before 1\" yield 1 puts \"Before 2\" yield 2 puts \"Before 3\" yield 3 puts \"After 3\" end thrice do | i | if i == 2 break end end The above prints \"Before 1\" and \"Before 2\". The thrice method didn't execute the puts \"Before 3\" expression because of the break . break can also accept arguments: these become the method's return value. For example: def twice yield 1 yield 2 end twice { | i | i + 1 } # => 3 twice { | i | break \"hello\" } # => \"hello\" The first call's value is 3 because the last expression of the twice method is yield , which gets the value of the block. The second call's value is \"hello\" because a break was performed. If there are conditional breaks, the call's return value type will be a union of the type of the block's value and the type of the many break s: value = twice do | i | if i == 1 break \"hello\" end i + 1 end value # :: Int32 | String If a break receives many arguments, they are automatically transformed to a Tuple : values = twice { break 1 , 2 } values # => {1, 2} If a break receives no arguments, it's the same as receiving a single nil argument: value = twice { break } value # => nil next \u00b6 The next expression inside a block exits early from the block (not the method). For example: def twice yield 1 yield 2 end twice do | i | if i == 1 puts \"Skipping 1\" next end puts \"Got #{ i } \" end # Output: # Skipping 1 # Got 2 The next expression accepts arguments, and these give the value of the yield expression that invoked the block: def twice v1 = yield 1 puts v1 v2 = yield 2 puts v2 end twice do | i | if i == 1 next 10 end i + 1 end # Output # 10 # 3 If a next receives many arguments, they are automatically transformed to a Tuple . If it receives no arguments it's the same as receiving a single nil argument. with ... yield \u00b6 A yield expression can be modified, using the with keyword, to specify an object to use as the default receiver of method calls within the block: class Foo def one 1 end def yield_with_self with self yield end def yield_normally yield end end def one \"one\" end Foo . new . yield_with_self { one } # => 1 Foo . new . yield_normally { one } # => \"one\" Unpacking block parameters \u00b6 A block parameter can specify sub-parameters enclosed in parentheses: array = [ { 1 , \"one\" }, { 2 , \"two\" } ] array . each do | ( number , word ) | puts \" #{ number } : #{ word } \" end The above is simply syntax sugar of this: array = [ { 1 , \"one\" }, { 2 , \"two\" } ] array . each do | arg | number = arg [ 0 ] word = arg [ 1 ] puts \" #{ number } : #{ word } \" end That means that any type that responds to [] with integers can be unpacked in a block parameter. For Tuple parameters you can take advantage of auto-splatting and do not need parentheses: array = [ { 1 , \"one\" , true }, { 2 , \"two\" , false } ] array . each do | number , word , bool | puts \" #{ number } : #{ word } #{ bool } \" end Hash(K, V)#each passes Tuple(K, V) to the block so iterating key-value pairs works with auto-splatting: h = { \"foo\" => \"bar\" } h . each do | key , value | key # => \"foo\" value # => \"bar\" end Performance \u00b6 When using blocks with yield , the blocks are always inlined: no closures, calls or function pointers are involved. This means that this: def twice yield 1 yield 2 end twice do | i | puts \"Got: #{ i } \" end is exactly the same as writing this: i = 1 puts \"Got: #{ i } \" i = 2 puts \"Got: #{ i } \" For example, the standard library includes a times method on integers, allowing you to write: 3 . times do | i | puts i end This looks very fancy, but is it as fast as a C for loop? The answer is: yes! This is Int#times definition: struct Int def times i = 0 while i < self yield i i += 1 end end end Because a non-captured block is always inlined, the above method invocation is exactly the same as writing this: i = 0 while i < 3 puts i i += 1 end Have no fear using blocks for readability or code reuse, it won't affect the resulting executable performance.","title":"Blocks and Procs"},{"location":"syntax_and_semantics/blocks_and_procs.html#blocks-and-procs","text":"Methods can accept a block of code that is executed with the yield keyword. For example: def twice yield yield end twice do puts \"Hello!\" end The above program prints \"Hello!\" twice, once for each yield . To define a method that receives a block, simply use yield inside it and the compiler will know. You can make this more evident by declaring a dummy block parameter, indicated as a last parameter prefixed with ampersand ( & ): def twice ( & block ) yield yield end To invoke a method and pass a block, you use do ... end or { ... } . All of these are equivalent: twice () do puts \"Hello!\" end twice do puts \"Hello!\" end twice { puts \"Hello!\" } The difference between using do ... end and { ... } is that do ... end binds to the left-most call, while { ... } binds to the right-most call: foo bar do something end # The above is the same as foo ( bar ) do something end foo bar { something } # The above is the same as foo ( bar { something }) The reason for this is to allow creating Domain Specific Languages (DSLs) using do ... end to have them be read as plain English: open file \"foo.cr\" do something end # Same as: open ( file ( \"foo.cr\" )) do end You wouldn't want the above to be: open ( file ( \"foo.cr\" ) do end )","title":"Blocks and Procs"},{"location":"syntax_and_semantics/blocks_and_procs.html#overloads","text":"Two methods, one that yields and another that doesn't, are considered different overloads, as explained in the overloading section.","title":"Overloads"},{"location":"syntax_and_semantics/blocks_and_procs.html#yield-arguments","text":"The yield expression is similar to a call and can receive arguments. For example: def twice yield 1 yield 2 end twice do | i | puts \"Got #{ i } \" end The above prints \"Got 1\" and \"Got 2\". A curly braces notation is also available: twice { | i | puts \"Got #{ i } \" } You can yield many values: def many yield 1 , 2 , 3 end many do | x , y , z | puts x + y + z end # Output: 6 A block can specify fewer parameters than the arguments yielded: def many yield 1 , 2 , 3 end many do | x , y | puts x + y end # Output: 3 It's an error specifying more block parameters than the arguments yielded: def twice yield yield end twice do | i | # Error: too many block parameters end Each block parameter has the type of every yield expression in that position. For example: def some yield 1 , 'a' yield true , \"hello\" yield 2 , nil end some do | first , second | # first is Int32 | Bool # second is Char | String | Nil end","title":"Yield arguments"},{"location":"syntax_and_semantics/blocks_and_procs.html#short-one-parameter-syntax","text":"If a block has a single parameter and invokes a method on it, the block can be replaced with the short syntax argument. This: method do | param | param . some_method end and method { | param | param . some_method } can both be written as: method &. some_method Or like: method ( &. some_method ) In either case, &.some_method is an argument passed to method . This argument is syntactically equivalent to the block variants. It is only syntactic sugar and does not have any performance penalty. If the method has other required arguments, the short syntax argument should also be supplied in the method's argument list. [ \"a\" , \"b\" ]. join ( \",\" , &. upcase ) Is equivalent to: [ \"a\" , \"b\" ]. join ( \",\" ) { | s | s . upcase } Arguments can be used with the short syntax argument as well: [ \"i\" , \"o\" ]. join ( \",\" , &. upcase ( Unicode :: CaseOptions :: Turkic )) Operators can be invoked too: method &. + ( 2 ) method ( &. [index ] )","title":"Short one-parameter syntax"},{"location":"syntax_and_semantics/blocks_and_procs.html#yield-value","text":"The yield expression itself has a value: the last expression of the block. For example: def twice v1 = yield 1 puts v1 v2 = yield 2 puts v2 end twice do | i | i + 1 end The above prints \"2\" and \"3\". A yield expression's value is mostly useful for transforming and filtering values. The best examples of this are Enumerable#map and Enumerable#select : ary = [ 1 , 2 , 3 ] ary . map { | x | x + 1 } # => [2, 3, 4] ary . select { | x | x % 2 == 1 } # => [1, 3] A dummy transformation method: def transform ( value ) yield value end transform ( 1 ) { | x | x + 1 } # => 2 The result of the last expression is 2 because the last expression of the transform method is yield , whose value is the last expression of the block.","title":"yield value"},{"location":"syntax_and_semantics/blocks_and_procs.html#type-restrictions","text":"The type of the block in a method that uses yield can be restricted using the &block syntax. For example: def transform_int ( start : Int32 , & block : Int32 -> Int32 ) result = yield start result * 2 end transform_int ( 3 ) { | x | x + 2 } # => 10 transform_int ( 3 ) { | x | \"foo\" } # Error: expected block to return Int32, not String","title":"Type restrictions"},{"location":"syntax_and_semantics/blocks_and_procs.html#break","text":"A break expression inside a block exits early from the method: def thrice puts \"Before 1\" yield 1 puts \"Before 2\" yield 2 puts \"Before 3\" yield 3 puts \"After 3\" end thrice do | i | if i == 2 break end end The above prints \"Before 1\" and \"Before 2\". The thrice method didn't execute the puts \"Before 3\" expression because of the break . break can also accept arguments: these become the method's return value. For example: def twice yield 1 yield 2 end twice { | i | i + 1 } # => 3 twice { | i | break \"hello\" } # => \"hello\" The first call's value is 3 because the last expression of the twice method is yield , which gets the value of the block. The second call's value is \"hello\" because a break was performed. If there are conditional breaks, the call's return value type will be a union of the type of the block's value and the type of the many break s: value = twice do | i | if i == 1 break \"hello\" end i + 1 end value # :: Int32 | String If a break receives many arguments, they are automatically transformed to a Tuple : values = twice { break 1 , 2 } values # => {1, 2} If a break receives no arguments, it's the same as receiving a single nil argument: value = twice { break } value # => nil","title":"break"},{"location":"syntax_and_semantics/blocks_and_procs.html#next","text":"The next expression inside a block exits early from the block (not the method). For example: def twice yield 1 yield 2 end twice do | i | if i == 1 puts \"Skipping 1\" next end puts \"Got #{ i } \" end # Output: # Skipping 1 # Got 2 The next expression accepts arguments, and these give the value of the yield expression that invoked the block: def twice v1 = yield 1 puts v1 v2 = yield 2 puts v2 end twice do | i | if i == 1 next 10 end i + 1 end # Output # 10 # 3 If a next receives many arguments, they are automatically transformed to a Tuple . If it receives no arguments it's the same as receiving a single nil argument.","title":"next"},{"location":"syntax_and_semantics/blocks_and_procs.html#with-yield","text":"A yield expression can be modified, using the with keyword, to specify an object to use as the default receiver of method calls within the block: class Foo def one 1 end def yield_with_self with self yield end def yield_normally yield end end def one \"one\" end Foo . new . yield_with_self { one } # => 1 Foo . new . yield_normally { one } # => \"one\"","title":"with ... yield"},{"location":"syntax_and_semantics/blocks_and_procs.html#unpacking-block-parameters","text":"A block parameter can specify sub-parameters enclosed in parentheses: array = [ { 1 , \"one\" }, { 2 , \"two\" } ] array . each do | ( number , word ) | puts \" #{ number } : #{ word } \" end The above is simply syntax sugar of this: array = [ { 1 , \"one\" }, { 2 , \"two\" } ] array . each do | arg | number = arg [ 0 ] word = arg [ 1 ] puts \" #{ number } : #{ word } \" end That means that any type that responds to [] with integers can be unpacked in a block parameter. For Tuple parameters you can take advantage of auto-splatting and do not need parentheses: array = [ { 1 , \"one\" , true }, { 2 , \"two\" , false } ] array . each do | number , word , bool | puts \" #{ number } : #{ word } #{ bool } \" end Hash(K, V)#each passes Tuple(K, V) to the block so iterating key-value pairs works with auto-splatting: h = { \"foo\" => \"bar\" } h . each do | key , value | key # => \"foo\" value # => \"bar\" end","title":"Unpacking block parameters"},{"location":"syntax_and_semantics/blocks_and_procs.html#performance","text":"When using blocks with yield , the blocks are always inlined: no closures, calls or function pointers are involved. This means that this: def twice yield 1 yield 2 end twice do | i | puts \"Got: #{ i } \" end is exactly the same as writing this: i = 1 puts \"Got: #{ i } \" i = 2 puts \"Got: #{ i } \" For example, the standard library includes a times method on integers, allowing you to write: 3 . times do | i | puts i end This looks very fancy, but is it as fast as a C for loop? The answer is: yes! This is Int#times definition: struct Int def times i = 0 while i < self yield i i += 1 end end end Because a non-captured block is always inlined, the above method invocation is exactly the same as writing this: i = 0 while i < 3 puts i i += 1 end Have no fear using blocks for readability or code reuse, it won't affect the resulting executable performance.","title":"Performance"},{"location":"syntax_and_semantics/break.html","text":"break \u00b6 You can use break to break out of a while loop: a = 2 while ( a += 1 ) < 20 if a == 10 break # goes to 'puts a' end end puts a # => 10 break can also take an argument which will then be the value that gets returned: def foo loop do break \"bar\" end end puts foo # => \"bar\"","title":"break"},{"location":"syntax_and_semantics/break.html#break","text":"You can use break to break out of a while loop: a = 2 while ( a += 1 ) < 20 if a == 10 break # goes to 'puts a' end end puts a # => 10 break can also take an argument which will then be the value that gets returned: def foo loop do break \"bar\" end end puts foo # => \"bar\"","title":"break"},{"location":"syntax_and_semantics/capturing_blocks.html","text":"Capturing blocks \u00b6 A block can be captured and turned into a Proc , which represents a block of code with an associated context: the closured data. To capture a block you must specify it as a method's block parameter, give it a name and specify the input and output types. For example: def int_to_int ( & block : Int32 -> Int32 ) block end proc = int_to_int { | x | x + 1 } proc . call ( 1 ) # => 2 The above code captures the block of code passed to int_to_int in the block variable, and returns it from the method. The type of proc is Proc(Int32, Int32) , a function that accepts a single Int32 argument and returns an Int32 . In this way a block can be saved as a callback: class Model def on_save ( & block ) @on_save_callback = block end def save if callback = @on_save_callback callback . call end end end model = Model . new model . on_save { puts \"Saved!\" } model . save # prints \"Saved!\" In the above example the type of &block wasn't specified: this just means that the captured block doesn't take any arguments and doesn't return anything. Note that if the return type is not specified, nothing gets returned from the proc call: def some_proc ( & block : Int32 -> ) block end proc = some_proc { | x | x + 1 } proc . call ( 1 ) # void To have something returned, either specify the return type or use an underscore to allow any return type: def some_proc ( & block : Int32 -> _ ) block end proc = some_proc { | x | x + 1 } proc . call ( 1 ) # 2 proc = some_proc { | x | x . to_s } proc . call ( 1 ) # \"1\" break and next \u00b6 return and break can't be used inside a captured block. next can be used and will exit and give the value of the captured block. with ... yield \u00b6 The default receiver within a captured block can't be changed by using with ... yield .","title":"Capturing blocks"},{"location":"syntax_and_semantics/capturing_blocks.html#capturing-blocks","text":"A block can be captured and turned into a Proc , which represents a block of code with an associated context: the closured data. To capture a block you must specify it as a method's block parameter, give it a name and specify the input and output types. For example: def int_to_int ( & block : Int32 -> Int32 ) block end proc = int_to_int { | x | x + 1 } proc . call ( 1 ) # => 2 The above code captures the block of code passed to int_to_int in the block variable, and returns it from the method. The type of proc is Proc(Int32, Int32) , a function that accepts a single Int32 argument and returns an Int32 . In this way a block can be saved as a callback: class Model def on_save ( & block ) @on_save_callback = block end def save if callback = @on_save_callback callback . call end end end model = Model . new model . on_save { puts \"Saved!\" } model . save # prints \"Saved!\" In the above example the type of &block wasn't specified: this just means that the captured block doesn't take any arguments and doesn't return anything. Note that if the return type is not specified, nothing gets returned from the proc call: def some_proc ( & block : Int32 -> ) block end proc = some_proc { | x | x + 1 } proc . call ( 1 ) # void To have something returned, either specify the return type or use an underscore to allow any return type: def some_proc ( & block : Int32 -> _ ) block end proc = some_proc { | x | x + 1 } proc . call ( 1 ) # 2 proc = some_proc { | x | x . to_s } proc . call ( 1 ) # \"1\"","title":"Capturing blocks"},{"location":"syntax_and_semantics/capturing_blocks.html#break-and-next","text":"return and break can't be used inside a captured block. next can be used and will exit and give the value of the captured block.","title":"break and next"},{"location":"syntax_and_semantics/capturing_blocks.html#with-yield","text":"The default receiver within a captured block can't be changed by using with ... yield .","title":"with ... yield"},{"location":"syntax_and_semantics/case.html","text":"case \u00b6 A case is a control expression which functions a bit like pattern matching. It allows writing a chain of if-else-if with a small change in semantic and some more powerful constructs. In its basic form, it allows matching a value against other values: case exp when value1 , value2 do_something when value3 do_something_else else do_another_thing end # The above is the same as: tmp = exp if value1 === tmp || value2 === tmp do_something elsif value3 === tmp do_something_else else do_another_thing end For comparing an expression against a case 's value the case equality operator === is used. It is defined as a method on Object and can be overridden by subclasses to provide meaningful semantics in case statements. For example, Class defines case equality as when an object is an instance of that class, Regex as when the value matches the regular expression and Range as when the value is included in that range. If a when 's expression is a type, is_a? is used. Additionally, if the case expression is a variable or a variable assignment the type of the variable is restricted: case var when String # var : String do_something when Int32 # var : Int32 do_something_else else # here var is neither a String nor an Int32 do_another_thing end # The above is the same as: if var .is_a? ( String ) do_something elsif var .is_a? ( Int32 ) do_something_else else do_another_thing end You can invoke a method on the case 's expression in a when by using the implicit-object syntax: case num when . even? do_something when . odd? do_something_else end # The above is the same as: tmp = num if tmp . even? do_something elsif tmp . odd? do_something_else end You may use then after the when condition to place the body on a single line. case exp when value1 , value2 then do_something when value3 then do_something_else else do_another_thing end Finally, you can omit the case 's value: case when cond1 , cond2 do_something when cond3 do_something_else end # The above is the same as: if cond1 || cond2 do_something elsif cond3 do_something_else end This sometimes leads to code that is more natural to read. Tuple literal \u00b6 When a case expression is a tuple literal there are a few semantic differences if a when condition is also a tuple literal. Tuple size must match \u00b6 case { value1 , value2 } when { 0 , 0 } # OK, 2 elements # ... when { 1 , 2 , 3 } # Syntax error: wrong number of tuple elements (given 3, expected 2) # ... end Underscore allowed \u00b6 case { value1 , value2 } when { 0 , _ } # Matches if 0 === value1, no test done against value2 when { _ , 0 } # Matches if 0 === value2, no test done against value1 end Implicit-object allowed \u00b6 case { value1 , value2 } when { . even? , . odd? } # Matches if value1.even? && value2.odd? end Comparing against a type will perform an is_a? check \u00b6 case { value1 , value2 } when { String , Int32 } # Matches if value1.is_a?(String) && value2.is_a?(Int32) # The type of value1 is known to be a String by the compiler, # and the type of value2 is known to be an Int32 end","title":"case"},{"location":"syntax_and_semantics/case.html#case","text":"A case is a control expression which functions a bit like pattern matching. It allows writing a chain of if-else-if with a small change in semantic and some more powerful constructs. In its basic form, it allows matching a value against other values: case exp when value1 , value2 do_something when value3 do_something_else else do_another_thing end # The above is the same as: tmp = exp if value1 === tmp || value2 === tmp do_something elsif value3 === tmp do_something_else else do_another_thing end For comparing an expression against a case 's value the case equality operator === is used. It is defined as a method on Object and can be overridden by subclasses to provide meaningful semantics in case statements. For example, Class defines case equality as when an object is an instance of that class, Regex as when the value matches the regular expression and Range as when the value is included in that range. If a when 's expression is a type, is_a? is used. Additionally, if the case expression is a variable or a variable assignment the type of the variable is restricted: case var when String # var : String do_something when Int32 # var : Int32 do_something_else else # here var is neither a String nor an Int32 do_another_thing end # The above is the same as: if var .is_a? ( String ) do_something elsif var .is_a? ( Int32 ) do_something_else else do_another_thing end You can invoke a method on the case 's expression in a when by using the implicit-object syntax: case num when . even? do_something when . odd? do_something_else end # The above is the same as: tmp = num if tmp . even? do_something elsif tmp . odd? do_something_else end You may use then after the when condition to place the body on a single line. case exp when value1 , value2 then do_something when value3 then do_something_else else do_another_thing end Finally, you can omit the case 's value: case when cond1 , cond2 do_something when cond3 do_something_else end # The above is the same as: if cond1 || cond2 do_something elsif cond3 do_something_else end This sometimes leads to code that is more natural to read.","title":"case"},{"location":"syntax_and_semantics/case.html#tuple-literal","text":"When a case expression is a tuple literal there are a few semantic differences if a when condition is also a tuple literal.","title":"Tuple literal"},{"location":"syntax_and_semantics/case.html#tuple-size-must-match","text":"case { value1 , value2 } when { 0 , 0 } # OK, 2 elements # ... when { 1 , 2 , 3 } # Syntax error: wrong number of tuple elements (given 3, expected 2) # ... end","title":"Tuple size must match"},{"location":"syntax_and_semantics/case.html#underscore-allowed","text":"case { value1 , value2 } when { 0 , _ } # Matches if 0 === value1, no test done against value2 when { _ , 0 } # Matches if 0 === value2, no test done against value1 end","title":"Underscore allowed"},{"location":"syntax_and_semantics/case.html#implicit-object-allowed","text":"case { value1 , value2 } when { . even? , . odd? } # Matches if value1.even? && value2.odd? end","title":"Implicit-object allowed"},{"location":"syntax_and_semantics/case.html#comparing-against-a-type-will-perform-an-is_a-check","text":"case { value1 , value2 } when { String , Int32 } # Matches if value1.is_a?(String) && value2.is_a?(Int32) # The type of value1 is known to be a String by the compiler, # and the type of value2 is known to be an Int32 end","title":"Comparing against a type will perform an is_a? check"},{"location":"syntax_and_semantics/class_methods.html","text":"Class methods \u00b6 Class methods are methods associated to a class or module instead of a specific instance. module CaesarCipher def self . encrypt ( string : String ) string . chars . map { | char | (( char . upcase . ord - 52 ) % 26 + 65 ) . chr } . join end end CaesarCipher . encrypt ( \"HELLO\" ) # => \"URYYB\" Class methods are defined by prefixing the method name with the type name and a period. def CaesarCipher . decrypt ( string : String ) encrypt ( string ) end When they're defined inside a class or module scope it is easier to use self instead of the class name. Class methods can also be defined by extending a Module . A class method can be called under the same name as it was defined ( CaesarCipher.decrypt(\"HELLO\") ). When called from within the same class or module scope the receiver can be self or implicit (like encrypt(string) ). Constructors \u00b6 Constructors are normal class methods which create a new instance of the class . By default all classes in Crystal have at least one constructor called new , but they may also define other constructors with different names.","title":"Class methods"},{"location":"syntax_and_semantics/class_methods.html#class-methods","text":"Class methods are methods associated to a class or module instead of a specific instance. module CaesarCipher def self . encrypt ( string : String ) string . chars . map { | char | (( char . upcase . ord - 52 ) % 26 + 65 ) . chr } . join end end CaesarCipher . encrypt ( \"HELLO\" ) # => \"URYYB\" Class methods are defined by prefixing the method name with the type name and a period. def CaesarCipher . decrypt ( string : String ) encrypt ( string ) end When they're defined inside a class or module scope it is easier to use self instead of the class name. Class methods can also be defined by extending a Module . A class method can be called under the same name as it was defined ( CaesarCipher.decrypt(\"HELLO\") ). When called from within the same class or module scope the receiver can be self or implicit (like encrypt(string) ).","title":"Class methods"},{"location":"syntax_and_semantics/class_methods.html#constructors","text":"Constructors are normal class methods which create a new instance of the class . By default all classes in Crystal have at least one constructor called new , but they may also define other constructors with different names.","title":"Constructors"},{"location":"syntax_and_semantics/class_variables.html","text":"Class variables \u00b6 Class variables are associated to classes instead of instances. They are prefixed with two \"at\" signs ( @@ ). For example: class Counter @@instances = 0 def initialize @@instances += 1 end def self . instances @@instances end end Counter . instances # => 0 Counter . new Counter . new Counter . new Counter . instances # => 3 Class variables can be read and written from class methods or instance methods. Their type is inferred using the global type inference algorithm . Class variables are inherited by subclasses with this meaning: their type is the same, but each class has a different runtime value. For example: class Parent @@numbers = [] of Int32 def self . numbers @@numbers end end class Child < Parent end Parent . numbers # => [] Child . numbers # => [] Parent . numbers << 1 Parent . numbers # => [1] Child . numbers # => [] Class variables can also be associated to modules and structs. Like above, they are inherited by including/subclassing types.","title":"Class variables"},{"location":"syntax_and_semantics/class_variables.html#class-variables","text":"Class variables are associated to classes instead of instances. They are prefixed with two \"at\" signs ( @@ ). For example: class Counter @@instances = 0 def initialize @@instances += 1 end def self . instances @@instances end end Counter . instances # => 0 Counter . new Counter . new Counter . new Counter . instances # => 3 Class variables can be read and written from class methods or instance methods. Their type is inferred using the global type inference algorithm . Class variables are inherited by subclasses with this meaning: their type is the same, but each class has a different runtime value. For example: class Parent @@numbers = [] of Int32 def self . numbers @@numbers end end class Child < Parent end Parent . numbers # => [] Child . numbers # => [] Parent . numbers << 1 Parent . numbers # => [1] Child . numbers # => [] Class variables can also be associated to modules and structs. Like above, they are inherited by including/subclassing types.","title":"Class variables"},{"location":"syntax_and_semantics/classes_and_methods.html","text":"Classes and methods \u00b6 A class is a blueprint from which individual objects are created. As an example, consider a Person class. You declare a class like this: class Person end Class names, and indeed all type names, begin with a capital letter in Crystal.","title":"Classes and methods"},{"location":"syntax_and_semantics/classes_and_methods.html#classes-and-methods","text":"A class is a blueprint from which individual objects are created. As an example, consider a Person class. You declare a class like this: class Person end Class names, and indeed all type names, begin with a capital letter in Crystal.","title":"Classes and methods"},{"location":"syntax_and_semantics/closures.html","text":"Closures \u00b6 Captured blocks and proc literals closure local variables and self . This is better understood with an example: x = 0 proc = -> { x += 1 ; x } proc . call # => 1 proc . call # => 2 x # => 2 Or with a proc returned from a method: def counter x = 0 -> { x += 1 ; x } end proc = counter proc . call # => 1 proc . call # => 2 In the above example, even though x is a local variable, it was captured by the proc literal. In this case the compiler allocates x on the heap and uses it as the context data of the proc to make it work, because normally local variables live in the stack and are gone after a method returns. Type of closured variables \u00b6 The compiler is usually moderately smart about the type of local variables. For example: def foo yield end x = 1 foo do x = \"hello\" end x # : Int32 | String The compiler knows that after the block, x can be Int32 or String (it could know that it will always be String because the method always yields; this may improve in the future). If x is assigned something else after the block, the compiler knows the type changed: x = 1 foo do x = \"hello\" end x # : Int32 | String x = 'a' x # : Char However, if x is closured by a proc, the type is always the mixed type of all assignments to it: def capture ( & block ) block end x = 1 capture { x = \"hello\" } x = 'a' x # : Int32 | String | Char This is because the captured block could have been potentially stored in a class or instance variable and invoked in a separate thread in between the instructions. The compiler doesn't do an exhaustive analysis of this: it just assumes that if a variable is captured by a proc, the time of that proc invocation is unknown. This also happens with regular proc literals, even if it's evident that the proc wasn't invoked or stored: def capture ( & block ) block end x = 1 -> { x = \"hello\" } x = 'a' x # : Int32 | String | Char","title":"Closures"},{"location":"syntax_and_semantics/closures.html#closures","text":"Captured blocks and proc literals closure local variables and self . This is better understood with an example: x = 0 proc = -> { x += 1 ; x } proc . call # => 1 proc . call # => 2 x # => 2 Or with a proc returned from a method: def counter x = 0 -> { x += 1 ; x } end proc = counter proc . call # => 1 proc . call # => 2 In the above example, even though x is a local variable, it was captured by the proc literal. In this case the compiler allocates x on the heap and uses it as the context data of the proc to make it work, because normally local variables live in the stack and are gone after a method returns.","title":"Closures"},{"location":"syntax_and_semantics/closures.html#type-of-closured-variables","text":"The compiler is usually moderately smart about the type of local variables. For example: def foo yield end x = 1 foo do x = \"hello\" end x # : Int32 | String The compiler knows that after the block, x can be Int32 or String (it could know that it will always be String because the method always yields; this may improve in the future). If x is assigned something else after the block, the compiler knows the type changed: x = 1 foo do x = \"hello\" end x # : Int32 | String x = 'a' x # : Char However, if x is closured by a proc, the type is always the mixed type of all assignments to it: def capture ( & block ) block end x = 1 capture { x = \"hello\" } x = 'a' x # : Int32 | String | Char This is because the captured block could have been potentially stored in a class or instance variable and invoked in a separate thread in between the instructions. The compiler doesn't do an exhaustive analysis of this: it just assumes that if a variable is captured by a proc, the time of that proc invocation is unknown. This also happens with regular proc literals, even if it's evident that the proc wasn't invoked or stored: def capture ( & block ) block end x = 1 -> { x = \"hello\" } x = 'a' x # : Int32 | String | Char","title":"Type of closured variables"},{"location":"syntax_and_semantics/comments.html","text":"Comments \u00b6 Comments start with the # character. All following content up to the end of the line is part of the comment. Comments may be on their own line or follow after a Crystal expression (trailing comment). # This is a comment puts \"hello\" # This is a trailing comment The purpose of comments is documenting the code. Public documentation, including autogenerated API docs, is a special feature based on comments and is described in Documenting Code .","title":"Comments"},{"location":"syntax_and_semantics/comments.html#comments","text":"Comments start with the # character. All following content up to the end of the line is part of the comment. Comments may be on their own line or follow after a Crystal expression (trailing comment). # This is a comment puts \"hello\" # This is a trailing comment The purpose of comments is documenting the code. Public documentation, including autogenerated API docs, is a special feature based on comments and is described in Documenting Code .","title":"Comments"},{"location":"syntax_and_semantics/compile_time_flags.html","text":"Compile-time flags \u00b6 Types, methods and generally any part of your code can be conditionally defined based on some flags available at compile time. These flags are by default read from the hosts LLVM Target Triple , split on - . To get the target you can execute llvm-config --host-target . $ llvm-config --host-target x86_64-unknown-linux-gnu # so the flags are: x86_64, unknown, linux, gnu To define a flag, simply use the --define or -D option, like so: crystal some_program.cr -Dflag Additionally, if a program is compiled with --release , the release flag will be set. You can check if a flag is defined with the flag? macro method: {% if flag? ( :x86_64 ) %} # some specific code for 64 bits platforms {% else %} # some specific code for non-64 bits platforms {% end %} flag? returns a boolean, so you can use it with && and || : {% if flag? ( :linux ) && flag? ( :x86_64 ) %} # some specific code for linux 64 bits {% end %} These flags are generally used in C bindings to conditionally define types and functions. For example, the very well known size_t type is defined like this in Crystal: lib C {% if flag? ( :x86_64 ) %} alias SizeT = UInt64 {% else %} alias SizeT = UInt32 {% end %} end","title":"Compile-time flags"},{"location":"syntax_and_semantics/compile_time_flags.html#compile-time-flags","text":"Types, methods and generally any part of your code can be conditionally defined based on some flags available at compile time. These flags are by default read from the hosts LLVM Target Triple , split on - . To get the target you can execute llvm-config --host-target . $ llvm-config --host-target x86_64-unknown-linux-gnu # so the flags are: x86_64, unknown, linux, gnu To define a flag, simply use the --define or -D option, like so: crystal some_program.cr -Dflag Additionally, if a program is compiled with --release , the release flag will be set. You can check if a flag is defined with the flag? macro method: {% if flag? ( :x86_64 ) %} # some specific code for 64 bits platforms {% else %} # some specific code for non-64 bits platforms {% end %} flag? returns a boolean, so you can use it with && and || : {% if flag? ( :linux ) && flag? ( :x86_64 ) %} # some specific code for linux 64 bits {% end %} These flags are generally used in C bindings to conditionally define types and functions. For example, the very well known size_t type is defined like this in Crystal: lib C {% if flag? ( :x86_64 ) %} alias SizeT = UInt64 {% else %} alias SizeT = UInt32 {% end %} end","title":"Compile-time flags"},{"location":"syntax_and_semantics/constants.html","text":"Constants \u00b6 Constants can be declared at the top level or inside other types. They must start with a capital letter: PI = 3.14 module Earth RADIUS = 6_371_000 end PI # => 3.14 Earth :: RADIUS # => 6_371_000 Although not enforced by the compiler, constants are usually named with all capital letters and underscores to separate words. A constant definition can invoke methods and have complex logic: TEN = begin a = 0 while a < 10 a += 1 end a end TEN # => 10 Pseudo Constants \u00b6 Crystal provides a few pseudo-constants which provide reflective data about the source code being executed. __LINE__ is the current line number in the currently executing crystal file. When __LINE__ is used as a default parameter value, it represents the line number at the location of the method call. __END_LINE__ is the line number of the end of the calling block. Can only be used as a default parameter value. __FILE__ references the full path to the currently executing crystal file. __DIR__ references the full path to the directory where the currently executing crystal file is located. # Assuming this example code is saved at: /crystal_code/pseudo_constants.cr # def pseudo_constants ( caller_line = __LINE__ , end_of_caller = __END_LINE__ ) puts \"Called from line number: #{ caller_line } \" puts \"Currently at line number: #{ __LINE__ } \" puts \"End of caller block is at: #{ end_of_caller } \" puts \"File path is: #{ __FILE__ } \" puts \"Directory file is in: #{ __DIR__ } \" end begin pseudo_constants end # Program prints: # Called from line number: 13 # Currently at line number: 5 # End of caller block is at: 14 # File path is: /crystal_code/pseudo_constants.cr # Directory file is in: /crystal_code Dynamic assignment \u00b6 Dynamically assigning values to constants using the chained assignment or the multiple assignment is not supported and results in a syntax error. ONE , TWO , THREE = 1 , 2 , 3 # Syntax error: Multiple assignment is not allowed for constants","title":"Constants"},{"location":"syntax_and_semantics/constants.html#constants","text":"Constants can be declared at the top level or inside other types. They must start with a capital letter: PI = 3.14 module Earth RADIUS = 6_371_000 end PI # => 3.14 Earth :: RADIUS # => 6_371_000 Although not enforced by the compiler, constants are usually named with all capital letters and underscores to separate words. A constant definition can invoke methods and have complex logic: TEN = begin a = 0 while a < 10 a += 1 end a end TEN # => 10","title":"Constants"},{"location":"syntax_and_semantics/constants.html#pseudo-constants","text":"Crystal provides a few pseudo-constants which provide reflective data about the source code being executed. __LINE__ is the current line number in the currently executing crystal file. When __LINE__ is used as a default parameter value, it represents the line number at the location of the method call. __END_LINE__ is the line number of the end of the calling block. Can only be used as a default parameter value. __FILE__ references the full path to the currently executing crystal file. __DIR__ references the full path to the directory where the currently executing crystal file is located. # Assuming this example code is saved at: /crystal_code/pseudo_constants.cr # def pseudo_constants ( caller_line = __LINE__ , end_of_caller = __END_LINE__ ) puts \"Called from line number: #{ caller_line } \" puts \"Currently at line number: #{ __LINE__ } \" puts \"End of caller block is at: #{ end_of_caller } \" puts \"File path is: #{ __FILE__ } \" puts \"Directory file is in: #{ __DIR__ } \" end begin pseudo_constants end # Program prints: # Called from line number: 13 # Currently at line number: 5 # End of caller block is at: 14 # File path is: /crystal_code/pseudo_constants.cr # Directory file is in: /crystal_code","title":"Pseudo Constants"},{"location":"syntax_and_semantics/constants.html#dynamic-assignment","text":"Dynamically assigning values to constants using the chained assignment or the multiple assignment is not supported and results in a syntax error. ONE , TWO , THREE = 1 , 2 , 3 # Syntax error: Multiple assignment is not allowed for constants","title":"Dynamic assignment"},{"location":"syntax_and_semantics/control_expressions.html","text":"Control expressions \u00b6 Before talking about control expressions we need to know what truthy and falsey values are.","title":"Control expressions"},{"location":"syntax_and_semantics/control_expressions.html#control-expressions","text":"Before talking about control expressions we need to know what truthy and falsey values are.","title":"Control expressions"},{"location":"syntax_and_semantics/cross-compilation.html","text":"Cross-compilation \u00b6 Crystal supports a basic form of cross compilation . In order to achieve this, the compiler executable provides two flags: --cross-compile : When given enables cross compilation mode --target : the LLVM Target Triple to use and set the default compile-time flags from To get the --target flags you can execute llvm-config --host-target using an installed LLVM 3.5. For example on a Linux it could say \"x86_64-unknown-linux-gnu\". If you need to set any compile-time flags not set implicitly through --target , you can use the -D command line flag. Using these two, we can compile a program in a Mac that will run on that Linux like this: crystal build your_program.cr --cross-compile --target \"x86_64-unknown-linux-gnu\" This will generate a .o ( Object file ) and will print a line with a command to execute on the system we are trying to cross-compile to. For example: cc your_program.o -o your_program -lpcre -lrt -lm -lgc -lunwind You must copy this .o file to that system and execute those commands. Once you do this the executable will be available in that target system. This procedure is usually done with the compiler itself to port it to new platforms where a compiler is not yet available. Because in order to compile a Crystal compiler we need an older Crystal compiler, the only two ways to generate a compiler for a system where there isn't a compiler yet are: We checkout the latest version of the compiler written in Ruby, and from that compiler we compile the next versions until the current one. We create a .o file in the target system and from that file we create a compiler. The first alternative is long and cumbersome, while the second one is much easier. Cross-compiling can be done for other executables, but its main target is the compiler. If Crystal isn't available in some system you can try cross-compiling it there.","title":"Cross-compilation"},{"location":"syntax_and_semantics/cross-compilation.html#cross-compilation","text":"Crystal supports a basic form of cross compilation . In order to achieve this, the compiler executable provides two flags: --cross-compile : When given enables cross compilation mode --target : the LLVM Target Triple to use and set the default compile-time flags from To get the --target flags you can execute llvm-config --host-target using an installed LLVM 3.5. For example on a Linux it could say \"x86_64-unknown-linux-gnu\". If you need to set any compile-time flags not set implicitly through --target , you can use the -D command line flag. Using these two, we can compile a program in a Mac that will run on that Linux like this: crystal build your_program.cr --cross-compile --target \"x86_64-unknown-linux-gnu\" This will generate a .o ( Object file ) and will print a line with a command to execute on the system we are trying to cross-compile to. For example: cc your_program.o -o your_program -lpcre -lrt -lm -lgc -lunwind You must copy this .o file to that system and execute those commands. Once you do this the executable will be available in that target system. This procedure is usually done with the compiler itself to port it to new platforms where a compiler is not yet available. Because in order to compile a Crystal compiler we need an older Crystal compiler, the only two ways to generate a compiler for a system where there isn't a compiler yet are: We checkout the latest version of the compiler written in Ruby, and from that compiler we compile the next versions until the current one. We create a .o file in the target system and from that file we create a compiler. The first alternative is long and cumbersome, while the second one is much easier. Cross-compiling can be done for other executables, but its main target is the compiler. If Crystal isn't available in some system you can try cross-compiling it there.","title":"Cross-compilation"},{"location":"syntax_and_semantics/declare_var.html","text":"Uninitialized variable declaration \u00b6 Crystal allows declaring uninitialized variables: x = uninitialized Int32 x # => some random value, garbage, unreliable This is unsafe code and is almost always used in low-level code for declaring uninitialized StaticArray buffers without a performance penalty: buffer = uninitialized UInt8 [ 256 ] The buffer is allocated on the stack, avoiding a heap allocation. The type after the uninitialized keyword follows the type grammar .","title":"Uninitialized variable declaration"},{"location":"syntax_and_semantics/declare_var.html#uninitialized-variable-declaration","text":"Crystal allows declaring uninitialized variables: x = uninitialized Int32 x # => some random value, garbage, unreliable This is unsafe code and is almost always used in low-level code for declaring uninitialized StaticArray buffers without a performance penalty: buffer = uninitialized UInt8 [ 256 ] The buffer is allocated on the stack, avoiding a heap allocation. The type after the uninitialized keyword follows the type grammar .","title":"Uninitialized variable declaration"},{"location":"syntax_and_semantics/default_and_named_arguments.html","text":"Default parameter values \u00b6 A method can specify default values for the last parameters: class Person def become_older ( by = 1 ) @age += by end end john = Person . new \"John\" john . age # => 0 john . become_older john . age # => 1 john . become_older 2 john . age # => 3 Named arguments \u00b6 All arguments can also be specified, in addition to their position, by their name. For example: john . become_older by : 5 When there are many arguments, the order of the names in the invocation doesn't matter, as long as all required parameters are covered: def some_method ( x , y = 1 , z = 2 , w = 3 ) # do something... end some_method 10 # x: 10, y: 1, z: 2, w: 3 some_method 10 , z : 10 # x: 10, y: 1, z: 10, w: 3 some_method 10 , w : 1 , y : 2 , z : 3 # x: 10, y: 2, z: 3, w: 1 some_method y : 10 , x : 20 # x: 20, y: 10, z: 2, w: 3 some_method y : 10 # Error, missing argument: x When a method specifies a splat parameter (explained in the next section), named arguments can't be used for positional parameters. The reason is that understanding how arguments are matched becomes very difficult; positional arguments are easier to reason about in this case.","title":"Default parameter values and named arguments"},{"location":"syntax_and_semantics/default_and_named_arguments.html#default-parameter-values","text":"A method can specify default values for the last parameters: class Person def become_older ( by = 1 ) @age += by end end john = Person . new \"John\" john . age # => 0 john . become_older john . age # => 1 john . become_older 2 john . age # => 3","title":"Default parameter values"},{"location":"syntax_and_semantics/default_and_named_arguments.html#named-arguments","text":"All arguments can also be specified, in addition to their position, by their name. For example: john . become_older by : 5 When there are many arguments, the order of the names in the invocation doesn't matter, as long as all required parameters are covered: def some_method ( x , y = 1 , z = 2 , w = 3 ) # do something... end some_method 10 # x: 10, y: 1, z: 2, w: 3 some_method 10 , z : 10 # x: 10, y: 1, z: 10, w: 3 some_method 10 , w : 1 , y : 2 , z : 3 # x: 10, y: 2, z: 3, w: 1 some_method y : 10 , x : 20 # x: 20, y: 10, z: 2, w: 3 some_method y : 10 # Error, missing argument: x When a method specifies a splat parameter (explained in the next section), named arguments can't be used for positional parameters. The reason is that understanding how arguments are matched becomes very difficult; positional arguments are easier to reason about in this case.","title":"Named arguments"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html","text":"Method arguments \u00b6 This is the formal specification of method parameters and call arguments. Components of a method definition \u00b6 A method definition consists of: required and optional positional parameters an optional splat parameter, whose name can be empty required and optional named parameters an optional double splat parameter For example: def foo ( # These are positional parameters: x , y , z = 1 , # This is the splat parameter: * args , # These are the named parameters: a , b , c = 2 , # This is the double splat parameter: ** options ) end Each one of them is optional, so a method can do without the double splat, without the splat, without named parameters and without positional parameters. Components of a method call \u00b6 A method call also has some parts: foo ( # These are positional arguments 1 , 2 , # These are named arguments a : 1 , b : 2 ) Additionally, a call argument can have a splat ( * ) or double splat ( ** ). A splat expands a Tuple into positional arguments, while a double splat expands a NamedTuple into named arguments. Multiple argument splats and double splats are allowed. How call arguments are matched to method parameters \u00b6 When invoking a method, the algorithm to match call arguments to method parameters is: First positional call arguments are matched with positional method parameters. The number of these must be at least the number of positional parameters without a default value. If there's a splat parameter with a name (the case without a name is explained below), more positional arguments are allowed and they are captured as a tuple. Positional arguments never match past the splat parameter. Then named arguments are matched, by name, with any parameter in the method (it can be before or after the splat parameter). If a parameter was already filled by a positional argument then it's an error. Extra named arguments are placed in the double splat method parameter, as a NamedTuple , if it exists, otherwise it's an error. When a splat parameter has no name, it means no more positional arguments can be passed, and any following parameters must be passed as named arguments. For example: # Only one positional argument allowed, y must be passed as a named argument def foo ( x , * , y ) end foo 1 # Error, missing argument: y foo 1 , 2 # Error: wrong number of arguments (given 2, expected 1) foo 1 , y : 10 # OK But even if a splat parameter has a name, parameters that follow it must be passed as named arguments: # One or more positional argument allowed, y must be passed as a named argument def foo ( x , * args , y ) end foo 1 # Error, missing argument: y foo 1 , 2 # Error: missing argument; y foo 1 , 2 , 3 # Error: missing argument: y foo 1 , y : 10 # OK foo 1 , 2 , 3 , y : 4 # OK There's also the possibility of making a method only receive named arguments (and list them), by placing the star at the beginning: # A method with two required named parameters: x and y def foo ( * , x , y ) end foo # Error: missing arguments: x, y foo x : 1 # Error: missing argument: y foo x : 1 , y : 2 # OK Parameters past the star can also have default values. It means: they must be passed as named arguments, but they aren't required (so: optional named parameters): # x is a required named parameter, y is an optional named parameter def foo ( * , x , y = 2 ) end foo # Error: missing argument: x foo x : 1 # OK, y is 2 foo x : 1 , y : 3 # OK, y is 3 Because parameters (without a default value) after the splat parameter must be passed by name, two methods with different required named parameters overload: def foo ( * , x ) puts \"Passed with x: #{ x } \" end def foo ( * , y ) puts \"Passed with y: #{ y } \" end foo x : 1 # => Passed with x: 1 foo y : 2 # => Passed with y: 2 Positional parameters can always be matched by name: def foo ( x , * , y ) end foo 1 , y : 2 # OK foo y : 2 , x : 3 # OK External names \u00b6 An external name can be specified for a method parameter. The external name is the one used when passing an argument as a named argument, and the internal name is the one used to refer to the parameter inside the method definition: def foo ( external_name internal_name ) # here we use internal_name end foo external_name : 1 This covers two uses cases. The first use case is using keywords as named parameters: def plan ( begin begin_time , end end_time ) puts \"Planning between #{ begin_time } and #{ end_time } \" end plan begin : Time . now , end : 2 . days . from_now The second use case is making a method parameter more readable inside a method body: def increment ( value , by ) # OK, but reads odd value + by end def increment ( value , by amount ) # Better value + amount end","title":"Method arguments"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html#method-arguments","text":"This is the formal specification of method parameters and call arguments.","title":"Method arguments"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html#components-of-a-method-definition","text":"A method definition consists of: required and optional positional parameters an optional splat parameter, whose name can be empty required and optional named parameters an optional double splat parameter For example: def foo ( # These are positional parameters: x , y , z = 1 , # This is the splat parameter: * args , # These are the named parameters: a , b , c = 2 , # This is the double splat parameter: ** options ) end Each one of them is optional, so a method can do without the double splat, without the splat, without named parameters and without positional parameters.","title":"Components of a method definition"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html#components-of-a-method-call","text":"A method call also has some parts: foo ( # These are positional arguments 1 , 2 , # These are named arguments a : 1 , b : 2 ) Additionally, a call argument can have a splat ( * ) or double splat ( ** ). A splat expands a Tuple into positional arguments, while a double splat expands a NamedTuple into named arguments. Multiple argument splats and double splats are allowed.","title":"Components of a method call"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html#how-call-arguments-are-matched-to-method-parameters","text":"When invoking a method, the algorithm to match call arguments to method parameters is: First positional call arguments are matched with positional method parameters. The number of these must be at least the number of positional parameters without a default value. If there's a splat parameter with a name (the case without a name is explained below), more positional arguments are allowed and they are captured as a tuple. Positional arguments never match past the splat parameter. Then named arguments are matched, by name, with any parameter in the method (it can be before or after the splat parameter). If a parameter was already filled by a positional argument then it's an error. Extra named arguments are placed in the double splat method parameter, as a NamedTuple , if it exists, otherwise it's an error. When a splat parameter has no name, it means no more positional arguments can be passed, and any following parameters must be passed as named arguments. For example: # Only one positional argument allowed, y must be passed as a named argument def foo ( x , * , y ) end foo 1 # Error, missing argument: y foo 1 , 2 # Error: wrong number of arguments (given 2, expected 1) foo 1 , y : 10 # OK But even if a splat parameter has a name, parameters that follow it must be passed as named arguments: # One or more positional argument allowed, y must be passed as a named argument def foo ( x , * args , y ) end foo 1 # Error, missing argument: y foo 1 , 2 # Error: missing argument; y foo 1 , 2 , 3 # Error: missing argument: y foo 1 , y : 10 # OK foo 1 , 2 , 3 , y : 4 # OK There's also the possibility of making a method only receive named arguments (and list them), by placing the star at the beginning: # A method with two required named parameters: x and y def foo ( * , x , y ) end foo # Error: missing arguments: x, y foo x : 1 # Error: missing argument: y foo x : 1 , y : 2 # OK Parameters past the star can also have default values. It means: they must be passed as named arguments, but they aren't required (so: optional named parameters): # x is a required named parameter, y is an optional named parameter def foo ( * , x , y = 2 ) end foo # Error: missing argument: x foo x : 1 # OK, y is 2 foo x : 1 , y : 3 # OK, y is 3 Because parameters (without a default value) after the splat parameter must be passed by name, two methods with different required named parameters overload: def foo ( * , x ) puts \"Passed with x: #{ x } \" end def foo ( * , y ) puts \"Passed with y: #{ y } \" end foo x : 1 # => Passed with x: 1 foo y : 2 # => Passed with y: 2 Positional parameters can always be matched by name: def foo ( x , * , y ) end foo 1 , y : 2 # OK foo y : 2 , x : 3 # OK","title":"How call arguments are matched to method parameters"},{"location":"syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html#external-names","text":"An external name can be specified for a method parameter. The external name is the one used when passing an argument as a named argument, and the internal name is the one used to refer to the parameter inside the method definition: def foo ( external_name internal_name ) # here we use internal_name end foo external_name : 1 This covers two uses cases. The first use case is using keywords as named parameters: def plan ( begin begin_time , end end_time ) puts \"Planning between #{ begin_time } and #{ end_time } \" end plan begin : Time . now , end : 2 . days . from_now The second use case is making a method parameter more readable inside a method body: def increment ( value , by ) # OK, but reads odd value + by end def increment ( value , by amount ) # Better value + amount end","title":"External names"},{"location":"syntax_and_semantics/documenting_code.html","text":"Documenting code \u00b6 Documentation for API features can be written in code comments directly preceding the definition of the respective feature. By default, all public methods, macros, types and constants are considered part of the API documentation. Tip The compiler command crystal docs automatically extracts the API documentation and generates a website to present it. Association \u00b6 Doc comments must be positioned directly above the definition of the documented feature. Consecutive comment lines are combined into a single comment block. Any empty line breaks the association to the documented feature. # This comment is not associated with the class. # First line of documentation for class Unicorn. # Second line of documentation for class Unicorn. class Unicorn end Format \u00b6 Doc comments support Markdown formatting. The first paragraph of a doc comment is considered its summary. It should concisely define the purpose and functionality. Supplementary details and usages instructions should follow in subsequent paragraphs. For instance: # Returns the number of horns this unicorn has. # # Always returns `1`. def horns 1 end Tip It is generally advised to use descriptive, third person present tense: Returns the number of horns this unicorn has (instead of an imperative Return the number of horns this unicorn has ). Markup \u00b6 Linking \u00b6 References to other API features can be enclosed in single backticks. They are automatically resolved and converted into links to the respective feature. class Unicorn # Creates a new `Unicorn` instance. def initialize end end The same lookup rules apply as in Crystal code. Features in the currently documented namespace can be accessed with relative names: Instance methods are referenced with a hash prefix: #horns . Class methods are referenced with a dot prefix: .new . Constants and types are referenced by their name: Unicorn . Features in other namespaces are referenced with the fully-qualified type path: Unicorn#horns , Unicorn.new , Unicorn::CONST . Different overloads of a method can be identified by the full signature .new(name) , ,new(name, age) . Parameters \u00b6 When refering to parameters, it is recommended to write their name italicized ( *italicized* ): # Creates a unicorn with the specified number of *horns*. def initialize ( @horns = 1 ) raise \"Not a unicorn\" if @horns != 1 end Code Examples \u00b6 Code examples can be placed in Markdown code blocks. If no language tag is given, the code block is considered to be Crystal code. # Example: # ``` # unicorn = Unicorn.new # unicorn.horns # => 1 # ``` class Unicorn end To designate a code block as plain text, it must be explicitly tagged. # Output: # ```plain # \"I'm a unicorn\" # ``` def say puts \"I'm a unicorn\" end Other language tags can also be used. To show the value of an expression inside code blocks, use # => . 1 + 2 # => 3 Unicorn . new . speak # => \"I'm a unicorn\" Admonitions \u00b6 Several admonition keywords are supported to visually highlight problems, notes and/or possible issues. BUG DEPRECATED FIXME NOTE OPTIMIZE TODO Admonition keywords must be the first word in their respective line and must be in all caps. An optional trailing colon is preferred for readability. # Makes the unicorn speak to STDOUT # # NOTE: Although unicorns don't normally talk, this one is special # TODO: Check if unicorn is asleep and raise exception if not able to speak # TODO: Create another `speak` method that takes and prints a string def speak puts \"I'm a unicorn\" end # Makes the unicorn talk to STDOUT # # DEPRECATED: Use `speak` def talk puts \"I'm a unicorn\" end The compiler implicitly adds some admonitions to doc comments: The @[Deprecated] annotation adds a DEPRECATED admonition. The @[Experimental] annotation adds an EXPERIMENTAL admonition. Directives \u00b6 Directives tell the documentation generator how to treat documentation for a specific feature. ditto \u00b6 If two consecutively defined features have the same documentation, :ditto: can be used to copy the same doc comment from the previous definition. # Returns the number of horns. def horns horns end # :ditto: def number_of_horns horns end The directive needs to be on a separate line but further documentation can be added in other lines. The :ditto: directive is simply replaced by the content of the previous doc comment. nodoc \u00b6 Public features can be hidden from the API docs with the :nodoc: directive. Private and protected features are always hidden. # :nodoc: class InternalHelper end This directive needs to be the first line in a doc comment. Leading whitespace if optional. Following comment lines can be used for internal documentation. inherit \u00b6 See Inheriting Documentation . Inheriting Documentation \u00b6 When an instance method has no doc comment, but a method with the same signature exists in a parent type, the documentation is inherited from the parent method. For example: abstract class Animal # Returns the name of `self`. abstract def name : String end class Unicorn < Animal def name : String \"unicorn\" end end The documentation for Unicorn#name would be: Description copied from class `Animal` Returns the name of `self`. The child method can use :inherit: to explicitly copy the parent's documentation, without the Description copied from ... text. :inherit: can also be used to inject the parent's documentation into additional documentation on the child. For example: abstract class Parent # Some documentation common to every *id*. abstract def id : Int32 end class Child < Parent # Some documentation specific to *id*'s usage within `Child`. # # :inherit: def id : Int32 - 1 end end The documentation for Child#id would be: Some documentation specific to *id*'s usage within `Child`. Some documentation common to every *id*. Note Inheriting documentation only works on instance , non-constructor methods. A Complete Example \u00b6 # A unicorn is a **legendary animal** (see the `Legendary` module) that has been # described since antiquity as a beast with a large, spiraling horn projecting # from its forehead. # # To create a unicorn: # # ``` # unicorn = Unicorn.new # unicorn.speak # ``` # # The above produces: # # ```text # \"I'm a unicorn\" # ``` # # Check the number of horns with `#horns`. class Unicorn include Legendary # Creates a unicorn with the specified number of *horns*. def initialize ( @horns = 1 ) raise \"Not a unicorn\" if @horns != 1 end # Returns the number of horns this unicorn has # # ``` # Unicorn.new.horns # => 1 # ``` def horns @horns end # :ditto: def number_of_horns horns end # Makes the unicorn speak to STDOUT def speak puts \"I'm a unicorn\" end # :nodoc: class Helper end end","title":"Documenting code"},{"location":"syntax_and_semantics/documenting_code.html#documenting-code","text":"Documentation for API features can be written in code comments directly preceding the definition of the respective feature. By default, all public methods, macros, types and constants are considered part of the API documentation. Tip The compiler command crystal docs automatically extracts the API documentation and generates a website to present it.","title":"Documenting code"},{"location":"syntax_and_semantics/documenting_code.html#association","text":"Doc comments must be positioned directly above the definition of the documented feature. Consecutive comment lines are combined into a single comment block. Any empty line breaks the association to the documented feature. # This comment is not associated with the class. # First line of documentation for class Unicorn. # Second line of documentation for class Unicorn. class Unicorn end","title":"Association"},{"location":"syntax_and_semantics/documenting_code.html#format","text":"Doc comments support Markdown formatting. The first paragraph of a doc comment is considered its summary. It should concisely define the purpose and functionality. Supplementary details and usages instructions should follow in subsequent paragraphs. For instance: # Returns the number of horns this unicorn has. # # Always returns `1`. def horns 1 end Tip It is generally advised to use descriptive, third person present tense: Returns the number of horns this unicorn has (instead of an imperative Return the number of horns this unicorn has ).","title":"Format"},{"location":"syntax_and_semantics/documenting_code.html#markup","text":"","title":"Markup"},{"location":"syntax_and_semantics/documenting_code.html#linking","text":"References to other API features can be enclosed in single backticks. They are automatically resolved and converted into links to the respective feature. class Unicorn # Creates a new `Unicorn` instance. def initialize end end The same lookup rules apply as in Crystal code. Features in the currently documented namespace can be accessed with relative names: Instance methods are referenced with a hash prefix: #horns . Class methods are referenced with a dot prefix: .new . Constants and types are referenced by their name: Unicorn . Features in other namespaces are referenced with the fully-qualified type path: Unicorn#horns , Unicorn.new , Unicorn::CONST . Different overloads of a method can be identified by the full signature .new(name) , ,new(name, age) .","title":"Linking"},{"location":"syntax_and_semantics/documenting_code.html#parameters","text":"When refering to parameters, it is recommended to write their name italicized ( *italicized* ): # Creates a unicorn with the specified number of *horns*. def initialize ( @horns = 1 ) raise \"Not a unicorn\" if @horns != 1 end","title":"Parameters"},{"location":"syntax_and_semantics/documenting_code.html#code-examples","text":"Code examples can be placed in Markdown code blocks. If no language tag is given, the code block is considered to be Crystal code. # Example: # ``` # unicorn = Unicorn.new # unicorn.horns # => 1 # ``` class Unicorn end To designate a code block as plain text, it must be explicitly tagged. # Output: # ```plain # \"I'm a unicorn\" # ``` def say puts \"I'm a unicorn\" end Other language tags can also be used. To show the value of an expression inside code blocks, use # => . 1 + 2 # => 3 Unicorn . new . speak # => \"I'm a unicorn\"","title":"Code Examples"},{"location":"syntax_and_semantics/documenting_code.html#admonitions","text":"Several admonition keywords are supported to visually highlight problems, notes and/or possible issues. BUG DEPRECATED FIXME NOTE OPTIMIZE TODO Admonition keywords must be the first word in their respective line and must be in all caps. An optional trailing colon is preferred for readability. # Makes the unicorn speak to STDOUT # # NOTE: Although unicorns don't normally talk, this one is special # TODO: Check if unicorn is asleep and raise exception if not able to speak # TODO: Create another `speak` method that takes and prints a string def speak puts \"I'm a unicorn\" end # Makes the unicorn talk to STDOUT # # DEPRECATED: Use `speak` def talk puts \"I'm a unicorn\" end The compiler implicitly adds some admonitions to doc comments: The @[Deprecated] annotation adds a DEPRECATED admonition. The @[Experimental] annotation adds an EXPERIMENTAL admonition.","title":"Admonitions"},{"location":"syntax_and_semantics/documenting_code.html#directives","text":"Directives tell the documentation generator how to treat documentation for a specific feature.","title":"Directives"},{"location":"syntax_and_semantics/documenting_code.html#ditto","text":"If two consecutively defined features have the same documentation, :ditto: can be used to copy the same doc comment from the previous definition. # Returns the number of horns. def horns horns end # :ditto: def number_of_horns horns end The directive needs to be on a separate line but further documentation can be added in other lines. The :ditto: directive is simply replaced by the content of the previous doc comment.","title":"ditto"},{"location":"syntax_and_semantics/documenting_code.html#nodoc","text":"Public features can be hidden from the API docs with the :nodoc: directive. Private and protected features are always hidden. # :nodoc: class InternalHelper end This directive needs to be the first line in a doc comment. Leading whitespace if optional. Following comment lines can be used for internal documentation.","title":"nodoc"},{"location":"syntax_and_semantics/documenting_code.html#inherit","text":"See Inheriting Documentation .","title":"inherit"},{"location":"syntax_and_semantics/documenting_code.html#inheriting-documentation","text":"When an instance method has no doc comment, but a method with the same signature exists in a parent type, the documentation is inherited from the parent method. For example: abstract class Animal # Returns the name of `self`. abstract def name : String end class Unicorn < Animal def name : String \"unicorn\" end end The documentation for Unicorn#name would be: Description copied from class `Animal` Returns the name of `self`. The child method can use :inherit: to explicitly copy the parent's documentation, without the Description copied from ... text. :inherit: can also be used to inject the parent's documentation into additional documentation on the child. For example: abstract class Parent # Some documentation common to every *id*. abstract def id : Int32 end class Child < Parent # Some documentation specific to *id*'s usage within `Child`. # # :inherit: def id : Int32 - 1 end end The documentation for Child#id would be: Some documentation specific to *id*'s usage within `Child`. Some documentation common to every *id*. Note Inheriting documentation only works on instance , non-constructor methods.","title":"Inheriting Documentation"},{"location":"syntax_and_semantics/documenting_code.html#a-complete-example","text":"# A unicorn is a **legendary animal** (see the `Legendary` module) that has been # described since antiquity as a beast with a large, spiraling horn projecting # from its forehead. # # To create a unicorn: # # ``` # unicorn = Unicorn.new # unicorn.speak # ``` # # The above produces: # # ```text # \"I'm a unicorn\" # ``` # # Check the number of horns with `#horns`. class Unicorn include Legendary # Creates a unicorn with the specified number of *horns*. def initialize ( @horns = 1 ) raise \"Not a unicorn\" if @horns != 1 end # Returns the number of horns this unicorn has # # ``` # Unicorn.new.horns # => 1 # ``` def horns @horns end # :ditto: def number_of_horns horns end # Makes the unicorn speak to STDOUT def speak puts \"I'm a unicorn\" end # :nodoc: class Helper end end","title":"A Complete Example"},{"location":"syntax_and_semantics/enum.html","text":"Enums \u00b6 An enum is a set of integer values, where each value has an associated name. For example: enum Color Red Green Blue end An enum is defined with the enum keyword, followed by its name. The enum's body contains the values. Values start with the value 0 and are incremented by one. The default value can be overwritten: enum Color Red # 0 Green # 1 Blue = 5 # overwritten to 5 Yellow # 6 (5 + 1) end Each constant in the enum has the type of the enum: Color :: Red # :: Color To get the underlying value you invoke value on it: Color :: Green . value # => 1 The type of the value is Int32 by default but can be changed: enum Color : UInt8 Red Green Blue end Color :: Red . value # :: UInt8 Only integer types are allowed as the underlying type. All enums inherit from Enum . Flags enums \u00b6 An enum can be marked with the @[Flags] annotation. This changes the default values: @[ Flags ] enum IOMode Read # 1 Write # 2 Async # 4 end The @[Flags] annotation makes the first constant's value be 1 , and successive constants are multiplied by 2 . Implicit constants, None and All , are automatically added to these enums, where None has the value 0 and All has the \"or\"ed value of all constants. IOMode :: None . value # => 0 IOMode :: All . value # => 7 Additionally, some Enum methods check the @[Flags] annotation. For example: puts ( Color :: Red ) # prints \"Red\" puts ( IOMode :: Write | IOMode :: Async ) # prints \"Write, Async\" Enums from integers \u00b6 An enum can be created from an integer: puts Color . new ( 1 ) # => prints \"Green\" Values that don't correspond to an enum's constants are allowed: the value will still be of type Color , but when printed you will get the underlying value: puts Color . new ( 10 ) # => prints \"10\" This method is mainly intended to convert integers from C to enums in Crystal. Methods \u00b6 Just like a class or a struct, you can define methods for enums: enum Color Red Green Blue def red? self == Color :: Red end end Color :: Red . red? # => true Color :: Blue . red? # => false Class variables are allowed, but instance variables are not. Usage \u00b6 Enums are a type-safe alternative to Symbol . For example, an API's method can specify a type restriction using an enum type: def paint ( color : Color ) case color when Color :: Red # ... else # Unusual, but still can happen raise \"unknown color: #{ color } \" end end paint Color :: Red The above could also be implemented with a Symbol: def paint ( color : Symbol ) case color when :red # ... else raise \"unknown color: #{ color } \" end end paint :red However, if the programmer makes a typo, say :reed , the error will only be caught at runtime, while attempting to use Color::Reed will result in a compile-time error. The recommended thing to do is to use enums whenever possible, only use symbols for the internal implementation of an API, and avoid symbols for public APIs. But you are free to do what you want.","title":"Enums"},{"location":"syntax_and_semantics/enum.html#enums","text":"An enum is a set of integer values, where each value has an associated name. For example: enum Color Red Green Blue end An enum is defined with the enum keyword, followed by its name. The enum's body contains the values. Values start with the value 0 and are incremented by one. The default value can be overwritten: enum Color Red # 0 Green # 1 Blue = 5 # overwritten to 5 Yellow # 6 (5 + 1) end Each constant in the enum has the type of the enum: Color :: Red # :: Color To get the underlying value you invoke value on it: Color :: Green . value # => 1 The type of the value is Int32 by default but can be changed: enum Color : UInt8 Red Green Blue end Color :: Red . value # :: UInt8 Only integer types are allowed as the underlying type. All enums inherit from Enum .","title":"Enums"},{"location":"syntax_and_semantics/enum.html#flags-enums","text":"An enum can be marked with the @[Flags] annotation. This changes the default values: @[ Flags ] enum IOMode Read # 1 Write # 2 Async # 4 end The @[Flags] annotation makes the first constant's value be 1 , and successive constants are multiplied by 2 . Implicit constants, None and All , are automatically added to these enums, where None has the value 0 and All has the \"or\"ed value of all constants. IOMode :: None . value # => 0 IOMode :: All . value # => 7 Additionally, some Enum methods check the @[Flags] annotation. For example: puts ( Color :: Red ) # prints \"Red\" puts ( IOMode :: Write | IOMode :: Async ) # prints \"Write, Async\"","title":"Flags enums"},{"location":"syntax_and_semantics/enum.html#enums-from-integers","text":"An enum can be created from an integer: puts Color . new ( 1 ) # => prints \"Green\" Values that don't correspond to an enum's constants are allowed: the value will still be of type Color , but when printed you will get the underlying value: puts Color . new ( 10 ) # => prints \"10\" This method is mainly intended to convert integers from C to enums in Crystal.","title":"Enums from integers"},{"location":"syntax_and_semantics/enum.html#methods","text":"Just like a class or a struct, you can define methods for enums: enum Color Red Green Blue def red? self == Color :: Red end end Color :: Red . red? # => true Color :: Blue . red? # => false Class variables are allowed, but instance variables are not.","title":"Methods"},{"location":"syntax_and_semantics/enum.html#usage","text":"Enums are a type-safe alternative to Symbol . For example, an API's method can specify a type restriction using an enum type: def paint ( color : Color ) case color when Color :: Red # ... else # Unusual, but still can happen raise \"unknown color: #{ color } \" end end paint Color :: Red The above could also be implemented with a Symbol: def paint ( color : Symbol ) case color when :red # ... else raise \"unknown color: #{ color } \" end end paint :red However, if the programmer makes a typo, say :reed , the error will only be caught at runtime, while attempting to use Color::Reed will result in a compile-time error. The recommended thing to do is to use enums whenever possible, only use symbols for the internal implementation of an API, and avoid symbols for public APIs. But you are free to do what you want.","title":"Usage"},{"location":"syntax_and_semantics/everything_is_an_object.html","text":"Everything is an object \u00b6 In Crystal everything is an object. The definition of an object boils down to these points: It has a type It can respond to some methods This is everything you can know about an object: its type and whether it responds to some method. An object's internal state, if any, can only be queried by invoking methods.","title":"Everything is an object"},{"location":"syntax_and_semantics/everything_is_an_object.html#everything-is-an-object","text":"In Crystal everything is an object. The definition of an object boils down to these points: It has a type It can respond to some methods This is everything you can know about an object: its type and whether it responds to some method. An object's internal state, if any, can only be queried by invoking methods.","title":"Everything is an object"},{"location":"syntax_and_semantics/exception_handling.html","text":"Exception handling \u00b6 Crystal's way to do error handling is by raising and rescuing exceptions. Raising exception \u00b6 You raise exceptions by invoking a top-level raise method. Unlike other keywords, raise is a regular method with two overloads: one accepting a String and another accepting an Exception instance : raise \"OH NO!\" raise Exception . new ( \"Some error\" ) The String version just creates a new Exception instance with that message. Only Exception instances or subclasses can be raised. Defining custom exceptions \u00b6 To define a custom exception type, just subclass from Exception : class MyException < Exception end class MyOtherException < Exception end You can, as always, define a constructor for your exception or just use the default one. Rescuing exceptions \u00b6 To rescue any exception use a begin ... rescue ... end expression: begin raise \"OH NO!\" rescue puts \"Rescued!\" end # Output: Rescued! To access the rescued exception you can specify a variable in the rescue clause: begin raise \"OH NO!\" rescue ex puts ex . message end # Output: OH NO! To rescue just one type of exception (or any of its subclasses): begin raise MyException . new ( \"OH NO!\" ) rescue MyException puts \"Rescued MyException\" end # Output: Rescued MyException And to access it, use a syntax similar to type restrictions: begin raise MyException . new ( \"OH NO!\" ) rescue ex : MyException puts \"Rescued MyException: #{ ex . message } \" end # Output: Rescued MyException: OH NO! Multiple rescue clauses can be specified: begin # ... rescue ex1 : MyException # only MyException... rescue ex2 : MyOtherException # only MyOtherException... rescue # any other kind of exception end You can also rescue multiple exception types at once by specifying a union type: begin # ... rescue ex : MyException | MyOtherException # only MyException or MyOtherException rescue # any other kind of exception end else \u00b6 An else clause is executed only if no exceptions were rescued: begin something_dangerous rescue # execute this if an exception is raised else # execute this if an exception isn't raised end An else clause can only be specified if at least one rescue clause is specified. ensure \u00b6 An ensure clause is executed at the end of a begin ... end or begin ... rescue ... end expression regardless of whether an exception was raised or not: begin something_dangerous ensure puts \"Cleanup...\" end # Will print \"Cleanup...\" after invoking something_dangerous, # regardless of whether it raised or not Or: begin something_dangerous rescue # ... else # ... ensure # this will always be executed end ensure clauses are usually used for clean up, freeing resources, etc. Short syntax form \u00b6 Exception handling has a short syntax form: assume a method or block definition is an implicit begin ... end expression, then specify rescue , else , and ensure clauses: def some_method something_dangerous rescue # execute if an exception is raised end # The above is the same as: def some_method begin something_dangerous rescue # execute if an exception is raised end end With ensure : def some_method something_dangerous ensure # always execute this end # The above is the same as: def some_method begin something_dangerous ensure # always execute this end end # Similarly, the shorthand also works with blocks: ( 1 .. 10 ) . each do | n | # potentially dangerous operation rescue # .. else # .. ensure # .. end Type inference \u00b6 Variables declared inside the begin part of an exception handler also get the Nil type when considered inside a rescue or ensure body. For example: begin a = something_dangerous_that_returns_Int32 ensure puts a + 1 # error, undefined method '+' for Nil end The above happens even if something_dangerous_that_returns_Int32 never raises, or if a was assigned a value and then a method that potentially raises is executed: begin a = 1 something_dangerous ensure puts a + 1 # error, undefined method '+' for Nil end Although it is obvious that a will always be assigned a value, the compiler will still think a might never had a chance to be initialized. Even though this logic might improve in the future, right now it forces you to keep your exception handlers to their necessary minimum, making the code's intention more clear: # Clearer than the above: `a` doesn't need # to be in the exception handling code. a = 1 begin something_dangerous ensure puts a + 1 # works end Alternative ways to do error handling \u00b6 Although exceptions are available as one of the mechanisms for handling errors, they are not your only choice. Raising an exception involves allocating memory, and executing an exception handler is generally slow. The standard library usually provides a couple of methods to accomplish something: one raises, one returns nil . For example: array = [ 1 , 2 , 3 ] array [ 4 ] # raises because of IndexError array [ 4 ]? # returns nil because of index out of bounds The usual convention is to provide an alternative \"question\" method to signal that this variant of the method returns nil instead of raising. This lets the user choose whether she wants to deal with exceptions or with nil . Note, however, that this is not available for every method out there, as exceptions are still the preferred way because they don't pollute the code with error handling logic.","title":"Exception handling"},{"location":"syntax_and_semantics/exception_handling.html#exception-handling","text":"Crystal's way to do error handling is by raising and rescuing exceptions.","title":"Exception handling"},{"location":"syntax_and_semantics/exception_handling.html#raising-exception","text":"You raise exceptions by invoking a top-level raise method. Unlike other keywords, raise is a regular method with two overloads: one accepting a String and another accepting an Exception instance : raise \"OH NO!\" raise Exception . new ( \"Some error\" ) The String version just creates a new Exception instance with that message. Only Exception instances or subclasses can be raised.","title":"Raising exception"},{"location":"syntax_and_semantics/exception_handling.html#defining-custom-exceptions","text":"To define a custom exception type, just subclass from Exception : class MyException < Exception end class MyOtherException < Exception end You can, as always, define a constructor for your exception or just use the default one.","title":"Defining custom exceptions"},{"location":"syntax_and_semantics/exception_handling.html#rescuing-exceptions","text":"To rescue any exception use a begin ... rescue ... end expression: begin raise \"OH NO!\" rescue puts \"Rescued!\" end # Output: Rescued! To access the rescued exception you can specify a variable in the rescue clause: begin raise \"OH NO!\" rescue ex puts ex . message end # Output: OH NO! To rescue just one type of exception (or any of its subclasses): begin raise MyException . new ( \"OH NO!\" ) rescue MyException puts \"Rescued MyException\" end # Output: Rescued MyException And to access it, use a syntax similar to type restrictions: begin raise MyException . new ( \"OH NO!\" ) rescue ex : MyException puts \"Rescued MyException: #{ ex . message } \" end # Output: Rescued MyException: OH NO! Multiple rescue clauses can be specified: begin # ... rescue ex1 : MyException # only MyException... rescue ex2 : MyOtherException # only MyOtherException... rescue # any other kind of exception end You can also rescue multiple exception types at once by specifying a union type: begin # ... rescue ex : MyException | MyOtherException # only MyException or MyOtherException rescue # any other kind of exception end","title":"Rescuing exceptions"},{"location":"syntax_and_semantics/exception_handling.html#else","text":"An else clause is executed only if no exceptions were rescued: begin something_dangerous rescue # execute this if an exception is raised else # execute this if an exception isn't raised end An else clause can only be specified if at least one rescue clause is specified.","title":"else"},{"location":"syntax_and_semantics/exception_handling.html#ensure","text":"An ensure clause is executed at the end of a begin ... end or begin ... rescue ... end expression regardless of whether an exception was raised or not: begin something_dangerous ensure puts \"Cleanup...\" end # Will print \"Cleanup...\" after invoking something_dangerous, # regardless of whether it raised or not Or: begin something_dangerous rescue # ... else # ... ensure # this will always be executed end ensure clauses are usually used for clean up, freeing resources, etc.","title":"ensure"},{"location":"syntax_and_semantics/exception_handling.html#short-syntax-form","text":"Exception handling has a short syntax form: assume a method or block definition is an implicit begin ... end expression, then specify rescue , else , and ensure clauses: def some_method something_dangerous rescue # execute if an exception is raised end # The above is the same as: def some_method begin something_dangerous rescue # execute if an exception is raised end end With ensure : def some_method something_dangerous ensure # always execute this end # The above is the same as: def some_method begin something_dangerous ensure # always execute this end end # Similarly, the shorthand also works with blocks: ( 1 .. 10 ) . each do | n | # potentially dangerous operation rescue # .. else # .. ensure # .. end","title":"Short syntax form"},{"location":"syntax_and_semantics/exception_handling.html#type-inference","text":"Variables declared inside the begin part of an exception handler also get the Nil type when considered inside a rescue or ensure body. For example: begin a = something_dangerous_that_returns_Int32 ensure puts a + 1 # error, undefined method '+' for Nil end The above happens even if something_dangerous_that_returns_Int32 never raises, or if a was assigned a value and then a method that potentially raises is executed: begin a = 1 something_dangerous ensure puts a + 1 # error, undefined method '+' for Nil end Although it is obvious that a will always be assigned a value, the compiler will still think a might never had a chance to be initialized. Even though this logic might improve in the future, right now it forces you to keep your exception handlers to their necessary minimum, making the code's intention more clear: # Clearer than the above: `a` doesn't need # to be in the exception handling code. a = 1 begin something_dangerous ensure puts a + 1 # works end","title":"Type inference"},{"location":"syntax_and_semantics/exception_handling.html#alternative-ways-to-do-error-handling","text":"Although exceptions are available as one of the mechanisms for handling errors, they are not your only choice. Raising an exception involves allocating memory, and executing an exception handler is generally slow. The standard library usually provides a couple of methods to accomplish something: one raises, one returns nil . For example: array = [ 1 , 2 , 3 ] array [ 4 ] # raises because of IndexError array [ 4 ]? # returns nil because of index out of bounds The usual convention is to provide an alternative \"question\" method to signal that this variant of the method returns nil instead of raising. This lets the user choose whether she wants to deal with exceptions or with nil . Note, however, that this is not available for every method out there, as exceptions are still the preferred way because they don't pollute the code with error handling logic.","title":"Alternative ways to do error handling"},{"location":"syntax_and_semantics/finalize.html","text":"finalize \u00b6 If a class defines a finalize method, when an instance of that class is garbage-collected that method will be invoked: class Foo def finalize # Invoked when Foo is garbage-collected # Use to release non-managed resources (ie. C libraries, structs) end end Use this method to release resources allocated by external libraries that are not directly managed by Crystal garbage collector. Examples of this can be found in IO::FileDescriptor#finalize or OpenSSL::Digest#finalize . Notes : The finalize method will only be invoked once the object has been fully initialized via the initialize method. If an exception is raised inside the initialize method, finalize won't be invoked. If your class defines a finalize method, be sure to catch any exceptions that might be raised in the initialize methods and free resources. Allocating any new object instances during garbage-collection might result in undefined behavior and most likely crashing your program.","title":"finalize"},{"location":"syntax_and_semantics/finalize.html#finalize","text":"If a class defines a finalize method, when an instance of that class is garbage-collected that method will be invoked: class Foo def finalize # Invoked when Foo is garbage-collected # Use to release non-managed resources (ie. C libraries, structs) end end Use this method to release resources allocated by external libraries that are not directly managed by Crystal garbage collector. Examples of this can be found in IO::FileDescriptor#finalize or OpenSSL::Digest#finalize . Notes : The finalize method will only be invoked once the object has been fully initialized via the initialize method. If an exception is raised inside the initialize method, finalize won't be invoked. If your class defines a finalize method, be sure to catch any exceptions that might be raised in the initialize methods and free resources. Allocating any new object instances during garbage-collection might result in undefined behavior and most likely crashing your program.","title":"finalize"},{"location":"syntax_and_semantics/generics.html","text":"Generics \u00b6 Generics allow you to parameterize a type based on other type. Consider a Box type: class MyBox ( T ) def initialize ( @value : T ) end def value @value end end int_box = MyBox ( Int32 ) . new ( 1 ) int_box . value # => 1 (Int32) string_box = MyBox ( String ) . new ( \"hello\" ) string_box . value # => \"hello\" (String) another_box = MyBox ( String ) . new ( 1 ) # Error, Int32 doesn't match String Generics are especially useful for implementing collection types. Array , Hash , Set are generic types, as is Pointer . More than one type parameter is allowed: class MyDictionary ( K , V ) end Any name can be used for type parameters: class MyDictionary ( KeyType , ValueType ) end Type variables inference \u00b6 Type restrictions in a generic type's constructor are free variables when type arguments were not specified, and then are used to infer them. For example: MyBox . new ( 1 ) # : MyBox(Int32) MyBox . new ( \"hello\" ) # : MyBox(String) In the above code we didn't have to specify the type arguments of MyBox , the compiler inferred them following this process: MyBox.new(value) delegates to initialize(@value : T) T isn't bound to a type yet, so the compiler binds it to the type of the given argument In this way generic types are less tedious to work with. Generic structs and modules \u00b6 Structs and modules can be generic too. When a module is generic you include it like this: module Moo ( T ) def t T end end class Foo ( U ) include Moo ( U ) def initialize ( @value : U ) end end foo = Foo . new ( 1 ) foo . t # Int32 Note that in the above example T becomes Int32 because Foo.new(1) makes U become Int32 , which in turn makes T become Int32 via the inclusion of the generic module. Generic types inheritance \u00b6 Generic classes and structs can be inherited. When inheriting you can specify an instance of the generic type, or delegate type variables: class Parent ( T ) end class Int32Child < Parent ( Int32 ) end class GenericChild ( T ) < Parent ( T ) end","title":"Generics"},{"location":"syntax_and_semantics/generics.html#generics","text":"Generics allow you to parameterize a type based on other type. Consider a Box type: class MyBox ( T ) def initialize ( @value : T ) end def value @value end end int_box = MyBox ( Int32 ) . new ( 1 ) int_box . value # => 1 (Int32) string_box = MyBox ( String ) . new ( \"hello\" ) string_box . value # => \"hello\" (String) another_box = MyBox ( String ) . new ( 1 ) # Error, Int32 doesn't match String Generics are especially useful for implementing collection types. Array , Hash , Set are generic types, as is Pointer . More than one type parameter is allowed: class MyDictionary ( K , V ) end Any name can be used for type parameters: class MyDictionary ( KeyType , ValueType ) end","title":"Generics"},{"location":"syntax_and_semantics/generics.html#type-variables-inference","text":"Type restrictions in a generic type's constructor are free variables when type arguments were not specified, and then are used to infer them. For example: MyBox . new ( 1 ) # : MyBox(Int32) MyBox . new ( \"hello\" ) # : MyBox(String) In the above code we didn't have to specify the type arguments of MyBox , the compiler inferred them following this process: MyBox.new(value) delegates to initialize(@value : T) T isn't bound to a type yet, so the compiler binds it to the type of the given argument In this way generic types are less tedious to work with.","title":"Type variables inference"},{"location":"syntax_and_semantics/generics.html#generic-structs-and-modules","text":"Structs and modules can be generic too. When a module is generic you include it like this: module Moo ( T ) def t T end end class Foo ( U ) include Moo ( U ) def initialize ( @value : U ) end end foo = Foo . new ( 1 ) foo . t # Int32 Note that in the above example T becomes Int32 because Foo.new(1) makes U become Int32 , which in turn makes T become Int32 via the inclusion of the generic module.","title":"Generic structs and modules"},{"location":"syntax_and_semantics/generics.html#generic-types-inheritance","text":"Generic classes and structs can be inherited. When inheriting you can specify an instance of the generic type, or delegate type variables: class Parent ( T ) end class Int32Child < Parent ( Int32 ) end class GenericChild ( T ) < Parent ( T ) end","title":"Generic types inheritance"},{"location":"syntax_and_semantics/if.html","text":"if \u00b6 An if evaluates the given branch if its condition is truthy . Otherwise, it evaluates the else branch if present. a = 1 if a > 0 a = 10 end a # => 10 b = 1 if b > 2 b = 10 else b = 20 end b # => 20 To write a chain of if-else-if you use elsif : if some_condition do_something elsif some_other_condition do_something_else else do_that end After an if , a variable\u2019s type depends on the type of the expressions used in both branches. a = 1 if some_condition a = \"hello\" else a = true end # a : String | Bool b = 1 if some_condition b = \"hello\" end # b : Int32 | String if some_condition c = 1 else c = \"hello\" end # c : Int32 | String if some_condition d = 1 end # d : Int32 | Nil Note that if a variable is declared inside one of the branches but not in the other one, at the end of the if it will also contain the Nil type. Inside an if 's branch the type of a variable is the one it got assigned in that branch, or the one that it had before the branch if it was not reassigned: a = 1 if some_condition a = \"hello\" # a : String a . size end # a : String | Int32 That is, a variable\u2019s type is the type of the last expression(s) assigned to it. If one of the branches never reaches past the end of an if , like in the case of a return , next , break or raise , that type is not considered at the end of the if : if some_condition e = 1 else e = \"hello\" # e : String return end # e : Int32","title":"if"},{"location":"syntax_and_semantics/if.html#if","text":"An if evaluates the given branch if its condition is truthy . Otherwise, it evaluates the else branch if present. a = 1 if a > 0 a = 10 end a # => 10 b = 1 if b > 2 b = 10 else b = 20 end b # => 20 To write a chain of if-else-if you use elsif : if some_condition do_something elsif some_other_condition do_something_else else do_that end After an if , a variable\u2019s type depends on the type of the expressions used in both branches. a = 1 if some_condition a = \"hello\" else a = true end # a : String | Bool b = 1 if some_condition b = \"hello\" end # b : Int32 | String if some_condition c = 1 else c = \"hello\" end # c : Int32 | String if some_condition d = 1 end # d : Int32 | Nil Note that if a variable is declared inside one of the branches but not in the other one, at the end of the if it will also contain the Nil type. Inside an if 's branch the type of a variable is the one it got assigned in that branch, or the one that it had before the branch if it was not reassigned: a = 1 if some_condition a = \"hello\" # a : String a . size end # a : String | Int32 That is, a variable\u2019s type is the type of the last expression(s) assigned to it. If one of the branches never reaches past the end of an if , like in the case of a return , next , break or raise , that type is not considered at the end of the if : if some_condition e = 1 else e = \"hello\" # e : String return end # e : Int32","title":"if"},{"location":"syntax_and_semantics/if_var.html","text":"if var \u00b6 If a variable is the condition of an if , inside the then branch the variable will be considered as not having the Nil type: a = some_condition ? nil : 3 # a is Int32 or Nil if a # Since the only way to get here is if a is truthy, # a can't be nil. So here a is Int32. a . abs end This also applies when a variable is assigned in an if 's condition: if a = some_expression # here a is not nil end This logic also applies if there are ands ( && ) in the condition: if a && b # here both a and b are guaranteed not to be Nil end Here, the right-hand side of the && expression is also guaranteed to have a as not Nil . Of course, reassigning a variable inside the then branch makes that variable have a new type based on the expression assigned. Limitations \u00b6 The above logic works only for local variables . It doesn\u2019t work with instance variables, class variables, or variables bound in a closure. The value of these kinds of variables could potentially be affected by another fiber after the condition was checked, rendering it nil . It also does not work with constants. if @a # here `@a` can be nil end if @@a # here `@@a` can be nil end a = nil closure = -> { a = \"foo\" } if a # here `a` can be nil end This can be circumvented by assigning the value to a new local variable: if a = @a # here `a` can't be nil end Another option is to use Object#try found in the standard library which only executes the block if the value is not nil : @a . try do | a | # here `a` can't be nil end Method calls \u00b6 That logic also doesn't work with proc and method calls, including getters and properties, because nilable (or, more generally, union-typed) procs and methods aren't guaranteed to return the same more-specific type on two successive calls. if method # first call to a method that can return Int32 or Nil # here we know that the first call did not return Nil method # second call can still return Int32 or Nil end The techniques described above for instance variables will also work for proc and method calls.","title":"if var"},{"location":"syntax_and_semantics/if_var.html#if-var","text":"If a variable is the condition of an if , inside the then branch the variable will be considered as not having the Nil type: a = some_condition ? nil : 3 # a is Int32 or Nil if a # Since the only way to get here is if a is truthy, # a can't be nil. So here a is Int32. a . abs end This also applies when a variable is assigned in an if 's condition: if a = some_expression # here a is not nil end This logic also applies if there are ands ( && ) in the condition: if a && b # here both a and b are guaranteed not to be Nil end Here, the right-hand side of the && expression is also guaranteed to have a as not Nil . Of course, reassigning a variable inside the then branch makes that variable have a new type based on the expression assigned.","title":"if var"},{"location":"syntax_and_semantics/if_var.html#limitations","text":"The above logic works only for local variables . It doesn\u2019t work with instance variables, class variables, or variables bound in a closure. The value of these kinds of variables could potentially be affected by another fiber after the condition was checked, rendering it nil . It also does not work with constants. if @a # here `@a` can be nil end if @@a # here `@@a` can be nil end a = nil closure = -> { a = \"foo\" } if a # here `a` can be nil end This can be circumvented by assigning the value to a new local variable: if a = @a # here `a` can't be nil end Another option is to use Object#try found in the standard library which only executes the block if the value is not nil : @a . try do | a | # here `a` can't be nil end","title":"Limitations"},{"location":"syntax_and_semantics/if_var.html#method-calls","text":"That logic also doesn't work with proc and method calls, including getters and properties, because nilable (or, more generally, union-typed) procs and methods aren't guaranteed to return the same more-specific type on two successive calls. if method # first call to a method that can return Int32 or Nil # here we know that the first call did not return Nil method # second call can still return Int32 or Nil end The techniques described above for instance variables will also work for proc and method calls.","title":"Method calls"},{"location":"syntax_and_semantics/if_var_nil.html","text":"if var.nil? \u00b6 If an if 's condition is var.nil? then the type of var in the then branch is known by the compiler to be Nil , and to be known as non- Nil in the else branch: a = some_condition ? nil : 3 if a .nil? # here a is Nil else # here a is Int32 end","title":"if var.nil?"},{"location":"syntax_and_semantics/if_var_nil.html#if-varnil","text":"If an if 's condition is var.nil? then the type of var in the then branch is known by the compiler to be Nil , and to be known as non- Nil in the else branch: a = some_condition ? nil : 3 if a .nil? # here a is Nil else # here a is Int32 end","title":"if var.nil?"},{"location":"syntax_and_semantics/if_varis_a.html","text":"if var.is_a?(...) \u00b6 If an if 's condition is an is_a? test, the type of a variable is guaranteed to be restricted by that type in the then branch. if a .is_a? ( String ) # here a is a String end if b .is_a? ( Number ) # here b is a Number end Additionally, in the else branch the type of the variable is guaranteed to not be restricted by that type: a = some_condition ? 1 : \"hello\" # a : Int32 | String if a .is_a? ( Number ) # a : Int32 else # a : String end Note that you can use any type as an is_a? test, like abstract classes and modules. The above also works if there are ands ( && ) in the condition: if a .is_a? ( String ) && b .is_a? ( Number ) # here a is a String and b is a Number end The above doesn\u2019t work with instance variables or class variables. To work with these, first assign them to a variable: if @a .is_a? ( String ) # here @a is not guaranteed to be a String end a = @a if a .is_a? ( String ) # here a is guaranteed to be a String end # A bit shorter: if ( a = @a ) .is_a? ( String ) # here a is guaranteed to be a String end","title":"if var.is_a?(...)"},{"location":"syntax_and_semantics/if_varis_a.html#if-varis_a","text":"If an if 's condition is an is_a? test, the type of a variable is guaranteed to be restricted by that type in the then branch. if a .is_a? ( String ) # here a is a String end if b .is_a? ( Number ) # here b is a Number end Additionally, in the else branch the type of the variable is guaranteed to not be restricted by that type: a = some_condition ? 1 : \"hello\" # a : Int32 | String if a .is_a? ( Number ) # a : Int32 else # a : String end Note that you can use any type as an is_a? test, like abstract classes and modules. The above also works if there are ands ( && ) in the condition: if a .is_a? ( String ) && b .is_a? ( Number ) # here a is a String and b is a Number end The above doesn\u2019t work with instance variables or class variables. To work with these, first assign them to a variable: if @a .is_a? ( String ) # here @a is not guaranteed to be a String end a = @a if a .is_a? ( String ) # here a is guaranteed to be a String end # A bit shorter: if ( a = @a ) .is_a? ( String ) # here a is guaranteed to be a String end","title":"if var.is_a?(...)"},{"location":"syntax_and_semantics/if_varresponds_to.html","text":"if var.responds_to?(...) \u00b6 If an if 's condition is a responds_to? test, in the then branch the type of a variable is guaranteed to be restricted to the types that respond to that method: if a .responds_to? ( :abs ) # here a's type will be reduced to those responding to the 'abs' method end Additionally, in the else branch the type of the variable is guaranteed to be restricted to the types that don\u2019t respond to that method: a = some_condition ? 1 : \"hello\" # a : Int32 | String if a .responds_to? ( :abs ) # here a will be Int32, since Int32#abs exists but String#abs doesn't else # here a will be String end The above doesn\u2019t work with instance variables or class variables. To work with these, first assign them to a variable: if @a .responds_to? ( :abs ) # here @a is not guaranteed to respond to `abs` end a = @a if a .responds_to? ( :abs ) # here a is guaranteed to respond to `abs` end # A bit shorter: if ( a = @a ) .responds_to? ( :abs ) # here a is guaranteed to respond to `abs` end","title":"if var.responds_to?(...)"},{"location":"syntax_and_semantics/if_varresponds_to.html#if-varresponds_to","text":"If an if 's condition is a responds_to? test, in the then branch the type of a variable is guaranteed to be restricted to the types that respond to that method: if a .responds_to? ( :abs ) # here a's type will be reduced to those responding to the 'abs' method end Additionally, in the else branch the type of the variable is guaranteed to be restricted to the types that don\u2019t respond to that method: a = some_condition ? 1 : \"hello\" # a : Int32 | String if a .responds_to? ( :abs ) # here a will be Int32, since Int32#abs exists but String#abs doesn't else # here a will be String end The above doesn\u2019t work with instance variables or class variables. To work with these, first assign them to a variable: if @a .responds_to? ( :abs ) # here @a is not guaranteed to respond to `abs` end a = @a if a .responds_to? ( :abs ) # here a is guaranteed to respond to `abs` end # A bit shorter: if ( a = @a ) .responds_to? ( :abs ) # here a is guaranteed to respond to `abs` end","title":"if var.responds_to?(...)"},{"location":"syntax_and_semantics/inheritance.html","text":"Inheritance \u00b6 Every class except Object , the hierarchy root, inherits from another class (its superclass). If you don't specify one it defaults to Reference for classes and Struct for structs. A class inherits all instance variables and all instance and class methods of a superclass, including its constructors ( new and initialize ). class Person def initialize ( @name : String ) end def greet puts \"Hi, I'm #{ @name } \" end end class Employee < Person end employee = Employee . new \"John\" employee . greet # \"Hi, I'm John\" If a class defines a new or initialize then its superclass constructors are not inherited: class Person def initialize ( @name : String ) end end class Employee < Person def initialize ( @name : String , @company_name : String ) end end Employee . new \"John\" , \"Acme\" # OK Employee . new \"Peter\" # Error: wrong number of arguments for 'Employee:Class#new' (1 for 2) You can override methods in a derived class: class Person def greet ( msg ) puts \"Hi, #{ msg } \" end end class Employee < Person def greet ( msg ) puts \"Hello, #{ msg } \" end end p = Person . new p . greet \"everyone\" # \"Hi, everyone\" e = Employee . new e . greet \"everyone\" # \"Hello, everyone\" Instead of overriding you can define specialized methods by using type restrictions: class Person def greet ( msg ) puts \"Hi, #{ msg } \" end end class Employee < Person def greet ( msg : Int32 ) puts \"Hi, this is a number: #{ msg } \" end end e = Employee . new e . greet \"everyone\" # \"Hi, everyone\" e . greet 1 # \"Hi, this is a number: 1\" super \u00b6 You can invoke a superclass' method using super : class Person def greet ( msg ) puts \"Hello, #{ msg } \" end end class Employee < Person def greet ( msg ) super # Same as: super(msg) super ( \"another message\" ) end end Without arguments or parentheses, super receives all of the method's parameters as arguments. Otherwise, it receives the arguments you pass to it. Covariance and Contravariance \u00b6 One place inheritance can get a little tricky is with arrays. We have to be careful when declaring an array of objects where inheritance is used. For example, consider the following class Foo end class Bar < Foo end foo_arr = [ Bar . new ] of Foo # => [#<Bar:0x10215bfe0>] : Array(Foo) bar_arr = [ Bar . new ] # => [#<Bar:0x10215bfd0>] : Array(Bar) bar_arr2 = [ Foo . new ] of Bar # compiler error A Foo array can hold both Foo's and Bar's, but an array of Bar can only hold Bar and its subclasses. One place this might trip you up is when automatic casting comes into play. For example, the following won't work: class Foo end class Bar < Foo end class Test @arr : Array ( Foo ) def initialize @arr = [ Bar . new ] end end we've declared @arr as type Array(Foo) so we may be tempted to think that we can start putting Bar s in there. Not quite. In the initialize , the type of the [Bar.new] expression is Array(Bar) , period. And Array(Bar) is not assignable to an Array(Foo) instance var. What's the right way to do this? Change the expression so that it is of the right type: Array(Foo) (see example above). class Foo end class Bar < Foo end class Test @arr : Array ( Foo ) def initialize @arr = [ Bar . new ] of Foo end end This is just one type (Array) and one operation (assignment), the logic of the above will be applied differently for other types and assignments, in general Covariance and Contravariance is not fully supported.","title":"Inheritance"},{"location":"syntax_and_semantics/inheritance.html#inheritance","text":"Every class except Object , the hierarchy root, inherits from another class (its superclass). If you don't specify one it defaults to Reference for classes and Struct for structs. A class inherits all instance variables and all instance and class methods of a superclass, including its constructors ( new and initialize ). class Person def initialize ( @name : String ) end def greet puts \"Hi, I'm #{ @name } \" end end class Employee < Person end employee = Employee . new \"John\" employee . greet # \"Hi, I'm John\" If a class defines a new or initialize then its superclass constructors are not inherited: class Person def initialize ( @name : String ) end end class Employee < Person def initialize ( @name : String , @company_name : String ) end end Employee . new \"John\" , \"Acme\" # OK Employee . new \"Peter\" # Error: wrong number of arguments for 'Employee:Class#new' (1 for 2) You can override methods in a derived class: class Person def greet ( msg ) puts \"Hi, #{ msg } \" end end class Employee < Person def greet ( msg ) puts \"Hello, #{ msg } \" end end p = Person . new p . greet \"everyone\" # \"Hi, everyone\" e = Employee . new e . greet \"everyone\" # \"Hello, everyone\" Instead of overriding you can define specialized methods by using type restrictions: class Person def greet ( msg ) puts \"Hi, #{ msg } \" end end class Employee < Person def greet ( msg : Int32 ) puts \"Hi, this is a number: #{ msg } \" end end e = Employee . new e . greet \"everyone\" # \"Hi, everyone\" e . greet 1 # \"Hi, this is a number: 1\"","title":"Inheritance"},{"location":"syntax_and_semantics/inheritance.html#super","text":"You can invoke a superclass' method using super : class Person def greet ( msg ) puts \"Hello, #{ msg } \" end end class Employee < Person def greet ( msg ) super # Same as: super(msg) super ( \"another message\" ) end end Without arguments or parentheses, super receives all of the method's parameters as arguments. Otherwise, it receives the arguments you pass to it.","title":"super"},{"location":"syntax_and_semantics/inheritance.html#covariance-and-contravariance","text":"One place inheritance can get a little tricky is with arrays. We have to be careful when declaring an array of objects where inheritance is used. For example, consider the following class Foo end class Bar < Foo end foo_arr = [ Bar . new ] of Foo # => [#<Bar:0x10215bfe0>] : Array(Foo) bar_arr = [ Bar . new ] # => [#<Bar:0x10215bfd0>] : Array(Bar) bar_arr2 = [ Foo . new ] of Bar # compiler error A Foo array can hold both Foo's and Bar's, but an array of Bar can only hold Bar and its subclasses. One place this might trip you up is when automatic casting comes into play. For example, the following won't work: class Foo end class Bar < Foo end class Test @arr : Array ( Foo ) def initialize @arr = [ Bar . new ] end end we've declared @arr as type Array(Foo) so we may be tempted to think that we can start putting Bar s in there. Not quite. In the initialize , the type of the [Bar.new] expression is Array(Bar) , period. And Array(Bar) is not assignable to an Array(Foo) instance var. What's the right way to do this? Change the expression so that it is of the right type: Array(Foo) (see example above). class Foo end class Bar < Foo end class Test @arr : Array ( Foo ) def initialize @arr = [ Bar . new ] of Foo end end This is just one type (Array) and one operation (assignment), the logic of the above will be applied differently for other types and assignments, in general Covariance and Contravariance is not fully supported.","title":"Covariance and Contravariance"},{"location":"syntax_and_semantics/instance_sizeof.html","text":"instance_sizeof \u00b6 The instance_sizeof expression returns an Int32 with the instance size of a given class. For example: class Point def initialize ( @x , @y ) end end Point . new 1 , 2 # 2 x Int32 = 2 x 4 = 8 instance_sizeof ( Point ) # => 12 Even though the instance has two Int32 fields, the compiler always includes an extra Int32 field for the type id of the object. That's why the instance size ends up being 12 and not 8.","title":"instance_sizeof"},{"location":"syntax_and_semantics/instance_sizeof.html#instance_sizeof","text":"The instance_sizeof expression returns an Int32 with the instance size of a given class. For example: class Point def initialize ( @x , @y ) end end Point . new 1 , 2 # 2 x Int32 = 2 x 4 = 8 instance_sizeof ( Point ) # => 12 Even though the instance has two Int32 fields, the compiler always includes an extra Int32 field for the type id of the object. That's why the instance size ends up being 12 and not 8.","title":"instance_sizeof"},{"location":"syntax_and_semantics/is_a.html","text":"is_a? \u00b6 The pseudo-method is_a? determines whether an expression's runtime type inherits or includes another type. For example: a = 1 a .is_a? ( Int32 ) # => true a .is_a? ( String ) # => false a .is_a? ( Number ) # => true a .is_a? ( Int32 | String ) # => true It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in if var.is_a?(...) . Also, it accepts a type that must be known at compile-time as its argument.","title":"is_a?"},{"location":"syntax_and_semantics/is_a.html#is_a","text":"The pseudo-method is_a? determines whether an expression's runtime type inherits or includes another type. For example: a = 1 a .is_a? ( Int32 ) # => true a .is_a? ( String ) # => false a .is_a? ( Number ) # => true a .is_a? ( Int32 | String ) # => true It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in if var.is_a?(...) . Also, it accepts a type that must be known at compile-time as its argument.","title":"is_a?"},{"location":"syntax_and_semantics/local_variables.html","text":"Local variables \u00b6 Local variables start with lowercase letters. They are declared when you first assign them a value. name = \"Crystal\" age = 1 Their type is inferred from their usage, not only from their initializer. In general, they are just value holders associated with the type that the programmer expects them to have according to their location and usage on the program. For example, reassigning a variable with a different expression makes it have that expression\u2019s type: flower = \"Tulip\" # At this point 'flower' is a String flower = 1 # At this point 'flower' is an Int32 Underscores are allowed at the beginning of a variable name, but these names are reserved for the compiler, so their use is not recommended (and it also makes the code uglier to read).","title":"Local variables"},{"location":"syntax_and_semantics/local_variables.html#local-variables","text":"Local variables start with lowercase letters. They are declared when you first assign them a value. name = \"Crystal\" age = 1 Their type is inferred from their usage, not only from their initializer. In general, they are just value holders associated with the type that the programmer expects them to have according to their location and usage on the program. For example, reassigning a variable with a different expression makes it have that expression\u2019s type: flower = \"Tulip\" # At this point 'flower' is a String flower = 1 # At this point 'flower' is an Int32 Underscores are allowed at the beginning of a variable name, but these names are reserved for the compiler, so their use is not recommended (and it also makes the code uglier to read).","title":"Local variables"},{"location":"syntax_and_semantics/low_level_primitives.html","text":"Low-level primitives \u00b6 Some low-level primitives are provided. They are mostly useful for interfacing with C libraries and for low-level code.","title":"Low-level primitives"},{"location":"syntax_and_semantics/low_level_primitives.html#low-level-primitives","text":"Some low-level primitives are provided. They are mostly useful for interfacing with C libraries and for low-level code.","title":"Low-level primitives"},{"location":"syntax_and_semantics/methods_and_instance_variables.html","text":"Methods and instance variables \u00b6 We can simplify our constructor by using a shorter syntax for assigning a method parameter to an instance variable: class Person def initialize ( @name : String ) @age = 0 end def age @age end end Right now, we can't do much with a person aside from create it with a name. Its age will always be zero. So lets add a method that makes a person become older: class Person def initialize ( @name : String ) @age = 0 end def age @age end def become_older @age += 1 end end john = Person . new \"John\" peter = Person . new \"Peter\" john . age # => 0 john . become_older john . age # => 1 peter . age # => 0 Method names begin with a lowercase letter and, as a convention, only use lowercase letters, underscores and numbers. Getters and setters \u00b6 The Crystal Standard Library provides macros which simplify the definition of getter and setter methods: class Person property age getter name : String def initialize ( @name ) @age = 0 end end john = Person . new \"John\" john . age = 32 john . age # => 32 For more information on getter and setter macros, see the standard library documentation for Object#getter , Object#setter , and Object#property . As a side note, we can define become_older inside the original Person definition, or in a separate definition: Crystal combines all definitions into a single class. The following works just fine: class Person def initialize ( @name : String ) @age = 0 end end class Person def become_older @age += 1 end end Redefining methods, and previous_def \u00b6 If you redefine a method, the last definition will take precedence. class Person def become_older @age += 1 end end class Person def become_older @age += 2 end end person = Person . new \"John\" person . become_older person . age # => 2 You can invoke the previously redefined method with previous_def : class Person def become_older @age += 1 end end class Person def become_older previous_def @age += 2 end end person = Person . new \"John\" person . become_older person . age # => 3 Without arguments or parentheses, previous_def receives all of the method's parameters as arguments. Otherwise, it receives the arguments you pass to it. Catch-all initialization \u00b6 Instance variables can also be initialized outside initialize methods: class Person @age = 0 def initialize ( @name : String ) end end This will initialize @age to zero in every constructor. This is useful to avoid duplication, but also to avoid the Nil type when reopening a class and adding instance variables to it.","title":"Methods and instance variables"},{"location":"syntax_and_semantics/methods_and_instance_variables.html#methods-and-instance-variables","text":"We can simplify our constructor by using a shorter syntax for assigning a method parameter to an instance variable: class Person def initialize ( @name : String ) @age = 0 end def age @age end end Right now, we can't do much with a person aside from create it with a name. Its age will always be zero. So lets add a method that makes a person become older: class Person def initialize ( @name : String ) @age = 0 end def age @age end def become_older @age += 1 end end john = Person . new \"John\" peter = Person . new \"Peter\" john . age # => 0 john . become_older john . age # => 1 peter . age # => 0 Method names begin with a lowercase letter and, as a convention, only use lowercase letters, underscores and numbers.","title":"Methods and instance variables"},{"location":"syntax_and_semantics/methods_and_instance_variables.html#getters-and-setters","text":"The Crystal Standard Library provides macros which simplify the definition of getter and setter methods: class Person property age getter name : String def initialize ( @name ) @age = 0 end end john = Person . new \"John\" john . age = 32 john . age # => 32 For more information on getter and setter macros, see the standard library documentation for Object#getter , Object#setter , and Object#property . As a side note, we can define become_older inside the original Person definition, or in a separate definition: Crystal combines all definitions into a single class. The following works just fine: class Person def initialize ( @name : String ) @age = 0 end end class Person def become_older @age += 1 end end","title":"Getters and setters"},{"location":"syntax_and_semantics/methods_and_instance_variables.html#redefining-methods-and-previous_def","text":"If you redefine a method, the last definition will take precedence. class Person def become_older @age += 1 end end class Person def become_older @age += 2 end end person = Person . new \"John\" person . become_older person . age # => 2 You can invoke the previously redefined method with previous_def : class Person def become_older @age += 1 end end class Person def become_older previous_def @age += 2 end end person = Person . new \"John\" person . become_older person . age # => 3 Without arguments or parentheses, previous_def receives all of the method's parameters as arguments. Otherwise, it receives the arguments you pass to it.","title":"Redefining methods, and previous_def"},{"location":"syntax_and_semantics/methods_and_instance_variables.html#catch-all-initialization","text":"Instance variables can also be initialized outside initialize methods: class Person @age = 0 def initialize ( @name : String ) end end This will initialize @age to zero in every constructor. This is useful to avoid duplication, but also to avoid the Nil type when reopening a class and adding instance variables to it.","title":"Catch-all initialization"},{"location":"syntax_and_semantics/modules.html","text":"Modules \u00b6 Modules serve two purposes: as namespaces for defining other types, methods and constants as partial types that can be mixed in other types An example of a module as a namespace: module Curses class Window end end Curses :: Window . new Library authors are advised to put their definitions inside a module to avoid name clashes. The standard library usually doesn't have a namespace as its types and methods are very common, to avoid writing long names. To use a module as a partial type you use include or extend . An include makes a type include methods defined in that module as instance methods: module ItemsSize def size items . size end end class Items include ItemsSize def items [ 1 , 2 , 3 ] end end items = Items . new items . size # => 3 In the above example, it is as if we pasted the size method from the module into the Items class. The way this really works is by making each type have a list of ancestors, or parents. By default this list starts with the superclass. As modules are included they are prepended to this list. When a method is not found in a type it is looked up in this list. When you invoke super , the first type in this ancestors list is used. A module can include other modules, so when a method is not found in it it will be looked up in the included modules. An extend makes a type include methods defined in that module as class methods: module SomeSize def size 3 end end class Items extend SomeSize end Items . size # => 3 Both include and extend make constants defined in the module available to the including/extending type. Both of them can be used at the top level to avoid writing a namespace over and over (although the chances of name clashes increase): module SomeModule class SomeType end def some_method 1 end end include SomeModule SomeType . new # OK, same as SomeModule::SomeType some_method # OK, 1 extend self \u00b6 A common pattern for modules is extend self : module Base64 extend self def encode64 ( string ) # ... end def decode64 ( string ) # ... end end In this way a module can be used as a namespace: Base64 . encode64 \"hello\" # => \"aGVsbG8=\" But also it can be included in the program and its methods can be invoked without a namespace: include Base64 encode64 \"hello\" # => \"aGVsbG8=\" For this to be useful the method name should have some reference to the module, otherwise chances of name clashes are high. A module cannot be instantiated: module Moo end Moo . new # undefined method 'new' for Moo:Module Module Type Checking \u00b6 Modules can also be used for type checking. If we define two modules with names A and B : module A ; end module B ; end These can be included into classes: class One include A end class Two include B end class Three < Two include A end We can then type check against instances of these classes with not only their class, but the included modules as well: one = One . new typeof ( one ) # => One one .is_a? ( A ) # => true one .is_a? ( B ) # => false three = Three . new typeof ( three ) # => Three three .is_a? ( A ) # => true three .is_a? ( B ) # => true This allows you to define arrays and methods based on module type instead of class: one = One . new two = Two . new three = Three . new new_array = Array ( A ) . new new_array << one # Ok, One inherits module A new_array << three # Ok, Three includes module A new_array << two # Error, because Two does not inherit module A","title":"Modules"},{"location":"syntax_and_semantics/modules.html#modules","text":"Modules serve two purposes: as namespaces for defining other types, methods and constants as partial types that can be mixed in other types An example of a module as a namespace: module Curses class Window end end Curses :: Window . new Library authors are advised to put their definitions inside a module to avoid name clashes. The standard library usually doesn't have a namespace as its types and methods are very common, to avoid writing long names. To use a module as a partial type you use include or extend . An include makes a type include methods defined in that module as instance methods: module ItemsSize def size items . size end end class Items include ItemsSize def items [ 1 , 2 , 3 ] end end items = Items . new items . size # => 3 In the above example, it is as if we pasted the size method from the module into the Items class. The way this really works is by making each type have a list of ancestors, or parents. By default this list starts with the superclass. As modules are included they are prepended to this list. When a method is not found in a type it is looked up in this list. When you invoke super , the first type in this ancestors list is used. A module can include other modules, so when a method is not found in it it will be looked up in the included modules. An extend makes a type include methods defined in that module as class methods: module SomeSize def size 3 end end class Items extend SomeSize end Items . size # => 3 Both include and extend make constants defined in the module available to the including/extending type. Both of them can be used at the top level to avoid writing a namespace over and over (although the chances of name clashes increase): module SomeModule class SomeType end def some_method 1 end end include SomeModule SomeType . new # OK, same as SomeModule::SomeType some_method # OK, 1","title":"Modules"},{"location":"syntax_and_semantics/modules.html#extend-self","text":"A common pattern for modules is extend self : module Base64 extend self def encode64 ( string ) # ... end def decode64 ( string ) # ... end end In this way a module can be used as a namespace: Base64 . encode64 \"hello\" # => \"aGVsbG8=\" But also it can be included in the program and its methods can be invoked without a namespace: include Base64 encode64 \"hello\" # => \"aGVsbG8=\" For this to be useful the method name should have some reference to the module, otherwise chances of name clashes are high. A module cannot be instantiated: module Moo end Moo . new # undefined method 'new' for Moo:Module","title":"extend self"},{"location":"syntax_and_semantics/modules.html#module-type-checking","text":"Modules can also be used for type checking. If we define two modules with names A and B : module A ; end module B ; end These can be included into classes: class One include A end class Two include B end class Three < Two include A end We can then type check against instances of these classes with not only their class, but the included modules as well: one = One . new typeof ( one ) # => One one .is_a? ( A ) # => true one .is_a? ( B ) # => false three = Three . new typeof ( three ) # => Three three .is_a? ( A ) # => true three .is_a? ( B ) # => true This allows you to define arrays and methods based on module type instead of class: one = One . new two = Two . new three = Three . new new_array = Array ( A ) . new new_array << one # Ok, One inherits module A new_array << three # Ok, Three includes module A new_array << two # Error, because Two does not inherit module A","title":"Module Type Checking"},{"location":"syntax_and_semantics/new%2C_initialize_and_allocate.html","text":"new, initialize and allocate \u00b6 You create an instance of a class by invoking new on that class: person = Person . new Here, person is an instance of Person . We can't do much with person , so let's add some concepts to it. A Person has a name and an age. In the \"Everything is an object\" section we said that an object has a type and responds to some methods, which is the only way to interact with objects, so we'll need both name and age methods. We will store this information in instance variables, which are always prefixed with an at ( @ ) character. We also want a Person to come into existence with a name of our choice and an age of zero. We code the \"come into existence\" part with a special initialize method, which is normally called a constructor : class Person def initialize ( name : String ) @name = name @age = 0 end def name @name end def age @age end end Now we can create people like this: john = Person . new \"John\" peter = Person . new \"Peter\" john . name # => \"John\" john . age # => 0 peter . name # => \"Peter\" (If you wonder why we needed to specify that name is a String but we didn't need to do it for age , check the global type inference algorithm ) Note that we create a Person with new but we defined the initialization in an initialize method, not in a new method. Why is this so? The answer is that when we defined an initialize method Crystal defined a new method for us, like this: class Person def self . new ( name : String ) instance = Person . allocate instance . initialize ( name ) instance end end First, note the self.new notation. This is a class method that belongs to the class Person , not to particular instances of that class. This is why we can do Person.new . Second, allocate is a low-level class method that creates an uninitialized object of the given type. It basically allocates the necessary memory for the object, then initialize is invoked on it and finally the instance is returned. You generally never invoke allocate , as it is unsafe , but that's the reason why new and initialize are related.","title":"new, initialize and allocate"},{"location":"syntax_and_semantics/new%2C_initialize_and_allocate.html#new-initialize-and-allocate","text":"You create an instance of a class by invoking new on that class: person = Person . new Here, person is an instance of Person . We can't do much with person , so let's add some concepts to it. A Person has a name and an age. In the \"Everything is an object\" section we said that an object has a type and responds to some methods, which is the only way to interact with objects, so we'll need both name and age methods. We will store this information in instance variables, which are always prefixed with an at ( @ ) character. We also want a Person to come into existence with a name of our choice and an age of zero. We code the \"come into existence\" part with a special initialize method, which is normally called a constructor : class Person def initialize ( name : String ) @name = name @age = 0 end def name @name end def age @age end end Now we can create people like this: john = Person . new \"John\" peter = Person . new \"Peter\" john . name # => \"John\" john . age # => 0 peter . name # => \"Peter\" (If you wonder why we needed to specify that name is a String but we didn't need to do it for age , check the global type inference algorithm ) Note that we create a Person with new but we defined the initialization in an initialize method, not in a new method. Why is this so? The answer is that when we defined an initialize method Crystal defined a new method for us, like this: class Person def self . new ( name : String ) instance = Person . allocate instance . initialize ( name ) instance end end First, note the self.new notation. This is a class method that belongs to the class Person , not to particular instances of that class. This is why we can do Person.new . Second, allocate is a low-level class method that creates an uninitialized object of the given type. It basically allocates the necessary memory for the object, then initialize is invoked on it and finally the instance is returned. You generally never invoke allocate , as it is unsafe , but that's the reason why new and initialize are related.","title":"new, initialize and allocate"},{"location":"syntax_and_semantics/next.html","text":"next \u00b6 You can use next to try to execute the next iteration of a while loop. After executing next , the while 's condition is checked and, if truthy , the body will be executed. a = 1 while a < 5 a += 1 if a == 3 next end puts a end # The above prints the numbers 2, 4 and 5 next can also be used to exit from a block, for example: def block yield end block do puts \"hello\" next puts \"world\" end # The above prints \"hello\" Similar to break , next can also take an argument which will then be returned by yield . def block puts yield end block do next \"hello\" end # The above prints \"hello\"","title":"next"},{"location":"syntax_and_semantics/next.html#next","text":"You can use next to try to execute the next iteration of a while loop. After executing next , the while 's condition is checked and, if truthy , the body will be executed. a = 1 while a < 5 a += 1 if a == 3 next end puts a end # The above prints the numbers 2, 4 and 5 next can also be used to exit from a block, for example: def block yield end block do puts \"hello\" next puts \"world\" end # The above prints \"hello\" Similar to break , next can also take an argument which will then be returned by yield . def block puts yield end block do next \"hello\" end # The above prints \"hello\"","title":"next"},{"location":"syntax_and_semantics/nil_question.html","text":"nil? \u00b6 The pseudo-method nil? determines whether an expression's runtime type is Nil . For example: a = 1 a .nil? # => false b = nil b .nil? # => true It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in if var.nil?(...) . It has the same effect as writing is_a?(Nil) but it's shorter and easier to read and write.","title":"nil?"},{"location":"syntax_and_semantics/nil_question.html#nil","text":"The pseudo-method nil? determines whether an expression's runtime type is Nil . For example: a = 1 a .nil? # => false b = nil b .nil? # => true It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in if var.nil?(...) . It has the same effect as writing is_a?(Nil) but it's shorter and easier to read and write.","title":"nil?"},{"location":"syntax_and_semantics/not.html","text":"if ! \u00b6 The ! operator returns a Bool that results from negating the truthiness of a value. When used in an if in conjunction with a variable, is_a? , responds_to? or nil? the compiler will restrict the types accordingly: a = some_condition ? nil : 3 if ! a # here a is Nil because a is falsey in this branch else # here a is Int32, because a is truthy in this branch end b = some_condition ? 1 : \"x\" if ! b .is_a? ( Int32 ) # here b is String because it's not an Int32 end","title":"if !"},{"location":"syntax_and_semantics/not.html#if","text":"The ! operator returns a Bool that results from negating the truthiness of a value. When used in an if in conjunction with a variable, is_a? , responds_to? or nil? the compiler will restrict the types accordingly: a = some_condition ? nil : 3 if ! a # here a is Nil because a is falsey in this branch else # here a is Int32, because a is truthy in this branch end b = some_condition ? 1 : \"x\" if ! b .is_a? ( Int32 ) # here b is String because it's not an Int32 end","title":"if !"},{"location":"syntax_and_semantics/offsetof.html","text":"offsetof \u00b6 An offsetof expression returns the byte offset of an instance variable in a struct or class type. It accepts the type as first argument and the instance variable name prefixed by an @ as second argument: offsetof ( Type , @ivar ) This is a low-level primitive and only useful if a C API needs to directly interface with the data layout of a Crystal type. Example: struct Foo @x = 0 _i64 @y = 34_i32 end offsetof ( Foo , @y ) # => 8","title":"offsetof"},{"location":"syntax_and_semantics/offsetof.html#offsetof","text":"An offsetof expression returns the byte offset of an instance variable in a struct or class type. It accepts the type as first argument and the instance variable name prefixed by an @ as second argument: offsetof ( Type , @ivar ) This is a low-level primitive and only useful if a C API needs to directly interface with the data layout of a Crystal type. Example: struct Foo @x = 0 _i64 @y = 34_i32 end offsetof ( Foo , @y ) # => 8","title":"offsetof"},{"location":"syntax_and_semantics/operators.html","text":"Operators \u00b6 Crystal supports a number of operators, with one, two or three operands. Operator expressions are actually parsed as method calls. For example a + b is semantically equivalent to a.+(b) , a call to method + on a with argument b . There are however some special rules regarding operator syntax: The dot ( . ) usually put between receiver and method name (i.e. the operator ) can be omitted. Chained sequences of operator calls are restructured by the compiler in order to implement operator precedence . Enforcing operator precedence makes sure that an expression such as 1 * 2 + 3 * 4 is parsed as (1 * 2) + (2 * 3) to honour regular math rules. Regular method names must start with a letter or underscore, but operators only consist of special characters. Any method not starting with a letter or underscore is an operator method. Available operators are whitelisted in the compiler (see List of Operators below) which allows symbol-only method names and treats them as operators, including their precedence rules. Operators are implemented like any regular method, and the standard library offers many implementations, for example for math expressions. Defining operator methods \u00b6 Most operators can be implemented as regular methods. One can assign any meaning to the operators, but it is advisable to stay within similar semantics to the generic operator meaning to avoid cryptic code that is confusing and behaves unexpectedly. A few operators are defined directly by the compiler and cannot be redefined in user code. Examples for this are the inversion operator ! , the assignment operator = , combined assignment operators such as ||= and range operators . Whether a method can be redefined is indicated by the colum Overloadable in the below operator tables. Unary operators \u00b6 Unary operators are written in prefix notation and have only a single operand. Thus, a method implementation receives no arguments and only operates on self . The following example demonstrates the Vector2 type as a two-dimensional vector with a unary operator method - for vector inversion. struct Vector2 getter x , y def initialize ( @x : Int32 , @y : Int32 ) end # Unary operator. Returns the inverted vector to `self`. def - : self Vector2 . new ( - x , - y ) end end v1 = Vector2 . new ( 1 , 2 ) - v1 # => Vector2(@x=-1, @y=-2) Binary operators \u00b6 Binary operators have two operands. Thus, a method implementation receives exactly one argument representing the second operand. The first operand is the receiver self . The following example demonstrates the Vector2 type as a two-dimensional vector with a binary operator method + for vector addition. struct Vector2 getter x , y def initialize ( @x : Int32 , @y : Int32 ) end # Binary operator. Returns *other* added to `self`. def + ( other : self ) : self Vector2 . new ( x + other . x , y + other . y ) end end v1 = Vector2 . new ( 1 , 2 ) v2 = Vector2 . new ( 3 , 4 ) v1 + v2 # => Vector2(@x=4, @y=6) Per convention, the return type of a binary operator should be the type of the first operand (the receiver), so that typeof(a <op> b) == typeof(a) . Otherwise the assignment operator ( a <op>= b ) would unintentionally change the type of a . There can be reasonable exceptions though. For example in the standard library the float division operator / on integer types always returns Float64 , because the quotient must not be limited to the value range of integers. Ternary operators \u00b6 The conditional operator ( ? : ) is the only ternary operator. It not parsed as a method, and its meaning cannot be changed. The compiler transforms it to an if expression. Operator Precedence \u00b6 This list is sorted by precedence, so upper entries bind stronger than lower ones. Category Operators Index accessors [] , []? Unary + , &+ , - , &- , ! , ~ , * , ** Exponential ** , &** Multiplicative * , &* , / , // , % Additive + , &+ , - , &- Shift << , >> Binary AND & Binary OR/XOR | , ^ Equality == , != , =~ , !~ , === Comparison < , <= , > , >= , <=> Logical AND && Logical OR || Range .. , ... Conditional ?: Assignment = , []= , += , &+= , -= , &-= , *= , &*= , /= , //= , %= , |= , &= , ^= , **= , <<= , >>= , ||= , &&= List of operators \u00b6 Arithmetic operators \u00b6 Unary \u00b6 Operator Description Example Overloadable + positive +1 yes &+ wrapping positive &+1 yes - negative -1 yes &- wrapping negative &-1 yes Multiplicative \u00b6 Operator Description Example Overloadable ** exponentiation 1 ** 2 yes &** wrapping exponentiation 1 &** 2 yes * multiplication 1 * 2 yes &* wrapping multiplication 1 &* 2 yes / division 1 / 2 yes // floor division 1 // 2 yes % modulus 1 % 2 yes Additive \u00b6 Operator Description Example Overloadable + addition 1 + 2 yes &+ wrapping addition 1 &+ 2 yes - subtraction 1 - 2 yes &- wrapping subtraction 1 &- 2 yes Other unary operators \u00b6 Operator Description Example Overloadable ! inversion !true no ~ binary complement ~1 yes Shifts \u00b6 Operator Description Example Overloadable << shift left, append 1 << 2 , STDOUT << \"foo\" yes >> shift right 1 >> 2 yes Binary \u00b6 Operator Description Example Overloadable & binary AND 1 & 2 yes | binary OR 1 | 2 yes ^ binary XOR 1 ^ 2 yes Equality \u00b6 Three base operators test equality: == : Checks whether the values of the operands are equal =~ : Checks whether the value of the first operand matches the value of the second operand with pattern matching. === : Checks whether the left hand operand matches the right hand operand in case equality . This operator is applied in case ... when conditions. The first two operators also have inversion operators ( != and !~ ) whose semantical intention is just the inverse of the base operator: a != b is supposed to be equivalent to !(a == b) and a !~ b to !(a =~ b) . Nevertheless, these inversions can be defined with a custom implementation. This can be useful for example to improve performance (non-equality can often be proven faster than equality). Operator Description Example Overloadable == equals 1 == 2 yes != not equals 1 != 2 yes =~ pattern match \"foo\" =~ /fo/ yes !~ no pattern match \"foo\" !~ /fo/ yes === case equality /foo/ === \"foo\" yes Comparison \u00b6 Operator Description Example Overloadable < less 1 < 2 yes <= less or equal 1 <= 2 yes > greater 1 > 2 yes >= greater or equal 1 >= 2 yes <=> comparison 1 <=> 2 yes Logical \u00b6 Operator Description Example Overloadable && logical AND true && false no || logical OR true || false no Range \u00b6 The range operators are used in Range literals. Operator Description Example Overloadable .. range 1..10 no ... exclusive range 1...10 no Splats \u00b6 Splat operators can only be used for destructing tuples in method arguments. See Splats and Tuples for details. Operator Description Example Overloadable * splat *foo no ** double splat **foo no Conditional \u00b6 The conditional operator ( ? : ) is internally rewritten to an if expression by the compiler. Operator Description Example Overloadable ? : conditional a == b ? c : d no Assignments \u00b6 The assignment operator = assigns the value of the second operand to the first operand. The first operand is either a variable (in this case the operator can't be redefined) or a call (in this case the operator can be redefined). See assignment for details. Operator Description Example Overloadable = variable assignment a = 1 no = call assignment a.b = 1 yes []= index assignment a[0] = 1 yes Combined assignments \u00b6 The assignment operator = is the basis for all operators that combine an operator with assignment. The general form is a <op>= b and the compiler transform that into a = a <op> b . Exceptions to the general expansion formula are the logical operators: a ||= b transforms to a || (a = b) a &&= b transforms to a && (a = b) There is another special case when a is an index accessor ( [] ), it is changed to the nilable variant ( []? on the right hand side: a[i] ||= b transforms to a[i] = (a[i]? || b) a[i] &&= b transforms to a[i] = (a[i]? && b) All transformations assume the receiver ( a ) is a variable. If it is a call, the replacements are semantically equivalent but the implementation is a bit more complex (introducing an anonymous temporary variable) and expects a= to be callable. The receiver can't be anything else than a variable or call. Operator Description Example Overloadable += addition and assignment i += 1 no &+= wrapping addition and assignment i &+= 1 no -= subtraction and assignment i -= 1 no &-= wrapping subtraction and assignment i &-= 1 no *= multiplication and assignment i *= 1 no &*= wrapping multiplication and assignment i &*= 1 no /= division and assignment i /= 1 no //= floor division and assignment i //= 1 no %= modulo and assignment i %= 1 yes |= binary or and assignment i |= 1 no &= binary and and assignment i &= 1 no ^= binary xor and assignment i ^= 1 no **= exponential and assignment i **= 1 no <<= left shift and assignment i <<= 1 no >>= right shift and assignment i >>= 1 no ||= logical or and assignment i ||= true no &&= logical and and assignment i &&= true no Index Accessors \u00b6 Index accessors are used to query a value by index or key, for example an array item or map entry. The nilable variant []? is supposed to return nil when the index is not found, while the non-nilable variant raises in that case. Implementations in the standard-library usually raise KeyError or IndexError . Operator Description Example Overloadable [] index accessor ary[i] yes []? nilable index accessor ary[i]? yes","title":"Operators"},{"location":"syntax_and_semantics/operators.html#operators","text":"Crystal supports a number of operators, with one, two or three operands. Operator expressions are actually parsed as method calls. For example a + b is semantically equivalent to a.+(b) , a call to method + on a with argument b . There are however some special rules regarding operator syntax: The dot ( . ) usually put between receiver and method name (i.e. the operator ) can be omitted. Chained sequences of operator calls are restructured by the compiler in order to implement operator precedence . Enforcing operator precedence makes sure that an expression such as 1 * 2 + 3 * 4 is parsed as (1 * 2) + (2 * 3) to honour regular math rules. Regular method names must start with a letter or underscore, but operators only consist of special characters. Any method not starting with a letter or underscore is an operator method. Available operators are whitelisted in the compiler (see List of Operators below) which allows symbol-only method names and treats them as operators, including their precedence rules. Operators are implemented like any regular method, and the standard library offers many implementations, for example for math expressions.","title":"Operators"},{"location":"syntax_and_semantics/operators.html#defining-operator-methods","text":"Most operators can be implemented as regular methods. One can assign any meaning to the operators, but it is advisable to stay within similar semantics to the generic operator meaning to avoid cryptic code that is confusing and behaves unexpectedly. A few operators are defined directly by the compiler and cannot be redefined in user code. Examples for this are the inversion operator ! , the assignment operator = , combined assignment operators such as ||= and range operators . Whether a method can be redefined is indicated by the colum Overloadable in the below operator tables.","title":"Defining operator methods"},{"location":"syntax_and_semantics/operators.html#unary-operators","text":"Unary operators are written in prefix notation and have only a single operand. Thus, a method implementation receives no arguments and only operates on self . The following example demonstrates the Vector2 type as a two-dimensional vector with a unary operator method - for vector inversion. struct Vector2 getter x , y def initialize ( @x : Int32 , @y : Int32 ) end # Unary operator. Returns the inverted vector to `self`. def - : self Vector2 . new ( - x , - y ) end end v1 = Vector2 . new ( 1 , 2 ) - v1 # => Vector2(@x=-1, @y=-2)","title":"Unary operators"},{"location":"syntax_and_semantics/operators.html#binary-operators","text":"Binary operators have two operands. Thus, a method implementation receives exactly one argument representing the second operand. The first operand is the receiver self . The following example demonstrates the Vector2 type as a two-dimensional vector with a binary operator method + for vector addition. struct Vector2 getter x , y def initialize ( @x : Int32 , @y : Int32 ) end # Binary operator. Returns *other* added to `self`. def + ( other : self ) : self Vector2 . new ( x + other . x , y + other . y ) end end v1 = Vector2 . new ( 1 , 2 ) v2 = Vector2 . new ( 3 , 4 ) v1 + v2 # => Vector2(@x=4, @y=6) Per convention, the return type of a binary operator should be the type of the first operand (the receiver), so that typeof(a <op> b) == typeof(a) . Otherwise the assignment operator ( a <op>= b ) would unintentionally change the type of a . There can be reasonable exceptions though. For example in the standard library the float division operator / on integer types always returns Float64 , because the quotient must not be limited to the value range of integers.","title":"Binary operators"},{"location":"syntax_and_semantics/operators.html#ternary-operators","text":"The conditional operator ( ? : ) is the only ternary operator. It not parsed as a method, and its meaning cannot be changed. The compiler transforms it to an if expression.","title":"Ternary operators"},{"location":"syntax_and_semantics/operators.html#operator-precedence","text":"This list is sorted by precedence, so upper entries bind stronger than lower ones. Category Operators Index accessors [] , []? Unary + , &+ , - , &- , ! , ~ , * , ** Exponential ** , &** Multiplicative * , &* , / , // , % Additive + , &+ , - , &- Shift << , >> Binary AND & Binary OR/XOR | , ^ Equality == , != , =~ , !~ , === Comparison < , <= , > , >= , <=> Logical AND && Logical OR || Range .. , ... Conditional ?: Assignment = , []= , += , &+= , -= , &-= , *= , &*= , /= , //= , %= , |= , &= , ^= , **= , <<= , >>= , ||= , &&=","title":"Operator Precedence"},{"location":"syntax_and_semantics/operators.html#list-of-operators","text":"","title":"List of operators"},{"location":"syntax_and_semantics/operators.html#arithmetic-operators","text":"","title":"Arithmetic operators"},{"location":"syntax_and_semantics/operators.html#unary","text":"Operator Description Example Overloadable + positive +1 yes &+ wrapping positive &+1 yes - negative -1 yes &- wrapping negative &-1 yes","title":"Unary"},{"location":"syntax_and_semantics/operators.html#multiplicative","text":"Operator Description Example Overloadable ** exponentiation 1 ** 2 yes &** wrapping exponentiation 1 &** 2 yes * multiplication 1 * 2 yes &* wrapping multiplication 1 &* 2 yes / division 1 / 2 yes // floor division 1 // 2 yes % modulus 1 % 2 yes","title":"Multiplicative"},{"location":"syntax_and_semantics/operators.html#additive","text":"Operator Description Example Overloadable + addition 1 + 2 yes &+ wrapping addition 1 &+ 2 yes - subtraction 1 - 2 yes &- wrapping subtraction 1 &- 2 yes","title":"Additive"},{"location":"syntax_and_semantics/operators.html#other-unary-operators","text":"Operator Description Example Overloadable ! inversion !true no ~ binary complement ~1 yes","title":"Other unary operators"},{"location":"syntax_and_semantics/operators.html#shifts","text":"Operator Description Example Overloadable << shift left, append 1 << 2 , STDOUT << \"foo\" yes >> shift right 1 >> 2 yes","title":"Shifts"},{"location":"syntax_and_semantics/operators.html#binary","text":"Operator Description Example Overloadable & binary AND 1 & 2 yes | binary OR 1 | 2 yes ^ binary XOR 1 ^ 2 yes","title":"Binary"},{"location":"syntax_and_semantics/operators.html#equality","text":"Three base operators test equality: == : Checks whether the values of the operands are equal =~ : Checks whether the value of the first operand matches the value of the second operand with pattern matching. === : Checks whether the left hand operand matches the right hand operand in case equality . This operator is applied in case ... when conditions. The first two operators also have inversion operators ( != and !~ ) whose semantical intention is just the inverse of the base operator: a != b is supposed to be equivalent to !(a == b) and a !~ b to !(a =~ b) . Nevertheless, these inversions can be defined with a custom implementation. This can be useful for example to improve performance (non-equality can often be proven faster than equality). Operator Description Example Overloadable == equals 1 == 2 yes != not equals 1 != 2 yes =~ pattern match \"foo\" =~ /fo/ yes !~ no pattern match \"foo\" !~ /fo/ yes === case equality /foo/ === \"foo\" yes","title":"Equality"},{"location":"syntax_and_semantics/operators.html#comparison","text":"Operator Description Example Overloadable < less 1 < 2 yes <= less or equal 1 <= 2 yes > greater 1 > 2 yes >= greater or equal 1 >= 2 yes <=> comparison 1 <=> 2 yes","title":"Comparison"},{"location":"syntax_and_semantics/operators.html#logical","text":"Operator Description Example Overloadable && logical AND true && false no || logical OR true || false no","title":"Logical"},{"location":"syntax_and_semantics/operators.html#range","text":"The range operators are used in Range literals. Operator Description Example Overloadable .. range 1..10 no ... exclusive range 1...10 no","title":"Range"},{"location":"syntax_and_semantics/operators.html#splats","text":"Splat operators can only be used for destructing tuples in method arguments. See Splats and Tuples for details. Operator Description Example Overloadable * splat *foo no ** double splat **foo no","title":"Splats"},{"location":"syntax_and_semantics/operators.html#conditional","text":"The conditional operator ( ? : ) is internally rewritten to an if expression by the compiler. Operator Description Example Overloadable ? : conditional a == b ? c : d no","title":"Conditional"},{"location":"syntax_and_semantics/operators.html#assignments","text":"The assignment operator = assigns the value of the second operand to the first operand. The first operand is either a variable (in this case the operator can't be redefined) or a call (in this case the operator can be redefined). See assignment for details. Operator Description Example Overloadable = variable assignment a = 1 no = call assignment a.b = 1 yes []= index assignment a[0] = 1 yes","title":"Assignments"},{"location":"syntax_and_semantics/operators.html#combined-assignments","text":"The assignment operator = is the basis for all operators that combine an operator with assignment. The general form is a <op>= b and the compiler transform that into a = a <op> b . Exceptions to the general expansion formula are the logical operators: a ||= b transforms to a || (a = b) a &&= b transforms to a && (a = b) There is another special case when a is an index accessor ( [] ), it is changed to the nilable variant ( []? on the right hand side: a[i] ||= b transforms to a[i] = (a[i]? || b) a[i] &&= b transforms to a[i] = (a[i]? && b) All transformations assume the receiver ( a ) is a variable. If it is a call, the replacements are semantically equivalent but the implementation is a bit more complex (introducing an anonymous temporary variable) and expects a= to be callable. The receiver can't be anything else than a variable or call. Operator Description Example Overloadable += addition and assignment i += 1 no &+= wrapping addition and assignment i &+= 1 no -= subtraction and assignment i -= 1 no &-= wrapping subtraction and assignment i &-= 1 no *= multiplication and assignment i *= 1 no &*= wrapping multiplication and assignment i &*= 1 no /= division and assignment i /= 1 no //= floor division and assignment i //= 1 no %= modulo and assignment i %= 1 yes |= binary or and assignment i |= 1 no &= binary and and assignment i &= 1 no ^= binary xor and assignment i ^= 1 no **= exponential and assignment i **= 1 no <<= left shift and assignment i <<= 1 no >>= right shift and assignment i >>= 1 no ||= logical or and assignment i ||= true no &&= logical and and assignment i &&= true no","title":"Combined assignments"},{"location":"syntax_and_semantics/operators.html#index-accessors","text":"Index accessors are used to query a value by index or key, for example an array item or map entry. The nilable variant []? is supposed to return nil when the index is not found, while the non-nilable variant raises in that case. Implementations in the standard-library usually raise KeyError or IndexError . Operator Description Example Overloadable [] index accessor ary[i] yes []? nilable index accessor ary[i]? yes","title":"Index Accessors"},{"location":"syntax_and_semantics/or.html","text":"|| - Logical OR Operator \u00b6 An || (or) evaluates its left hand side. If it's falsey , it evaluates its right hand side and has that value. Otherwise it has the value of the left hand side. Its type is the union of the types of both sides. You can think an || as syntax sugar of an if : some_exp1 || some_exp2 # The above is the same as: tmp = some_exp1 if tmp tmp else some_exp2 end","title":"||"},{"location":"syntax_and_semantics/or.html#-logical-or-operator","text":"An || (or) evaluates its left hand side. If it's falsey , it evaluates its right hand side and has that value. Otherwise it has the value of the left hand side. Its type is the union of the types of both sides. You can think an || as syntax sugar of an if : some_exp1 || some_exp2 # The above is the same as: tmp = some_exp1 if tmp tmp else some_exp2 end","title":"|| - Logical OR Operator"},{"location":"syntax_and_semantics/overloading.html","text":"Overloading \u00b6 We can define a become_older method that accepts a number indicating the years to grow: class Person getter :age def initialize ( @name : String , @age : Int = 0 ) end def become_older @age += 1 end def become_older ( years ) @age += years end end john = Person . new \"John\" john . age # => 0 john . become_older john . age # => 1 john . become_older 5 john . age # => 6 That is, you can have different methods with the same name and different number of parameters and they will be considered as separate methods. This is called method overloading . Methods overload by several criteria: The number of parameters The type restrictions applied to parameters The names of required named parameters Whether the method accepts a block or not For example, we can define four different become_older methods: class Person @age = 0 # Increases age by one def become_older @age += 1 end # Increases age by the given number of years def become_older ( years : Int32 ) @age += years end # Increases age by the given number of years, as a String def become_older ( years : String ) @age += years . to_i end # Yields the current age of this person and increases # its age by the value returned by the block def become_older @age += yield @age end end person = Person . new \"John\" person . become_older person . age # => 1 person . become_older 5 person . age # => 6 person . become_older \"12\" person . age # => 18 person . become_older do | current_age | current_age < 20 ? 10 : 30 end person . age # => 28 Note that in the case of the method that yields, the compiler figured this out because there's a yield expression. To make this more explicit, you can add a dummy &block parameter at the end: class Person @age = 0 def become_older ( & block ) @age += yield @age end end In generated documentation the dummy &block method will always appear, regardless of you writing it or not. Given the same number of parameters, the compiler will try to sort them by leaving the less restrictive ones to the end: class Person @age = 0 # First, this method is defined def become_older ( age ) @age += age end # Since \"String\" is more restrictive than no restriction # at all, the compiler puts this method before the previous # one when considering which overload matches. def become_older ( age : String ) @age += age . to_i end end person = Person . new \"John\" # Invokes the first definition person . become_older 20 # Invokes the second definition person . become_older \"12\" However, the compiler cannot always figure out the order because there isn't always a total ordering, so it's always better to put less restrictive methods at the end.","title":"Overloading"},{"location":"syntax_and_semantics/overloading.html#overloading","text":"We can define a become_older method that accepts a number indicating the years to grow: class Person getter :age def initialize ( @name : String , @age : Int = 0 ) end def become_older @age += 1 end def become_older ( years ) @age += years end end john = Person . new \"John\" john . age # => 0 john . become_older john . age # => 1 john . become_older 5 john . age # => 6 That is, you can have different methods with the same name and different number of parameters and they will be considered as separate methods. This is called method overloading . Methods overload by several criteria: The number of parameters The type restrictions applied to parameters The names of required named parameters Whether the method accepts a block or not For example, we can define four different become_older methods: class Person @age = 0 # Increases age by one def become_older @age += 1 end # Increases age by the given number of years def become_older ( years : Int32 ) @age += years end # Increases age by the given number of years, as a String def become_older ( years : String ) @age += years . to_i end # Yields the current age of this person and increases # its age by the value returned by the block def become_older @age += yield @age end end person = Person . new \"John\" person . become_older person . age # => 1 person . become_older 5 person . age # => 6 person . become_older \"12\" person . age # => 18 person . become_older do | current_age | current_age < 20 ? 10 : 30 end person . age # => 28 Note that in the case of the method that yields, the compiler figured this out because there's a yield expression. To make this more explicit, you can add a dummy &block parameter at the end: class Person @age = 0 def become_older ( & block ) @age += yield @age end end In generated documentation the dummy &block method will always appear, regardless of you writing it or not. Given the same number of parameters, the compiler will try to sort them by leaving the less restrictive ones to the end: class Person @age = 0 # First, this method is defined def become_older ( age ) @age += age end # Since \"String\" is more restrictive than no restriction # at all, the compiler puts this method before the previous # one when considering which overload matches. def become_older ( age : String ) @age += age . to_i end end person = Person . new \"John\" # Invokes the first definition person . become_older 20 # Invokes the second definition person . become_older \"12\" However, the compiler cannot always figure out the order because there isn't always a total ordering, so it's always better to put less restrictive methods at the end.","title":"Overloading"},{"location":"syntax_and_semantics/pointerof.html","text":"pointerof \u00b6 The pointerof expression returns a Pointer that points to the contents of a variable or instance variable. An example with a variable: a = 1 ptr = pointerof ( a ) ptr . value = 2 a # => 2 An example with an instance variable: class Point def initialize ( @x : Int32 , @y : Int32 ) end def x @x end def x_ptr pointerof ( @x ) end end point = Point . new 1 , 2 ptr = point . x_ptr ptr . value = 10 point . x # => 10 Because pointerof involves pointers, it is considered unsafe .","title":"pointerof"},{"location":"syntax_and_semantics/pointerof.html#pointerof","text":"The pointerof expression returns a Pointer that points to the contents of a variable or instance variable. An example with a variable: a = 1 ptr = pointerof ( a ) ptr . value = 2 a # => 2 An example with an instance variable: class Point def initialize ( @x : Int32 , @y : Int32 ) end def x @x end def x_ptr pointerof ( @x ) end end point = Point . new 1 , 2 ptr = point . x_ptr ptr . value = 10 point . x # => 10 Because pointerof involves pointers, it is considered unsafe .","title":"pointerof"},{"location":"syntax_and_semantics/proc_literal.html","text":"Proc literal \u00b6 A captured block is the same as declaring a Proc literal and passing it to the method. def some_proc ( & block : Int32 -> Int32 ) block end x = 0 proc = -> ( i : Int32 ) { x += i } proc = some_proc ( & proc ) proc . call ( 1 ) # => 1 proc . call ( 10 ) # => 11 x # => 11 As explained in the proc literals section, a Proc can also be created from existing methods: def add ( x , y ) x + y end adder = -> add ( Int32 , Int32 ) adder . call ( 1 , 2 ) # => 3","title":"Proc literal"},{"location":"syntax_and_semantics/proc_literal.html#proc-literal","text":"A captured block is the same as declaring a Proc literal and passing it to the method. def some_proc ( & block : Int32 -> Int32 ) block end x = 0 proc = -> ( i : Int32 ) { x += i } proc = some_proc ( & proc ) proc . call ( 1 ) # => 1 proc . call ( 10 ) # => 11 x # => 11 As explained in the proc literals section, a Proc can also be created from existing methods: def add ( x , y ) x + y end adder = -> add ( Int32 , Int32 ) adder . call ( 1 , 2 ) # => 3","title":"Proc literal"},{"location":"syntax_and_semantics/requiring_files.html","text":"Requiring files \u00b6 Writing a program in a single file is OK for little snippets and small benchmark code. Big programs are better maintained and understood when split across different files. To make the compiler process other files you use require \"...\" . It accepts a single argument, a string literal, and it can come in many flavors. Once a file is required, the compiler remembers its absolute path and later require s of that same file will be ignored. require \"filename\" \u00b6 This looks up \"filename\" in the require path. By default the require path is the location of the standard library that comes with the compiler, and the \"lib\" directory relative to the current working directory (given by pwd in a Unix shell). These are the only places that are looked up. The lookup goes like this: If a file named \"filename.cr\" is found in the require path, it is required. If a directory named \"filename\" is found and it contains a file named \"filename.cr\" directly underneath it, it is required. If a directory named \"filename\" is found with a directory \"src\" in it and it contains a file named \"filename.cr\" directly underneath it, it is required. If a directory named \"filename\" is found with a directory \"src\" in it and it contains a directory named \"filename\" directly underneath it with a \"filename.cr\" file inside it, it is required. Otherwise a compile-time error is issued. The second rule means that in addition to having this: - project - src - file - sub1.cr - sub2.cr - file.cr (requires \"./file/*\") you can have it like this: - project - src - file - file.cr (requires \"./*\") - sub1.cr - sub2.cr which might be a bit cleaner depending on your taste. The third rule is very convenient because of the typical directory structure of a project: - project - lib - foo - src - foo.cr - bar - src - bar.cr - src - project.cr - spec - project_spec.cr That is, inside \"lib/{project}\" each project's directory exists ( src , spec , README.md and so on) For example, if you put require \"foo\" in project.cr and run crystal src/project.cr in the project's root directory, it will find foo in lib/foo/foo.cr . The fourth rule is the second rule applied to the third rule. If you run the compiler from somewhere else, say the src folder, lib will not be in the path and require \"foo\" can't be resolved. require \"./filename\" \u00b6 This looks up \"filename\" relative to the file containing the require expression. The lookup goes like this: If a file named \"filename.cr\" is found relative to the current file, it is required. If a directory named \"filename\" is found and it contains a file named \"filename.cr\" directly underneath it, it is required. Otherwise a compile-time error is issued. This relative is mostly used inside a project to refer to other files inside it. It is also used to refer to code from specs : # in spec/project_spec.cr require \"../src/project\" Other forms \u00b6 In both cases you can use nested names and they will be looked up in nested directories: require \"foo/bar/baz\" will lookup \"foo/bar/baz.cr\", \"foo/bar/baz/baz.cr\", \"foo/src/bar/baz.cr\" or \"foo/src/bar/baz/baz.cr\" in the require path. require \"./foo/bar/baz\" will lookup \"foo/bar/baz.cr\" or \"foo/bar/baz/baz.cr\" relative to the current file. You can also use \"../\" to access parent directories relative to the current file, so require \"../../foo/bar\" works as well. In all of these cases you can use the special * and ** suffixes: require \"foo/*\" will require all \".cr\" files below the \"foo\" directory, but not below directories inside \"foo\". require \"foo/**\" will require all \".cr\" files below the \"foo\" directory, and below directories inside \"foo\", recursively.","title":"Requiring files"},{"location":"syntax_and_semantics/requiring_files.html#requiring-files","text":"Writing a program in a single file is OK for little snippets and small benchmark code. Big programs are better maintained and understood when split across different files. To make the compiler process other files you use require \"...\" . It accepts a single argument, a string literal, and it can come in many flavors. Once a file is required, the compiler remembers its absolute path and later require s of that same file will be ignored.","title":"Requiring files"},{"location":"syntax_and_semantics/requiring_files.html#require-filename","text":"This looks up \"filename\" in the require path. By default the require path is the location of the standard library that comes with the compiler, and the \"lib\" directory relative to the current working directory (given by pwd in a Unix shell). These are the only places that are looked up. The lookup goes like this: If a file named \"filename.cr\" is found in the require path, it is required. If a directory named \"filename\" is found and it contains a file named \"filename.cr\" directly underneath it, it is required. If a directory named \"filename\" is found with a directory \"src\" in it and it contains a file named \"filename.cr\" directly underneath it, it is required. If a directory named \"filename\" is found with a directory \"src\" in it and it contains a directory named \"filename\" directly underneath it with a \"filename.cr\" file inside it, it is required. Otherwise a compile-time error is issued. The second rule means that in addition to having this: - project - src - file - sub1.cr - sub2.cr - file.cr (requires \"./file/*\") you can have it like this: - project - src - file - file.cr (requires \"./*\") - sub1.cr - sub2.cr which might be a bit cleaner depending on your taste. The third rule is very convenient because of the typical directory structure of a project: - project - lib - foo - src - foo.cr - bar - src - bar.cr - src - project.cr - spec - project_spec.cr That is, inside \"lib/{project}\" each project's directory exists ( src , spec , README.md and so on) For example, if you put require \"foo\" in project.cr and run crystal src/project.cr in the project's root directory, it will find foo in lib/foo/foo.cr . The fourth rule is the second rule applied to the third rule. If you run the compiler from somewhere else, say the src folder, lib will not be in the path and require \"foo\" can't be resolved.","title":"require \"filename\""},{"location":"syntax_and_semantics/requiring_files.html#require-filename_1","text":"This looks up \"filename\" relative to the file containing the require expression. The lookup goes like this: If a file named \"filename.cr\" is found relative to the current file, it is required. If a directory named \"filename\" is found and it contains a file named \"filename.cr\" directly underneath it, it is required. Otherwise a compile-time error is issued. This relative is mostly used inside a project to refer to other files inside it. It is also used to refer to code from specs : # in spec/project_spec.cr require \"../src/project\"","title":"require \"./filename\""},{"location":"syntax_and_semantics/requiring_files.html#other-forms","text":"In both cases you can use nested names and they will be looked up in nested directories: require \"foo/bar/baz\" will lookup \"foo/bar/baz.cr\", \"foo/bar/baz/baz.cr\", \"foo/src/bar/baz.cr\" or \"foo/src/bar/baz/baz.cr\" in the require path. require \"./foo/bar/baz\" will lookup \"foo/bar/baz.cr\" or \"foo/bar/baz/baz.cr\" relative to the current file. You can also use \"../\" to access parent directories relative to the current file, so require \"../../foo/bar\" works as well. In all of these cases you can use the special * and ** suffixes: require \"foo/*\" will require all \".cr\" files below the \"foo\" directory, but not below directories inside \"foo\". require \"foo/**\" will require all \".cr\" files below the \"foo\" directory, and below directories inside \"foo\", recursively.","title":"Other forms"},{"location":"syntax_and_semantics/responds_to.html","text":"responds_to? \u00b6 The pseudo-method responds_to? determines whether a type has a method with the given name. For example: a = 1 a .responds_to? ( :abs ) # => true a .responds_to? ( :size ) # => false It is a pseudo-method because it only accepts a symbol literal as its argument, and is also treated specially by the compiler, as explained in if var.responds_to?(...) .","title":"responds_to?"},{"location":"syntax_and_semantics/responds_to.html#responds_to","text":"The pseudo-method responds_to? determines whether a type has a method with the given name. For example: a = 1 a .responds_to? ( :abs ) # => true a .responds_to? ( :size ) # => false It is a pseudo-method because it only accepts a symbol literal as its argument, and is also treated specially by the compiler, as explained in if var.responds_to?(...) .","title":"responds_to?"},{"location":"syntax_and_semantics/return_types.html","text":"Return types \u00b6 A method's return type is always inferred by the compiler. However, you might want to specify it for two reasons: To make sure that the method returns the type that you want To make it appear in documentation comments For example: def some_method : String \"hello\" end The return type follows the type grammar . Nil return type \u00b6 Marking a method as returning Nil will make it return nil regardless of what it actually returns: def some_method : Nil 1 + 2 end some_method # => nil This is useful for two reasons: Making sure a method returns nil without needing to add an extra nil at the end, or at every return point Documenting that the method's return value is of no interest These methods usually imply a side effect. Using Void is the same, but Nil is more idiomatic: Void is preferred in C bindings. NoReturn return type \u00b6 Some expressions won't return to the current scope and therefore have no return type. This is expressed as the special return type NoReturn . Typical examples for non-returning methods and keywords are return , exit , raise , next , and break . This is for example useful for deconstructing union types: string = STDIN . gets typeof ( string ) # => String? typeof ( raise \"Empty input\" ) # => NoReturn typeof ( string || raise \"Empty input\" ) # => String The compiler recognizes that in case string is Nil , the right hand side of the expression string || raise will be evaluated. Since typeof(raise \"Empty input\") is NoReturn the execution would not return to the current scope in that case. That leaves only String as resulting type of the expression. Every expression whose code paths all result in NoReturn will be NoReturn as well. NoReturn does not show up in a union type because it would essentially be included in every expression's type. It is only used when an expression will never return to the current scope. NoReturn can be explicitly set as return type of a method or function definition but will usually be inferred by the compiler.","title":"Return types"},{"location":"syntax_and_semantics/return_types.html#return-types","text":"A method's return type is always inferred by the compiler. However, you might want to specify it for two reasons: To make sure that the method returns the type that you want To make it appear in documentation comments For example: def some_method : String \"hello\" end The return type follows the type grammar .","title":"Return types"},{"location":"syntax_and_semantics/return_types.html#nil-return-type","text":"Marking a method as returning Nil will make it return nil regardless of what it actually returns: def some_method : Nil 1 + 2 end some_method # => nil This is useful for two reasons: Making sure a method returns nil without needing to add an extra nil at the end, or at every return point Documenting that the method's return value is of no interest These methods usually imply a side effect. Using Void is the same, but Nil is more idiomatic: Void is preferred in C bindings.","title":"Nil return type"},{"location":"syntax_and_semantics/return_types.html#noreturn-return-type","text":"Some expressions won't return to the current scope and therefore have no return type. This is expressed as the special return type NoReturn . Typical examples for non-returning methods and keywords are return , exit , raise , next , and break . This is for example useful for deconstructing union types: string = STDIN . gets typeof ( string ) # => String? typeof ( raise \"Empty input\" ) # => NoReturn typeof ( string || raise \"Empty input\" ) # => String The compiler recognizes that in case string is Nil , the right hand side of the expression string || raise will be evaluated. Since typeof(raise \"Empty input\") is NoReturn the execution would not return to the current scope in that case. That leaves only String as resulting type of the expression. Every expression whose code paths all result in NoReturn will be NoReturn as well. NoReturn does not show up in a union type because it would essentially be included in every expression's type. It is only used when an expression will never return to the current scope. NoReturn can be explicitly set as return type of a method or function definition but will usually be inferred by the compiler.","title":"NoReturn return type"},{"location":"syntax_and_semantics/sizeof.html","text":"sizeof \u00b6 The sizeof expression returns an Int32 with the size in bytes of a given type. For example: sizeof ( Int32 ) # => 4 sizeof ( Int64 ) # => 8 For Reference types, the size is the same as the size of a pointer: # On a 64 bits machine sizeof ( Pointer ( Int32 )) # => 8 sizeof ( String ) # => 8 This is because a Reference's memory is allocated on the heap and a pointer to it is passed around. To get the effective size of a class, use instance_sizeof . The argument to sizeof is a type and is often combined with typeof : a = 1 sizeof ( typeof ( a )) # => 4","title":"sizeof"},{"location":"syntax_and_semantics/sizeof.html#sizeof","text":"The sizeof expression returns an Int32 with the size in bytes of a given type. For example: sizeof ( Int32 ) # => 4 sizeof ( Int64 ) # => 8 For Reference types, the size is the same as the size of a pointer: # On a 64 bits machine sizeof ( Pointer ( Int32 )) # => 8 sizeof ( String ) # => 8 This is because a Reference's memory is allocated on the heap and a pointer to it is passed around. To get the effective size of a class, use instance_sizeof . The argument to sizeof is a type and is often combined with typeof : a = 1 sizeof ( typeof ( a )) # => 4","title":"sizeof"},{"location":"syntax_and_semantics/splats_and_tuples.html","text":"Splats and tuples \u00b6 A method can receive a variable number of arguments by using a splat parameter ( * ), which can appear only once and in any position: def sum ( * elements ) total = 0 elements . each do | value | total += value end total end sum 1 , 2 , 3 # => 6 sum 1 , 2 , 3 , 4.5 # => 10.5 The passed arguments become a Tuple in the method's body: # elements is Tuple(Int32, Int32, Int32) sum 1 , 2 , 3 # elements is Tuple(Int32, Int32, Int32, Float64) sum 1 , 2 , 3 , 4.5 Arguments past the splat parameter can only be passed as named arguments: def sum ( * elements , initial = 0 ) total = initial elements . each do | value | total += value end total end sum 1 , 2 , 3 # => 6 sum 1 , 2 , 3 , initial : 10 # => 16 Parameters past the splat parameter without a default value are required named parameters: def sum ( * elements , initial ) total = initial elements . each do | value | total += value end total end sum 1 , 2 , 3 # Error, missing argument: initial sum 1 , 2 , 3 , initial : 10 # => 16 Two methods with different required named parameters overload between each other: def foo ( * elements , x ) 1 end def foo ( * elements , y ) 2 end foo x : \"something\" # => 1 foo y : \"something\" # => 2 The splat parameter can also be left unnamed, with the meaning \"after this, named parameters follow\": def foo ( x , y , * , z ) end foo 1 , 2 , 3 # Error, wrong number of arguments (given 3, expected 2) foo 1 , 2 # Error, missing argument: z foo 1 , 2 , z : 3 # OK Splatting a tuple \u00b6 A Tuple can be splat into a method call by using * : def foo ( x , y ) x + y end tuple = { 1 , 2 } foo * tuple # => 3 Double splats and named tuples \u00b6 A double splat ( ** ) captures named arguments that were not matched by other parameters. The type of the parameter is a NamedTuple : def foo ( x , ** other ) # Return the captured named arguments as a NamedTuple other end foo 1 , y : 2 , z : 3 # => {y: 2, z: 3} foo y : 2 , x : 1 , z : 3 # => {y: 2, z: 3} Double splatting a named tuple \u00b6 A NamedTuple can be splat into a method call by using ** : def foo ( x , y ) x - y end tuple = { y : 3 , x : 10 } foo ** tuple # => 7","title":"Splats and tuples"},{"location":"syntax_and_semantics/splats_and_tuples.html#splats-and-tuples","text":"A method can receive a variable number of arguments by using a splat parameter ( * ), which can appear only once and in any position: def sum ( * elements ) total = 0 elements . each do | value | total += value end total end sum 1 , 2 , 3 # => 6 sum 1 , 2 , 3 , 4.5 # => 10.5 The passed arguments become a Tuple in the method's body: # elements is Tuple(Int32, Int32, Int32) sum 1 , 2 , 3 # elements is Tuple(Int32, Int32, Int32, Float64) sum 1 , 2 , 3 , 4.5 Arguments past the splat parameter can only be passed as named arguments: def sum ( * elements , initial = 0 ) total = initial elements . each do | value | total += value end total end sum 1 , 2 , 3 # => 6 sum 1 , 2 , 3 , initial : 10 # => 16 Parameters past the splat parameter without a default value are required named parameters: def sum ( * elements , initial ) total = initial elements . each do | value | total += value end total end sum 1 , 2 , 3 # Error, missing argument: initial sum 1 , 2 , 3 , initial : 10 # => 16 Two methods with different required named parameters overload between each other: def foo ( * elements , x ) 1 end def foo ( * elements , y ) 2 end foo x : \"something\" # => 1 foo y : \"something\" # => 2 The splat parameter can also be left unnamed, with the meaning \"after this, named parameters follow\": def foo ( x , y , * , z ) end foo 1 , 2 , 3 # Error, wrong number of arguments (given 3, expected 2) foo 1 , 2 # Error, missing argument: z foo 1 , 2 , z : 3 # OK","title":"Splats and tuples"},{"location":"syntax_and_semantics/splats_and_tuples.html#splatting-a-tuple","text":"A Tuple can be splat into a method call by using * : def foo ( x , y ) x + y end tuple = { 1 , 2 } foo * tuple # => 3","title":"Splatting a tuple"},{"location":"syntax_and_semantics/splats_and_tuples.html#double-splats-and-named-tuples","text":"A double splat ( ** ) captures named arguments that were not matched by other parameters. The type of the parameter is a NamedTuple : def foo ( x , ** other ) # Return the captured named arguments as a NamedTuple other end foo 1 , y : 2 , z : 3 # => {y: 2, z: 3} foo y : 2 , x : 1 , z : 3 # => {y: 2, z: 3}","title":"Double splats and named tuples"},{"location":"syntax_and_semantics/splats_and_tuples.html#double-splatting-a-named-tuple","text":"A NamedTuple can be splat into a method call by using ** : def foo ( x , y ) x - y end tuple = { y : 3 , x : 10 } foo ** tuple # => 7","title":"Double splatting a named tuple"},{"location":"syntax_and_semantics/structs.html","text":"Structs \u00b6 Instead of defining a type with class you can do so with struct : struct Point property x , y def initialize ( @x : Int32 , @y : Int32 ) end end Structs inherit from Value so they are allocated on the stack and passed by value: when passed to methods, returned from methods or assigned to variables, a copy of the value is actually passed (while classes inherit from Reference , are allocated on the heap and passed by reference). Therefore structs are mostly useful for immutable data types and/or stateless wrappers of other types, usually for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient (for more details, see the performance guide ). Mutable structs are still allowed, but you should be careful when writing code involving mutability if you want to avoid surprises that are described below. Passing by value \u00b6 A struct is always passed by value, even when you return self from the method of that struct: struct Counter def initialize ( @count : Int32 ) end def plus @count += 1 self end end counter = Counter . new ( 0 ) counter . plus . plus # => Counter(@x=2) puts counter # => Counter(@x=1) Notice that the chained calls of plus return the expected result, but only the first call to it modifies the variable counter , as the second call operates on the copy of the struct passed to it from the first call, and this copy is discarded after the expression is executed. You should also be careful when working on mutable types inside of the struct: class Klass property array = [ \"str\" ] end struct Strukt property array = [ \"str\" ] end def modify ( object ) object . array << \"foo\" object . array = [ \"new\" ] object . array << \"bar\" end klass = Klass . new puts modify ( klass ) # => [\"new\", \"bar\"] puts klass . array # => [\"new\", \"bar\"] strukt = Strukt . new puts modify ( strukt ) # => [\"new\", \"bar\"] puts strukt . array # => [\"str\", \"foo\"] What happens with the strukt here: Array is passed by reference, so the reference to [\"str\"] is stored in the property of strukt when strukt is passed to modify , a copy of the strukt is passed with the reference to array inside it the array referenced by array is modified (element inside it is added) by object.array << \"foo\" this is also reflected in the original strukt as it holds reference to the same array object.array = [\"new\"] replaces the reference in the copy of strukt with the reference to the new array object.array << \"bar\" appends to this newly created array modify returns the reference to this new array and its content is printed the reference to this new array was held only in the copy of strukt , but not in the original, so that's why the original strukt only retained the result of the first statement, but not of the other two statements Klass is a class, so it is passed by reference to modify , and object.array = [\"new\"] saves the reference to the newly created array in the original klass object, not in the copy as it was with the strukt . Inheritance \u00b6 A struct implicitly inherits from Struct , which inherits from Value . A class implicitly inherits from Reference . A struct cannot inherit from a non-abstract struct. The second point has a reason to it: a struct has a very well defined memory layout. For example, the above Point struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer: # The array's buffer will have 8 bytes dedicated to each Point ary = [] of Point If Point is inherited, an array of such type should also account for the fact that other types can be inside it, so the size of each element should grow to accommodate that. That is certainly unexpected. So, non-abstract structs can't be inherited from. Abstract structs, on the other hand, will have descendants, so it is expected that an array of them will account for the possibility of having multiple types inside it. A struct can also include modules and can be generic, just like a class.","title":"Structs"},{"location":"syntax_and_semantics/structs.html#structs","text":"Instead of defining a type with class you can do so with struct : struct Point property x , y def initialize ( @x : Int32 , @y : Int32 ) end end Structs inherit from Value so they are allocated on the stack and passed by value: when passed to methods, returned from methods or assigned to variables, a copy of the value is actually passed (while classes inherit from Reference , are allocated on the heap and passed by reference). Therefore structs are mostly useful for immutable data types and/or stateless wrappers of other types, usually for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient (for more details, see the performance guide ). Mutable structs are still allowed, but you should be careful when writing code involving mutability if you want to avoid surprises that are described below.","title":"Structs"},{"location":"syntax_and_semantics/structs.html#passing-by-value","text":"A struct is always passed by value, even when you return self from the method of that struct: struct Counter def initialize ( @count : Int32 ) end def plus @count += 1 self end end counter = Counter . new ( 0 ) counter . plus . plus # => Counter(@x=2) puts counter # => Counter(@x=1) Notice that the chained calls of plus return the expected result, but only the first call to it modifies the variable counter , as the second call operates on the copy of the struct passed to it from the first call, and this copy is discarded after the expression is executed. You should also be careful when working on mutable types inside of the struct: class Klass property array = [ \"str\" ] end struct Strukt property array = [ \"str\" ] end def modify ( object ) object . array << \"foo\" object . array = [ \"new\" ] object . array << \"bar\" end klass = Klass . new puts modify ( klass ) # => [\"new\", \"bar\"] puts klass . array # => [\"new\", \"bar\"] strukt = Strukt . new puts modify ( strukt ) # => [\"new\", \"bar\"] puts strukt . array # => [\"str\", \"foo\"] What happens with the strukt here: Array is passed by reference, so the reference to [\"str\"] is stored in the property of strukt when strukt is passed to modify , a copy of the strukt is passed with the reference to array inside it the array referenced by array is modified (element inside it is added) by object.array << \"foo\" this is also reflected in the original strukt as it holds reference to the same array object.array = [\"new\"] replaces the reference in the copy of strukt with the reference to the new array object.array << \"bar\" appends to this newly created array modify returns the reference to this new array and its content is printed the reference to this new array was held only in the copy of strukt , but not in the original, so that's why the original strukt only retained the result of the first statement, but not of the other two statements Klass is a class, so it is passed by reference to modify , and object.array = [\"new\"] saves the reference to the newly created array in the original klass object, not in the copy as it was with the strukt .","title":"Passing by value"},{"location":"syntax_and_semantics/structs.html#inheritance","text":"A struct implicitly inherits from Struct , which inherits from Value . A class implicitly inherits from Reference . A struct cannot inherit from a non-abstract struct. The second point has a reason to it: a struct has a very well defined memory layout. For example, the above Point struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer: # The array's buffer will have 8 bytes dedicated to each Point ary = [] of Point If Point is inherited, an array of such type should also account for the fact that other types can be inside it, so the size of each element should grow to accommodate that. That is certainly unexpected. So, non-abstract structs can't be inherited from. Abstract structs, on the other hand, will have descendants, so it is expected that an array of them will account for the possibility of having multiple types inside it. A struct can also include modules and can be generic, just like a class.","title":"Inheritance"},{"location":"syntax_and_semantics/ternary_if.html","text":"Ternary if \u00b6 The ternary if allows writing an if in a shorter way: a = 1 > 2 ? 3 : 4 # The above is the same as: a = if 1 > 2 3 else 4 end","title":"Ternary if"},{"location":"syntax_and_semantics/ternary_if.html#ternary-if","text":"The ternary if allows writing an if in a shorter way: a = 1 > 2 ? 3 : 4 # The above is the same as: a = if 1 > 2 3 else 4 end","title":"Ternary if"},{"location":"syntax_and_semantics/the_program.html","text":"The Program \u00b6 The program is a global object in which you can define types, methods and file-local variables. # Defines a method in the program def add ( x , y ) x + y end # Invokes the add method in the program add ( 1 , 2 ) # => 3 A method's value is the value of its last expression; there's no need for explicit return expressions. However, explicit return expressions are possible: def even? ( num ) if num % 2 == 0 return true end return false end When invoking a method without a receiver, like add(1, 2) , it will be searched for in the program if not found in the current type or any of its ancestors. def add ( x , y ) x + y end class Foo def bar # invokes the program's add method add ( 1 , 2 ) # invokes Foo's baz method baz ( 1 , 2 ) end def baz ( x , y ) x * y end end If you want to invoke the program's method, even though the current type defines a method with the same name, prefix the call with :: : def baz ( x , y ) x + y end class Foo def bar baz ( 4 , 2 ) # => 2 :: baz ( 4 , 2 ) # => 6 end def baz ( x , y ) x - y end end Variables declared in a program are not visible inside methods: x = 1 def add ( y ) x + y # error: undefined local variable or method 'x' end add ( 2 ) Parentheses in method invocations are optional: add 1 , 2 # same as add(1, 2) Main code \u00b6 Main code, the code that is run when you compile and run a program, can be written directly in a source file without the need to put it in a special \"main\" method: # This is a program that prints \"Hello Crystal!\" puts \"Hello Crystal!\" Main code can also be inside type declarations: # This is a program that prints \"Hello\" class Hello # 'self' here is the Hello class puts self end","title":"The Program"},{"location":"syntax_and_semantics/the_program.html#the-program","text":"The program is a global object in which you can define types, methods and file-local variables. # Defines a method in the program def add ( x , y ) x + y end # Invokes the add method in the program add ( 1 , 2 ) # => 3 A method's value is the value of its last expression; there's no need for explicit return expressions. However, explicit return expressions are possible: def even? ( num ) if num % 2 == 0 return true end return false end When invoking a method without a receiver, like add(1, 2) , it will be searched for in the program if not found in the current type or any of its ancestors. def add ( x , y ) x + y end class Foo def bar # invokes the program's add method add ( 1 , 2 ) # invokes Foo's baz method baz ( 1 , 2 ) end def baz ( x , y ) x * y end end If you want to invoke the program's method, even though the current type defines a method with the same name, prefix the call with :: : def baz ( x , y ) x + y end class Foo def bar baz ( 4 , 2 ) # => 2 :: baz ( 4 , 2 ) # => 6 end def baz ( x , y ) x - y end end Variables declared in a program are not visible inside methods: x = 1 def add ( y ) x + y # error: undefined local variable or method 'x' end add ( 2 ) Parentheses in method invocations are optional: add 1 , 2 # same as add(1, 2)","title":"The Program"},{"location":"syntax_and_semantics/the_program.html#main-code","text":"Main code, the code that is run when you compile and run a program, can be written directly in a source file without the need to put it in a special \"main\" method: # This is a program that prints \"Hello Crystal!\" puts \"Hello Crystal!\" Main code can also be inside type declarations: # This is a program that prints \"Hello\" class Hello # 'self' here is the Hello class puts self end","title":"Main code"},{"location":"syntax_and_semantics/truthy_and_falsey_values.html","text":"Truthy and falsey values \u00b6 A truthy value is a value that is considered true for an if , unless , while or until guard. A falsey value is a value that is considered false in those places. The only falsey values are nil , false and null pointers (pointers whose memory address is zero). Any other value is truthy.","title":"Truthy and falsey values"},{"location":"syntax_and_semantics/truthy_and_falsey_values.html#truthy-and-falsey-values","text":"A truthy value is a value that is considered true for an if , unless , while or until guard. A falsey value is a value that is considered false in those places. The only falsey values are nil , false and null pointers (pointers whose memory address is zero). Any other value is truthy.","title":"Truthy and falsey values"},{"location":"syntax_and_semantics/type_grammar.html","text":"Type grammar \u00b6 When: specifying type restrictions specifying type arguments declaring variables declaring aliases declaring typedefs the argument of an is_a? pseudo-call the argument of an as expression the argument of a sizeof expression the argument of an instance_sizeof expression a method's return type a convenient syntax is provided for some common types. These are especially useful when writing C bindings , but can be used in any of the above locations. Paths and generics \u00b6 Regular types and generics can be used: Int32 My :: Nested :: Type Array ( String ) Union \u00b6 alias Int32OrString = Int32 | String The pipe ( | ) in types creates a union type. Int32 | String is read \"Int32 or String\". In regular code, Int32 | String means invoking the method | on Int32 with String as an argument. Nilable \u00b6 alias Int32OrNil = Int32? is the same as: alias Int32OrNil = Int32 | :: Nil In regular code, Int32? is an Int32 | ::Nil union type itself. Pointer \u00b6 alias Int32Ptr = Int32 * is the same as: alias Int32Ptr = Pointer ( Int32 ) In regular code, Int32* means invoking the * method on Int32 . StaticArray \u00b6 alias Int32_8 = Int32 [ 8 ] is the same as: alias Int32_8 = StaticArray ( Int32 , 8 ) In regular code, Int32[8] means invoking the [] method on Int32 with 8 as an argument. Tuple \u00b6 alias Int32StringTuple = { Int32 , String } is the same as: alias Int32StringTuple = Tuple ( Int32 , String ) In regular code, {Int32, String} is a tuple instance containing Int32 and String as its elements. This is different than the above tuple type . NamedTuple \u00b6 alias Int32StringNamedTuple = { x : Int32 , y : String } is the same as: alias Int32StringNamedTuple = NamedTuple ( x : Int32 , y : String ) In regular code, {x: Int32, y: String} is a named tuple instance containing Int32 and String for x and y . This is different than the above named tuple type . Proc \u00b6 alias Int32ToString = Int32 -> String is the same as: alias Int32ToString = Proc ( Int32 , String ) To specify a Proc without parameters: alias ProcThatReturnsInt32 = -> Int32 To specify multiple parameters: alias Int32AndCharToString = Int32 , Char -> String For nested procs (and any type, in general), you can use parentheses: alias ComplexProc = ( Int32 -> Int32 ) -> String In regular code Int32 -> String is a syntax error. self \u00b6 self can be used in the type grammar to denote a self type. Refer to the type restrictions section. class \u00b6 class is used to refer to a class type, instead of an instance type. For example: def foo ( x : Int32 ) \"instance\" end def foo ( x : Int32 . class ) \"class\" end foo 1 # \"instance\" foo Int32 # \"class\" class is also useful for creating arrays and collections of class type: class Parent end class Child1 < Parent end class Child2 < Parent end ary = [] of Parent . class ary << Child1 ary << Child2 Underscore \u00b6 An underscore is allowed in type restrictions. It matches anything: # Same as not specifying a restriction, not very useful def foo ( x : _ ) end # A bit more useful: any two-parameter Proc that returns an Int32: def foo ( x : _ , _ -> Int32 ) end typeof \u00b6 typeof is allowed in the type grammar. It returns a union type of the type of the passed expressions: typeof ( 1 + 2 ) # => Int32 typeof ( 1 , \"a\" ) # => (Int32 | String)","title":"Type grammar"},{"location":"syntax_and_semantics/type_grammar.html#type-grammar","text":"When: specifying type restrictions specifying type arguments declaring variables declaring aliases declaring typedefs the argument of an is_a? pseudo-call the argument of an as expression the argument of a sizeof expression the argument of an instance_sizeof expression a method's return type a convenient syntax is provided for some common types. These are especially useful when writing C bindings , but can be used in any of the above locations.","title":"Type grammar"},{"location":"syntax_and_semantics/type_grammar.html#paths-and-generics","text":"Regular types and generics can be used: Int32 My :: Nested :: Type Array ( String )","title":"Paths and generics"},{"location":"syntax_and_semantics/type_grammar.html#union","text":"alias Int32OrString = Int32 | String The pipe ( | ) in types creates a union type. Int32 | String is read \"Int32 or String\". In regular code, Int32 | String means invoking the method | on Int32 with String as an argument.","title":"Union"},{"location":"syntax_and_semantics/type_grammar.html#nilable","text":"alias Int32OrNil = Int32? is the same as: alias Int32OrNil = Int32 | :: Nil In regular code, Int32? is an Int32 | ::Nil union type itself.","title":"Nilable"},{"location":"syntax_and_semantics/type_grammar.html#pointer","text":"alias Int32Ptr = Int32 * is the same as: alias Int32Ptr = Pointer ( Int32 ) In regular code, Int32* means invoking the * method on Int32 .","title":"Pointer"},{"location":"syntax_and_semantics/type_grammar.html#staticarray","text":"alias Int32_8 = Int32 [ 8 ] is the same as: alias Int32_8 = StaticArray ( Int32 , 8 ) In regular code, Int32[8] means invoking the [] method on Int32 with 8 as an argument.","title":"StaticArray"},{"location":"syntax_and_semantics/type_grammar.html#tuple","text":"alias Int32StringTuple = { Int32 , String } is the same as: alias Int32StringTuple = Tuple ( Int32 , String ) In regular code, {Int32, String} is a tuple instance containing Int32 and String as its elements. This is different than the above tuple type .","title":"Tuple"},{"location":"syntax_and_semantics/type_grammar.html#namedtuple","text":"alias Int32StringNamedTuple = { x : Int32 , y : String } is the same as: alias Int32StringNamedTuple = NamedTuple ( x : Int32 , y : String ) In regular code, {x: Int32, y: String} is a named tuple instance containing Int32 and String for x and y . This is different than the above named tuple type .","title":"NamedTuple"},{"location":"syntax_and_semantics/type_grammar.html#proc","text":"alias Int32ToString = Int32 -> String is the same as: alias Int32ToString = Proc ( Int32 , String ) To specify a Proc without parameters: alias ProcThatReturnsInt32 = -> Int32 To specify multiple parameters: alias Int32AndCharToString = Int32 , Char -> String For nested procs (and any type, in general), you can use parentheses: alias ComplexProc = ( Int32 -> Int32 ) -> String In regular code Int32 -> String is a syntax error.","title":"Proc"},{"location":"syntax_and_semantics/type_grammar.html#self","text":"self can be used in the type grammar to denote a self type. Refer to the type restrictions section.","title":"self"},{"location":"syntax_and_semantics/type_grammar.html#class","text":"class is used to refer to a class type, instead of an instance type. For example: def foo ( x : Int32 ) \"instance\" end def foo ( x : Int32 . class ) \"class\" end foo 1 # \"instance\" foo Int32 # \"class\" class is also useful for creating arrays and collections of class type: class Parent end class Child1 < Parent end class Child2 < Parent end ary = [] of Parent . class ary << Child1 ary << Child2","title":"class"},{"location":"syntax_and_semantics/type_grammar.html#underscore","text":"An underscore is allowed in type restrictions. It matches anything: # Same as not specifying a restriction, not very useful def foo ( x : _ ) end # A bit more useful: any two-parameter Proc that returns an Int32: def foo ( x : _ , _ -> Int32 ) end","title":"Underscore"},{"location":"syntax_and_semantics/type_grammar.html#typeof","text":"typeof is allowed in the type grammar. It returns a union type of the type of the passed expressions: typeof ( 1 + 2 ) # => Int32 typeof ( 1 , \"a\" ) # => (Int32 | String)","title":"typeof"},{"location":"syntax_and_semantics/type_inference.html","text":"Type inference \u00b6 Crystal's philosophy is to require as few type restrictions as possible. However, some restrictions are required. Consider a class definition like this: class Person def initialize ( @name ) @age = 0 end end We can quickly see that @age is an integer, but we don't know the type of @name . The compiler could infer its type from all uses of the Person class. However, doing so has a few issues: The type is not obvious for a human reading the code: they would also have to check all uses of Person to find this out. Some compiler optimizations, like having to analyze a method just once, and incremental compilation, are nearly impossible to do. As a code base grows, these issues gain more relevance: understanding a project becomes harder, and compile times become unbearable. For this reason, Crystal needs to know, in an obvious way (as obvious as to a human), the types of instance and class variables. There are several ways to let Crystal know this. With type restrictions \u00b6 The easiest, but probably most tedious, way is to use explicit type restrictions. class Person @name : String @age : Int32 def initialize ( @name ) @age = 0 end end Without type restrictions \u00b6 If you omit an explicit type restriction, the compiler will try to infer the type of instance and class variables using a bunch of syntactic rules. For a given instance/class variable, when a rule can be applied and a type can be guessed, the type is added to a set. When no more rules can be applied, the inferred type will be the union of those types. Additionally, if the compiler infers that an instance variable isn't always initialized, it will also include the Nil type. The rules are many, but usually the first three are most used. There's no need to remember them all. If the compiler gives an error saying that the type of an instance variable can't be inferred you can always add an explicit type restriction. The following rules only mention instance variables, but they apply to class variables as well. They are: 1. Assigning a literal value \u00b6 When a literal is assigned to an instance variable, the literal's type is added to the set. All literals have an associated type. In the following example, @name is inferred to be String and @age to be Int32 . class Person def initialize @name = \"John Doe\" @age = 0 end end This rule, and every following rule, will also be applied in methods other than initialize . For example: class SomeObject def lucky_number @lucky_number = 42 end end In the above case, @lucky_number will be inferred to be Int32 | Nil : Int32 because 42 was assigned to it, and Nil because it wasn't assigned in all of the class' initialize methods. 2. Assigning the result of invoking the class method new \u00b6 When an expression like Type.new(...) is assigned to an instance variable, the type Type is added to the set. In the following example, @address is inferred to be Address . class Person def initialize @address = Address . new ( \"somewhere\" ) end end This also is applied to generic types. Here @values is inferred to be Array(Int32) . class Something def initialize @values = Array ( Int32 ) . new end end Note : a new method might be redefined by a type. In that case the inferred type will be the one returned by new , if it can be inferred using some of the next rules. 3. Assigning a variable that is a method parameter with a type restriction \u00b6 In the following example @name is inferred to be String because the method parameter name has a type restriction of type String , and that parameter is assigned to @name . class Person def initialize ( name : String ) @name = name end end Note that the name of the method parameter is not important; this works as well: class Person def initialize ( obj : String ) @name = obj end end Using the shorter syntax to assign an instance variable from a method parameter has the same effect: class Person def initialize ( @name : String ) end end Also note that the compiler doesn't check whether a method parameter is reassigned a different value: class Person def initialize ( name : String ) name = 1 @name = name end end In the above case, the compiler will still infer @name to be String , and later will give a compile time error, when fully typing that method, saying that Int32 can't be assigned to a variable of type String . Use an explicit type restriction if @name isn't supposed to be a String . 4. Assigning the result of a class method that has a return type restriction \u00b6 In the following example, @address is inferred to be Address , because the class method Address.unknown has a return type restriction of Address . class Person def initialize @address = Address . unknown end end class Address def self . unknown : Address new ( \"unknown\" ) end def initialize ( @name : String ) end end In fact, the above code doesn't need the return type restriction in self.unknown . The reason is that the compiler will also look at a class method's body and if it can apply one of the previous rules (it's a new method, or it's a literal, etc.) it will infer the type from that expression. So, the above can be simply written like this: class Person def initialize @address = Address . unknown end end class Address # No need for a return type restriction here def self . unknown new ( \"unknown\" ) end def initialize ( @name : String ) end end This extra rule is very convenient because it's very common to have \"constructor-like\" class methods in addition to new . 5. Assigning a variable that is a method parameter with a default value \u00b6 In the following example, because the default value of name is a string literal, and it's later assigned to @name , String will be added to the set of inferred types. class Person def initialize ( name = \"John Doe\" ) @name = name end end This of course also works with the short syntax: class Person def initialize ( @name = \"John Doe\" ) end end The default parameter value can also be a Type.new(...) method or a class method with a return type restriction. 6. Assigning the result of invoking a lib function \u00b6 Because a lib function must have explicit types, the compiler can use the return type when assigning it to an instance variable. In the following example @age is inferred to be Int32 . class Person def initialize @age = LibPerson . compute_default_age end end lib LibPerson fun compute_default_age : Int32 end 7. Using an out lib expression \u00b6 Because a lib function must have explicit types, the compiler can use the out argument's type, which should be a pointer type, and use the dereferenced type as a guess. In the following example @age is inferred to be Int32 . class Person def initialize LibPerson . compute_default_age ( out @age ) end end lib LibPerson fun compute_default_age ( age_ptr : Int32 * ) end Other rules \u00b6 The compiler will try to be as smart as possible to require less explicit type restrictions. For example, if assigning an if expression, type will be inferred from the then and else branches: class Person def initialize @age = some_condition ? 1 : 2 end end Because the if above (well, technically a ternary operator, but it's similar to an if ) has integer literals, @age is successfully inferred to be Int32 without requiring a redundant type restriction. Another case is || and ||= : class SomeObject def lucky_number @lucky_number ||= 42 end end In the above example @lucky_number will be inferred to be Int32 | Nil . This is very useful for lazily initialized variables. Constants will also be followed, as it's pretty simple for the compiler (and a human) to do so. class SomeObject DEFAULT_LUCKY_NUMBER = 42 def initialize ( @lucky_number = DEFAULT_LUCKY_NUMBER ) end end Here rule 5 (default parameter value) is used, and because the constant resolves to an integer literal, @lucky_number is inferred to be Int32 .","title":"Type inference"},{"location":"syntax_and_semantics/type_inference.html#type-inference","text":"Crystal's philosophy is to require as few type restrictions as possible. However, some restrictions are required. Consider a class definition like this: class Person def initialize ( @name ) @age = 0 end end We can quickly see that @age is an integer, but we don't know the type of @name . The compiler could infer its type from all uses of the Person class. However, doing so has a few issues: The type is not obvious for a human reading the code: they would also have to check all uses of Person to find this out. Some compiler optimizations, like having to analyze a method just once, and incremental compilation, are nearly impossible to do. As a code base grows, these issues gain more relevance: understanding a project becomes harder, and compile times become unbearable. For this reason, Crystal needs to know, in an obvious way (as obvious as to a human), the types of instance and class variables. There are several ways to let Crystal know this.","title":"Type inference"},{"location":"syntax_and_semantics/type_inference.html#with-type-restrictions","text":"The easiest, but probably most tedious, way is to use explicit type restrictions. class Person @name : String @age : Int32 def initialize ( @name ) @age = 0 end end","title":"With type restrictions"},{"location":"syntax_and_semantics/type_inference.html#without-type-restrictions","text":"If you omit an explicit type restriction, the compiler will try to infer the type of instance and class variables using a bunch of syntactic rules. For a given instance/class variable, when a rule can be applied and a type can be guessed, the type is added to a set. When no more rules can be applied, the inferred type will be the union of those types. Additionally, if the compiler infers that an instance variable isn't always initialized, it will also include the Nil type. The rules are many, but usually the first three are most used. There's no need to remember them all. If the compiler gives an error saying that the type of an instance variable can't be inferred you can always add an explicit type restriction. The following rules only mention instance variables, but they apply to class variables as well. They are:","title":"Without type restrictions"},{"location":"syntax_and_semantics/type_inference.html#1-assigning-a-literal-value","text":"When a literal is assigned to an instance variable, the literal's type is added to the set. All literals have an associated type. In the following example, @name is inferred to be String and @age to be Int32 . class Person def initialize @name = \"John Doe\" @age = 0 end end This rule, and every following rule, will also be applied in methods other than initialize . For example: class SomeObject def lucky_number @lucky_number = 42 end end In the above case, @lucky_number will be inferred to be Int32 | Nil : Int32 because 42 was assigned to it, and Nil because it wasn't assigned in all of the class' initialize methods.","title":"1. Assigning a literal value"},{"location":"syntax_and_semantics/type_inference.html#2-assigning-the-result-of-invoking-the-class-method-new","text":"When an expression like Type.new(...) is assigned to an instance variable, the type Type is added to the set. In the following example, @address is inferred to be Address . class Person def initialize @address = Address . new ( \"somewhere\" ) end end This also is applied to generic types. Here @values is inferred to be Array(Int32) . class Something def initialize @values = Array ( Int32 ) . new end end Note : a new method might be redefined by a type. In that case the inferred type will be the one returned by new , if it can be inferred using some of the next rules.","title":"2. Assigning the result of invoking the class method new"},{"location":"syntax_and_semantics/type_inference.html#3-assigning-a-variable-that-is-a-method-parameter-with-a-type-restriction","text":"In the following example @name is inferred to be String because the method parameter name has a type restriction of type String , and that parameter is assigned to @name . class Person def initialize ( name : String ) @name = name end end Note that the name of the method parameter is not important; this works as well: class Person def initialize ( obj : String ) @name = obj end end Using the shorter syntax to assign an instance variable from a method parameter has the same effect: class Person def initialize ( @name : String ) end end Also note that the compiler doesn't check whether a method parameter is reassigned a different value: class Person def initialize ( name : String ) name = 1 @name = name end end In the above case, the compiler will still infer @name to be String , and later will give a compile time error, when fully typing that method, saying that Int32 can't be assigned to a variable of type String . Use an explicit type restriction if @name isn't supposed to be a String .","title":"3. Assigning a variable that is a method parameter with a type restriction"},{"location":"syntax_and_semantics/type_inference.html#4-assigning-the-result-of-a-class-method-that-has-a-return-type-restriction","text":"In the following example, @address is inferred to be Address , because the class method Address.unknown has a return type restriction of Address . class Person def initialize @address = Address . unknown end end class Address def self . unknown : Address new ( \"unknown\" ) end def initialize ( @name : String ) end end In fact, the above code doesn't need the return type restriction in self.unknown . The reason is that the compiler will also look at a class method's body and if it can apply one of the previous rules (it's a new method, or it's a literal, etc.) it will infer the type from that expression. So, the above can be simply written like this: class Person def initialize @address = Address . unknown end end class Address # No need for a return type restriction here def self . unknown new ( \"unknown\" ) end def initialize ( @name : String ) end end This extra rule is very convenient because it's very common to have \"constructor-like\" class methods in addition to new .","title":"4. Assigning the result of a class method that has a return type restriction"},{"location":"syntax_and_semantics/type_inference.html#5-assigning-a-variable-that-is-a-method-parameter-with-a-default-value","text":"In the following example, because the default value of name is a string literal, and it's later assigned to @name , String will be added to the set of inferred types. class Person def initialize ( name = \"John Doe\" ) @name = name end end This of course also works with the short syntax: class Person def initialize ( @name = \"John Doe\" ) end end The default parameter value can also be a Type.new(...) method or a class method with a return type restriction.","title":"5. Assigning a variable that is a method parameter with a default value"},{"location":"syntax_and_semantics/type_inference.html#6-assigning-the-result-of-invoking-a-lib-function","text":"Because a lib function must have explicit types, the compiler can use the return type when assigning it to an instance variable. In the following example @age is inferred to be Int32 . class Person def initialize @age = LibPerson . compute_default_age end end lib LibPerson fun compute_default_age : Int32 end","title":"6. Assigning the result of invoking a lib function"},{"location":"syntax_and_semantics/type_inference.html#7-using-an-out-lib-expression","text":"Because a lib function must have explicit types, the compiler can use the out argument's type, which should be a pointer type, and use the dereferenced type as a guess. In the following example @age is inferred to be Int32 . class Person def initialize LibPerson . compute_default_age ( out @age ) end end lib LibPerson fun compute_default_age ( age_ptr : Int32 * ) end","title":"7. Using an out lib expression"},{"location":"syntax_and_semantics/type_inference.html#other-rules","text":"The compiler will try to be as smart as possible to require less explicit type restrictions. For example, if assigning an if expression, type will be inferred from the then and else branches: class Person def initialize @age = some_condition ? 1 : 2 end end Because the if above (well, technically a ternary operator, but it's similar to an if ) has integer literals, @age is successfully inferred to be Int32 without requiring a redundant type restriction. Another case is || and ||= : class SomeObject def lucky_number @lucky_number ||= 42 end end In the above example @lucky_number will be inferred to be Int32 | Nil . This is very useful for lazily initialized variables. Constants will also be followed, as it's pretty simple for the compiler (and a human) to do so. class SomeObject DEFAULT_LUCKY_NUMBER = 42 def initialize ( @lucky_number = DEFAULT_LUCKY_NUMBER ) end end Here rule 5 (default parameter value) is used, and because the constant resolves to an integer literal, @lucky_number is inferred to be Int32 .","title":"Other rules"},{"location":"syntax_and_semantics/type_reflection.html","text":"Type reflection \u00b6 Crystal provides basic methods to do type reflection, casting and introspection.","title":"Type reflection"},{"location":"syntax_and_semantics/type_reflection.html#type-reflection","text":"Crystal provides basic methods to do type reflection, casting and introspection.","title":"Type reflection"},{"location":"syntax_and_semantics/type_restrictions.html","text":"Type restrictions \u00b6 Type restrictions are applied to method parameters to restrict the types accepted by that method. def add ( x : Number , y : Number ) x + y end # Ok add 1 , 2 # Error: no overload matches 'add' with types Bool, Bool add true , false Note that if we had defined add without type restrictions, we would also have gotten a compile time error: def add ( x , y ) x + y end add true , false The above code gives this compile error: Error in foo.cr:6: instantiating 'add(Bool, Bool)' add true, false ^~~ in foo.cr:2: undefined method '+' for Bool x + y ^ This is because when you invoke add , it is instantiated with the types of the arguments: every method invocation with a different type combination results in a different method instantiation. The only difference is that the first error message is a little more clear, but both definitions are safe in that you will get a compile time error anyway. So, in general, it's preferable not to specify type restrictions and almost only use them to define different method overloads. This results in more generic, reusable code. For example, if we define a class that has a + method but isn't a Number , we can use the add method that doesn't have type restrictions, but we can't use the add method that has restrictions. # A class that has a + method but isn't a Number class Six def + ( other ) 6 + other end end # add method without type restrictions def add ( x , y ) x + y end # OK add Six . new , 10 # add method with type restrictions def restricted_add ( x : Number , y : Number ) x + y end # Error: no overload matches 'restricted_add' with types Six, Int32 restricted_add Six . new , 10 Refer to the type grammar for the notation used in type restrictions. Note that type restrictions do not apply to the variables inside the actual methods. def handle_path ( path : String ) path = Path . new ( path ) # *path* is now of the type Path # Do something with *path* end self restriction \u00b6 A special type restriction is self : class Person def == ( other : self ) other . name == name end def == ( other ) false end end john = Person . new \"John\" another_john = Person . new \"John\" peter = Person . new \"Peter\" john == another_john # => true john == peter # => false (names differ) john == 1 # => false (because 1 is not a Person) In the previous example self is the same as writing Person . But, in general, self is the same as writing the type that will finally own that method, which, when modules are involved, becomes more useful. As a side note, since Person inherits Reference the second definition of == is not needed, since it's already defined in Reference . Note that self always represents a match against an instance type, even in class methods: class Person getter name : String def initialize ( @name ) end def self . compare ( p1 : self , p2 : self ) p1 . name == p2 . name end end john = Person . new \"John\" peter = Person . new \"Peter\" Person . compare ( john , peter ) # OK You can use self.class to restrict to the Person type. The next section talks about the .class suffix in type restrictions. Classes as restrictions \u00b6 Using, for example, Int32 as a type restriction makes the method only accept instances of Int32 : def foo ( x : Int32 ) end foo 1 # OK foo \"hello\" # Error If you want a method to only accept the type Int32 (not instances of it), you use .class : def foo ( x : Int32 . class ) end foo Int32 # OK foo String # Error The above is useful for providing overloads based on types, not instances: def foo ( x : Int32 . class ) puts \"Got Int32\" end def foo ( x : String . class ) puts \"Got String\" end foo Int32 # prints \"Got Int32\" foo String # prints \"Got String\" Type restrictions in splats \u00b6 You can specify type restrictions in splats: def foo ( * args : Int32 ) end def foo ( * args : String ) end foo 1 , 2 , 3 # OK, invokes first overload foo \"a\" , \"b\" , \"c\" # OK, invokes second overload foo 1 , 2 , \"hello\" # Error foo () # Error When specifying a type, all elements in a tuple must match that type. Additionally, the empty-tuple doesn't match any of the above cases. If you want to support the empty-tuple case, add another overload: def foo # This is the empty-tuple case end A simple way to match against one or more elements of any type is to use Object as a restriction: def foo ( * args : Object ) end foo () # Error foo ( 1 ) # OK foo ( 1 , \"x\" ) # OK Free variables \u00b6 You can make a type restriction take the type of an argument, or part of the type of an argument, using forall : def foo ( x : T ) forall T T end foo ( 1 ) # => Int32 foo ( \"hello\" ) # => String That is, T becomes the type that was effectively used to instantiate the method. A free variable can be used to extract the type argument of a generic type within a type restriction: def foo ( x : Array ( T )) forall T T end foo ( [ 1 , 2 ] ) # => Int32 foo ( [ 1 , \"a\" ] ) # => (Int32 | String) To create a method that accepts a type name, rather than an instance of a type, append .class to a free variable in the type restriction: def foo ( x : T . class ) forall T Array ( T ) end foo ( Int32 ) # => Array(Int32) foo ( String ) # => Array(String) Multiple free variables can be specified too, for matching types of multiple arguments: def push ( element : T , array : Array ( T )) forall T array << element end push ( 4 , [ 1 , 2 , 3 ] ) # OK push ( \"oops\" , [ 1 , 2 , 3 ] ) # Error","title":"Type restrictions"},{"location":"syntax_and_semantics/type_restrictions.html#type-restrictions","text":"Type restrictions are applied to method parameters to restrict the types accepted by that method. def add ( x : Number , y : Number ) x + y end # Ok add 1 , 2 # Error: no overload matches 'add' with types Bool, Bool add true , false Note that if we had defined add without type restrictions, we would also have gotten a compile time error: def add ( x , y ) x + y end add true , false The above code gives this compile error: Error in foo.cr:6: instantiating 'add(Bool, Bool)' add true, false ^~~ in foo.cr:2: undefined method '+' for Bool x + y ^ This is because when you invoke add , it is instantiated with the types of the arguments: every method invocation with a different type combination results in a different method instantiation. The only difference is that the first error message is a little more clear, but both definitions are safe in that you will get a compile time error anyway. So, in general, it's preferable not to specify type restrictions and almost only use them to define different method overloads. This results in more generic, reusable code. For example, if we define a class that has a + method but isn't a Number , we can use the add method that doesn't have type restrictions, but we can't use the add method that has restrictions. # A class that has a + method but isn't a Number class Six def + ( other ) 6 + other end end # add method without type restrictions def add ( x , y ) x + y end # OK add Six . new , 10 # add method with type restrictions def restricted_add ( x : Number , y : Number ) x + y end # Error: no overload matches 'restricted_add' with types Six, Int32 restricted_add Six . new , 10 Refer to the type grammar for the notation used in type restrictions. Note that type restrictions do not apply to the variables inside the actual methods. def handle_path ( path : String ) path = Path . new ( path ) # *path* is now of the type Path # Do something with *path* end","title":"Type restrictions"},{"location":"syntax_and_semantics/type_restrictions.html#self-restriction","text":"A special type restriction is self : class Person def == ( other : self ) other . name == name end def == ( other ) false end end john = Person . new \"John\" another_john = Person . new \"John\" peter = Person . new \"Peter\" john == another_john # => true john == peter # => false (names differ) john == 1 # => false (because 1 is not a Person) In the previous example self is the same as writing Person . But, in general, self is the same as writing the type that will finally own that method, which, when modules are involved, becomes more useful. As a side note, since Person inherits Reference the second definition of == is not needed, since it's already defined in Reference . Note that self always represents a match against an instance type, even in class methods: class Person getter name : String def initialize ( @name ) end def self . compare ( p1 : self , p2 : self ) p1 . name == p2 . name end end john = Person . new \"John\" peter = Person . new \"Peter\" Person . compare ( john , peter ) # OK You can use self.class to restrict to the Person type. The next section talks about the .class suffix in type restrictions.","title":"self restriction"},{"location":"syntax_and_semantics/type_restrictions.html#classes-as-restrictions","text":"Using, for example, Int32 as a type restriction makes the method only accept instances of Int32 : def foo ( x : Int32 ) end foo 1 # OK foo \"hello\" # Error If you want a method to only accept the type Int32 (not instances of it), you use .class : def foo ( x : Int32 . class ) end foo Int32 # OK foo String # Error The above is useful for providing overloads based on types, not instances: def foo ( x : Int32 . class ) puts \"Got Int32\" end def foo ( x : String . class ) puts \"Got String\" end foo Int32 # prints \"Got Int32\" foo String # prints \"Got String\"","title":"Classes as restrictions"},{"location":"syntax_and_semantics/type_restrictions.html#type-restrictions-in-splats","text":"You can specify type restrictions in splats: def foo ( * args : Int32 ) end def foo ( * args : String ) end foo 1 , 2 , 3 # OK, invokes first overload foo \"a\" , \"b\" , \"c\" # OK, invokes second overload foo 1 , 2 , \"hello\" # Error foo () # Error When specifying a type, all elements in a tuple must match that type. Additionally, the empty-tuple doesn't match any of the above cases. If you want to support the empty-tuple case, add another overload: def foo # This is the empty-tuple case end A simple way to match against one or more elements of any type is to use Object as a restriction: def foo ( * args : Object ) end foo () # Error foo ( 1 ) # OK foo ( 1 , \"x\" ) # OK","title":"Type restrictions in splats"},{"location":"syntax_and_semantics/type_restrictions.html#free-variables","text":"You can make a type restriction take the type of an argument, or part of the type of an argument, using forall : def foo ( x : T ) forall T T end foo ( 1 ) # => Int32 foo ( \"hello\" ) # => String That is, T becomes the type that was effectively used to instantiate the method. A free variable can be used to extract the type argument of a generic type within a type restriction: def foo ( x : Array ( T )) forall T T end foo ( [ 1 , 2 ] ) # => Int32 foo ( [ 1 , \"a\" ] ) # => (Int32 | String) To create a method that accepts a type name, rather than an instance of a type, append .class to a free variable in the type restriction: def foo ( x : T . class ) forall T Array ( T ) end foo ( Int32 ) # => Array(Int32) foo ( String ) # => Array(String) Multiple free variables can be specified too, for matching types of multiple arguments: def push ( element : T , array : Array ( T )) forall T array << element end push ( 4 , [ 1 , 2 , 3 ] ) # OK push ( \"oops\" , [ 1 , 2 , 3 ] ) # Error","title":"Free variables"},{"location":"syntax_and_semantics/typeof.html","text":"typeof \u00b6 The typeof expression returns the type of an expression: a = 1 b = typeof ( a ) # => Int32 It accepts multiple arguments, and the result is the union of the expression types: typeof ( 1 , \"a\" , 'a' ) # => (Int32 | String | Char) It is often used in generic code, to make use of the compiler's type inference capabilities: hash = {} of Int32 => String another_hash = typeof ( hash ) . new # :: Hash(Int32, String) Since typeof doesn't actually evaluate the expression, it can be used on methods at compile time, such as in this example, which recursively forms a union type out of nested generic types: class Array def self . elem_type ( typ ) if typ .is_a? ( Array ) elem_type ( typ . first ) else typ end end end nest = [ 1 , [ \"b\" , [ :c , [ 'd' ]]]] flat = Array ( typeof ( Array . elem_type ( nest ))) . new typeof ( nest ) # => Array(Int32 | Array(String | Array(Symbol | Array(Char)))) typeof ( flat ) # => Array(String | Int32 | Symbol | Char) This expression is also available in the type grammar .","title":"typeof"},{"location":"syntax_and_semantics/typeof.html#typeof","text":"The typeof expression returns the type of an expression: a = 1 b = typeof ( a ) # => Int32 It accepts multiple arguments, and the result is the union of the expression types: typeof ( 1 , \"a\" , 'a' ) # => (Int32 | String | Char) It is often used in generic code, to make use of the compiler's type inference capabilities: hash = {} of Int32 => String another_hash = typeof ( hash ) . new # :: Hash(Int32, String) Since typeof doesn't actually evaluate the expression, it can be used on methods at compile time, such as in this example, which recursively forms a union type out of nested generic types: class Array def self . elem_type ( typ ) if typ .is_a? ( Array ) elem_type ( typ . first ) else typ end end end nest = [ 1 , [ \"b\" , [ :c , [ 'd' ]]]] flat = Array ( typeof ( Array . elem_type ( nest ))) . new typeof ( nest ) # => Array(Int32 | Array(String | Array(Symbol | Array(Char)))) typeof ( flat ) # => Array(String | Int32 | Symbol | Char) This expression is also available in the type grammar .","title":"typeof"},{"location":"syntax_and_semantics/types_and_methods.html","text":"Types and methods \u00b6 The next sections will assume you know what object oriented programming is, as well as the concepts of classes and methods .","title":"Types and methods"},{"location":"syntax_and_semantics/types_and_methods.html#types-and-methods","text":"The next sections will assume you know what object oriented programming is, as well as the concepts of classes and methods .","title":"Types and methods"},{"location":"syntax_and_semantics/union_types.html","text":"Union types \u00b6 The type of a variable or expression can consist of multiple types. This is called a union type. For example, when assigning to a same variable inside different if branches: if 1 + 2 == 3 a = 1 else a = \"hello\" end a # : Int32 | String At the end of the if, a will have the Int32 | String type, read \"the union of Int32 and String\". This union type is created automatically by the compiler. At runtime, a will of course be of one type only. This can be seen by invoking the class method: # The runtime type a . class # => Int32 The compile-time type can be seen by using typeof : # The compile-time type typeof ( a ) # => Int32 | String A union can consist of an arbitrary large number of types. When invoking a method on an expression whose type is a union type, all types in the union must respond to the method, otherwise a compile-time error is given. The type of the method call is the union type of the return types of those methods. # to_s is defined for Int32 and String, it returns String a . to_s # => String a + 1 # Error, because String#+(Int32) isn't defined If necessary a variable can be defined as a union type at compile time # set the compile-time type a = 0 .as ( Int32 | Nil | String ) typeof ( a ) # => Int32 | Nil | String Union types rules \u00b6 In the general case, when two types T1 and T2 are combined, the result is a union T1 | T2 . However, there are a few cases where the resulting type is a different type. Union of classes and structs under the same hierarchy \u00b6 If T1 and T2 are under the same hierarchy, and their nearest common ancestor Parent is not Reference , Struct , Int , Float nor Value , the resulting type is Parent+ . This is called a virtual type, which basically means the compiler will now see the type as being Parent or any of its subtypes. For example: class Foo end class Bar < Foo end class Baz < Foo end bar = Bar . new baz = Baz . new # Here foo's type will be Bar | Baz, # but because both Bar and Baz inherit from Foo, # the resulting type is Foo+ foo = rand < 0.5 ? bar : baz typeof ( foo ) # => Foo+ Union of tuples of the same size \u00b6 The union of two tuples of the same size results in a tuple type that has the union of the types in each position. For example: t1 = { 1 , \"hi\" } # Tuple(Int32, String) t2 = { true , nil } # Tuple(Bool, Nil) t3 = rand < 0.5 ? t1 : t2 typeof ( t3 ) # Tuple(Int32 | Bool, String | Nil) Union of named tuples with the same keys \u00b6 The union of two named tuples with the same keys (regardless of their order) results in a named tuple type that has the union of the types in each key. The order of the keys will be the ones from the tuple on the left hand side. For example: t1 = { x : 1 , y : \"hi\" } # Tuple(x: Int32, y: String) t2 = { y : true , x : nil } # Tuple(y: Bool, x: Nil) t3 = rand < 0.5 ? t1 : t2 typeof ( t3 ) # NamedTuple(x: Int32 | Nil, y: String | Bool)","title":"Union types"},{"location":"syntax_and_semantics/union_types.html#union-types","text":"The type of a variable or expression can consist of multiple types. This is called a union type. For example, when assigning to a same variable inside different if branches: if 1 + 2 == 3 a = 1 else a = \"hello\" end a # : Int32 | String At the end of the if, a will have the Int32 | String type, read \"the union of Int32 and String\". This union type is created automatically by the compiler. At runtime, a will of course be of one type only. This can be seen by invoking the class method: # The runtime type a . class # => Int32 The compile-time type can be seen by using typeof : # The compile-time type typeof ( a ) # => Int32 | String A union can consist of an arbitrary large number of types. When invoking a method on an expression whose type is a union type, all types in the union must respond to the method, otherwise a compile-time error is given. The type of the method call is the union type of the return types of those methods. # to_s is defined for Int32 and String, it returns String a . to_s # => String a + 1 # Error, because String#+(Int32) isn't defined If necessary a variable can be defined as a union type at compile time # set the compile-time type a = 0 .as ( Int32 | Nil | String ) typeof ( a ) # => Int32 | Nil | String","title":"Union types"},{"location":"syntax_and_semantics/union_types.html#union-types-rules","text":"In the general case, when two types T1 and T2 are combined, the result is a union T1 | T2 . However, there are a few cases where the resulting type is a different type.","title":"Union types rules"},{"location":"syntax_and_semantics/union_types.html#union-of-classes-and-structs-under-the-same-hierarchy","text":"If T1 and T2 are under the same hierarchy, and their nearest common ancestor Parent is not Reference , Struct , Int , Float nor Value , the resulting type is Parent+ . This is called a virtual type, which basically means the compiler will now see the type as being Parent or any of its subtypes. For example: class Foo end class Bar < Foo end class Baz < Foo end bar = Bar . new baz = Baz . new # Here foo's type will be Bar | Baz, # but because both Bar and Baz inherit from Foo, # the resulting type is Foo+ foo = rand < 0.5 ? bar : baz typeof ( foo ) # => Foo+","title":"Union of classes and structs under the same hierarchy"},{"location":"syntax_and_semantics/union_types.html#union-of-tuples-of-the-same-size","text":"The union of two tuples of the same size results in a tuple type that has the union of the types in each position. For example: t1 = { 1 , \"hi\" } # Tuple(Int32, String) t2 = { true , nil } # Tuple(Bool, Nil) t3 = rand < 0.5 ? t1 : t2 typeof ( t3 ) # Tuple(Int32 | Bool, String | Nil)","title":"Union of tuples of the same size"},{"location":"syntax_and_semantics/union_types.html#union-of-named-tuples-with-the-same-keys","text":"The union of two named tuples with the same keys (regardless of their order) results in a named tuple type that has the union of the types in each key. The order of the keys will be the ones from the tuple on the left hand side. For example: t1 = { x : 1 , y : \"hi\" } # Tuple(x: Int32, y: String) t2 = { y : true , x : nil } # Tuple(y: Bool, x: Nil) t3 = rand < 0.5 ? t1 : t2 typeof ( t3 ) # NamedTuple(x: Int32 | Nil, y: String | Bool)","title":"Union of named tuples with the same keys"},{"location":"syntax_and_semantics/unless.html","text":"unless \u00b6 An unless evaluates the then branch if its condition is falsey , and evaluates the else branch , if there\u2019s any, otherwise. That is, it behaves in the opposite way of an if : unless some_condition then_expression else else_expression end # The above is the same as: if some_condition else_expression else then_expression end # Can also be written as a suffix close_door unless door_closed?","title":"unless"},{"location":"syntax_and_semantics/unless.html#unless","text":"An unless evaluates the then branch if its condition is falsey , and evaluates the else branch , if there\u2019s any, otherwise. That is, it behaves in the opposite way of an if : unless some_condition then_expression else else_expression end # The above is the same as: if some_condition else_expression else then_expression end # Can also be written as a suffix close_door unless door_closed?","title":"unless"},{"location":"syntax_and_semantics/unsafe.html","text":"Unsafe code \u00b6 These parts of the language are considered unsafe: Code involving raw pointers: the Pointer type and pointerof . The allocate class method. Code involving C bindings Uninitialized variable declaration \"Unsafe\" means that memory corruption, segmentation faults and crashes are possible to achieve. For example: a = 1 ptr = pointerof ( a ) ptr [ 100_000 ] = 2 # undefined behaviour, probably a segmentation fault However, regular code usually never involves pointer manipulation or uninitialized variables. And C bindings are usually wrapped in safe wrappers that include null pointers and bounds checks. No language is 100% safe: some parts will inevitably be low-level, interface with the operating system and involve pointer manipulation. But once you abstract that and operate on a higher level, and assume (after mathematical proof or thorough testing) that the lower grounds are safe, you can be confident that your entire codebase is safe.","title":"Unsafe code"},{"location":"syntax_and_semantics/unsafe.html#unsafe-code","text":"These parts of the language are considered unsafe: Code involving raw pointers: the Pointer type and pointerof . The allocate class method. Code involving C bindings Uninitialized variable declaration \"Unsafe\" means that memory corruption, segmentation faults and crashes are possible to achieve. For example: a = 1 ptr = pointerof ( a ) ptr [ 100_000 ] = 2 # undefined behaviour, probably a segmentation fault However, regular code usually never involves pointer manipulation or uninitialized variables. And C bindings are usually wrapped in safe wrappers that include null pointers and bounds checks. No language is 100% safe: some parts will inevitably be low-level, interface with the operating system and involve pointer manipulation. But once you abstract that and operate on a higher level, and assume (after mathematical proof or thorough testing) that the lower grounds are safe, you can be confident that your entire codebase is safe.","title":"Unsafe code"},{"location":"syntax_and_semantics/until.html","text":"until \u00b6 An until executes its body until its condition is truthy . An until is just syntax sugar for a while with the condition negated: until some_condition do_this end # The above is the same as: while ! some_condition do_this end break and next can also be used inside an until .","title":"until"},{"location":"syntax_and_semantics/until.html#until","text":"An until executes its body until its condition is truthy . An until is just syntax sugar for a while with the condition negated: until some_condition do_this end # The above is the same as: while ! some_condition do_this end break and next can also be used inside an until .","title":"until"},{"location":"syntax_and_semantics/virtual_and_abstract_types.html","text":"Virtual and abstract types \u00b6 When a variable's type combines different types under the same class hierarchy, its type becomes a virtual type . This applies to every class and struct except for Reference , Value , Int and Float . An example: class Animal end class Dog < Animal def talk \"Woof!\" end end class Cat < Animal def talk \"Miau\" end end class Person getter pet def initialize ( @name : String , @pet : Animal ) end end john = Person . new \"John\" , Dog . new peter = Person . new \"Peter\" , Cat . new If you compile the above program with the tool hierarchy command you will see this for Person : - class Object | +- class Reference | +- class Person @name : String @pet : Animal+ You can see that @pet is Animal+ . The + means it's a virtual type, meaning \"any class that inherits from Animal , including Animal \". The compiler will always resolve a type union to a virtual type if they are under the same hierarchy: if some_condition pet = Dog . new else pet = Cat . new end # pet : Animal+ The compiler will always do this for classes and structs under the same hierarchy: it will find the first superclass from which all types inherit from (excluding Reference , Value , Int and Float ). If it can't find one, the type union remains. The real reason the compiler does this is to be able to compile programs faster by not creating all kinds of different similar unions, also making the generated code smaller in size. But, on the other hand, it makes sense: classes under the same hierarchy should behave in a similar way. Lets make John's pet talk: john . pet . talk # Error: undefined method 'talk' for Animal We get an error because the compiler now treats @pet as an Animal+ , which includes Animal . And since it can't find a talk method on it, it errors. What the compiler doesn't know is that for us, Animal will never be instantiated as it doesn't make sense to instantiate one. We have a way to tell the compiler so by marking the class as abstract : abstract class Animal end Now the code compiles: john . pet . talk # => \"Woof!\" Marking a class as abstract will also prevent us from creating an instance of it: Animal . new # Error: can't instantiate abstract class Animal To make it more explicit that an Animal must define a talk method, we can add it to Animal as an abstract method: abstract class Animal # Makes this animal talk abstract def talk end By marking a method as abstract the compiler will check that all subclasses implement this method, even if a program doesn't use them. Abstract methods can also be defined in modules, and the compiler will check that including types implement them.","title":"Virtual and abstract types"},{"location":"syntax_and_semantics/virtual_and_abstract_types.html#virtual-and-abstract-types","text":"When a variable's type combines different types under the same class hierarchy, its type becomes a virtual type . This applies to every class and struct except for Reference , Value , Int and Float . An example: class Animal end class Dog < Animal def talk \"Woof!\" end end class Cat < Animal def talk \"Miau\" end end class Person getter pet def initialize ( @name : String , @pet : Animal ) end end john = Person . new \"John\" , Dog . new peter = Person . new \"Peter\" , Cat . new If you compile the above program with the tool hierarchy command you will see this for Person : - class Object | +- class Reference | +- class Person @name : String @pet : Animal+ You can see that @pet is Animal+ . The + means it's a virtual type, meaning \"any class that inherits from Animal , including Animal \". The compiler will always resolve a type union to a virtual type if they are under the same hierarchy: if some_condition pet = Dog . new else pet = Cat . new end # pet : Animal+ The compiler will always do this for classes and structs under the same hierarchy: it will find the first superclass from which all types inherit from (excluding Reference , Value , Int and Float ). If it can't find one, the type union remains. The real reason the compiler does this is to be able to compile programs faster by not creating all kinds of different similar unions, also making the generated code smaller in size. But, on the other hand, it makes sense: classes under the same hierarchy should behave in a similar way. Lets make John's pet talk: john . pet . talk # Error: undefined method 'talk' for Animal We get an error because the compiler now treats @pet as an Animal+ , which includes Animal . And since it can't find a talk method on it, it errors. What the compiler doesn't know is that for us, Animal will never be instantiated as it doesn't make sense to instantiate one. We have a way to tell the compiler so by marking the class as abstract : abstract class Animal end Now the code compiles: john . pet . talk # => \"Woof!\" Marking a class as abstract will also prevent us from creating an instance of it: Animal . new # Error: can't instantiate abstract class Animal To make it more explicit that an Animal must define a talk method, we can add it to Animal as an abstract method: abstract class Animal # Makes this animal talk abstract def talk end By marking a method as abstract the compiler will check that all subclasses implement this method, even if a program doesn't use them. Abstract methods can also be defined in modules, and the compiler will check that including types implement them.","title":"Virtual and abstract types"},{"location":"syntax_and_semantics/visibility.html","text":"Visibility \u00b6 Methods are public by default: the compiler will always let you invoke them. There is no public keyword for this reason. Methods can be marked as private or protected . Private methods \u00b6 A private method can only be invoked without a receiver, that is, without something before the dot. The only exception is self as a receiver: class Person private def say ( message ) puts message end def say_hello say \"hello\" # OK, no receiver self . say \"hello\" # OK, self is a receiver, but it's allowed. other = Person . new other . say \"hello\" # Error, other is a receiver end end Note that private methods are visible by subclasses: class Employee < Person def say_bye say \"bye\" # OK end end Private types \u00b6 Private types can only be referenced inside the namespace where they are defined, and never be fully qualified. class Foo private class Bar end Bar # OK Foo :: Bar # Error end Foo :: Bar # Error private can be used with class , module , lib , enum , alias and constants: class Foo private ONE = 1 ONE # => 1 end Foo :: ONE # Error Protected methods \u00b6 A protected method can only be invoked on: instances of the same type as the current type instances in the same namespace (class, struct, module, etc.) as the current type # Example of 1 class Person protected def say ( message ) puts message end def say_hello say \"hello\" # OK, implicit self is a Person self . say \"hello\" # OK, self is a Person other = Person . new \"Other\" other . say \"hello\" # OK, other is a Person end end class Animal def make_a_person_talk person = Person . new person . say \"hello\" # Error: person is a Person but current type is an Animal end end one_more = Person . new \"One more\" one_more . say \"hello\" # Error: one_more is a Person but current type is the Program # Example of 2 module Namespace class Foo protected def foo puts \"Hello\" end end class Bar def bar # Works, because Foo and Bar are under Namespace Foo . new . foo end end end Namespace :: Bar . new . bar A protected method can only be invoked from the scope of its class or its descendants. That includes the class scope and bodies of class methods and instance methods of the same type the protected method is defined on, as well as all types including or inherinting that type and all types in that namespace. class Parent protected def self . protected_method end Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end class Child < Parent Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end class Parent:: Sub Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end Private top-level methods \u00b6 A private top-level method is only visible in the current file. # In file one.cr private def greet puts \"Hello\" end greet # => \"Hello\" # In file two.cr require \"./one\" greet # undefined local variable or method 'greet' This allows you to define helper methods in a file that will only be known in that file. Private top-level types \u00b6 A private top-level type is only visible in the current file. # In file one.cr private class Greeter def self . greet \"Hello\" end end Greeter . greet # => \"Hello\" # In file two.cr require \"./one\" Greeter . greet # undefined constant 'Greeter'","title":"Visibility"},{"location":"syntax_and_semantics/visibility.html#visibility","text":"Methods are public by default: the compiler will always let you invoke them. There is no public keyword for this reason. Methods can be marked as private or protected .","title":"Visibility"},{"location":"syntax_and_semantics/visibility.html#private-methods","text":"A private method can only be invoked without a receiver, that is, without something before the dot. The only exception is self as a receiver: class Person private def say ( message ) puts message end def say_hello say \"hello\" # OK, no receiver self . say \"hello\" # OK, self is a receiver, but it's allowed. other = Person . new other . say \"hello\" # Error, other is a receiver end end Note that private methods are visible by subclasses: class Employee < Person def say_bye say \"bye\" # OK end end","title":"Private methods"},{"location":"syntax_and_semantics/visibility.html#private-types","text":"Private types can only be referenced inside the namespace where they are defined, and never be fully qualified. class Foo private class Bar end Bar # OK Foo :: Bar # Error end Foo :: Bar # Error private can be used with class , module , lib , enum , alias and constants: class Foo private ONE = 1 ONE # => 1 end Foo :: ONE # Error","title":"Private types"},{"location":"syntax_and_semantics/visibility.html#protected-methods","text":"A protected method can only be invoked on: instances of the same type as the current type instances in the same namespace (class, struct, module, etc.) as the current type # Example of 1 class Person protected def say ( message ) puts message end def say_hello say \"hello\" # OK, implicit self is a Person self . say \"hello\" # OK, self is a Person other = Person . new \"Other\" other . say \"hello\" # OK, other is a Person end end class Animal def make_a_person_talk person = Person . new person . say \"hello\" # Error: person is a Person but current type is an Animal end end one_more = Person . new \"One more\" one_more . say \"hello\" # Error: one_more is a Person but current type is the Program # Example of 2 module Namespace class Foo protected def foo puts \"Hello\" end end class Bar def bar # Works, because Foo and Bar are under Namespace Foo . new . foo end end end Namespace :: Bar . new . bar A protected method can only be invoked from the scope of its class or its descendants. That includes the class scope and bodies of class methods and instance methods of the same type the protected method is defined on, as well as all types including or inherinting that type and all types in that namespace. class Parent protected def self . protected_method end Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end class Child < Parent Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end class Parent:: Sub Parent . protected_method # OK def instance_method Parent . protected_method # OK end def self . class_method Parent . protected_method # OK end end","title":"Protected methods"},{"location":"syntax_and_semantics/visibility.html#private-top-level-methods","text":"A private top-level method is only visible in the current file. # In file one.cr private def greet puts \"Hello\" end greet # => \"Hello\" # In file two.cr require \"./one\" greet # undefined local variable or method 'greet' This allows you to define helper methods in a file that will only be known in that file.","title":"Private top-level methods"},{"location":"syntax_and_semantics/visibility.html#private-top-level-types","text":"A private top-level type is only visible in the current file. # In file one.cr private class Greeter def self . greet \"Hello\" end end Greeter . greet # => \"Hello\" # In file two.cr require \"./one\" Greeter . greet # undefined constant 'Greeter'","title":"Private top-level types"},{"location":"syntax_and_semantics/while.html","text":"while \u00b6 A while executes its body as long as its condition is truthy . while some_condition do_this end The condition is first tested and, if truthy , the body is executed. That is, the body might never be executed. A while 's type is always Nil . Similar to an if , if a while 's condition is a variable, the variable is guaranteed to not be nil inside the body. If the condition is an var.is_a?(Type) test, var is guaranteed to be of type Type inside the body. And if the condition is a var.responds_to?(:method) , var is guaranteed to be of a type that responds to that method. The type of a variable after a while depends on the type it had before the while and the type it had before leaving the while 's body: a = 1 while some_condition # a : Int32 | String a = \"hello\" # a : String a . size end # a : Int32 | String Checking the condition at the end of a loop \u00b6 If you need to execute the body at least once and then check for a breaking condition, you can do this: while true do_something break if some_condition end Or use loop , found in the standard library: loop do do_something break if some_condition end","title":"while"},{"location":"syntax_and_semantics/while.html#while","text":"A while executes its body as long as its condition is truthy . while some_condition do_this end The condition is first tested and, if truthy , the body is executed. That is, the body might never be executed. A while 's type is always Nil . Similar to an if , if a while 's condition is a variable, the variable is guaranteed to not be nil inside the body. If the condition is an var.is_a?(Type) test, var is guaranteed to be of type Type inside the body. And if the condition is a var.responds_to?(:method) , var is guaranteed to be of a type that responds to that method. The type of a variable after a while depends on the type it had before the while and the type it had before leaving the while 's body: a = 1 while some_condition # a : Int32 | String a = \"hello\" # a : String a . size end # a : Int32 | String","title":"while"},{"location":"syntax_and_semantics/while.html#checking-the-condition-at-the-end-of-a-loop","text":"If you need to execute the body at least once and then check for a breaking condition, you can do this: while true do_something break if some_condition end Or use loop , found in the standard library: loop do do_something break if some_condition end","title":"Checking the condition at the end of a loop"},{"location":"syntax_and_semantics/annotations/index.html","text":"Annotations \u00b6 Annotations can be used to add metadata to certain features in the source code. Types, methods and instance variables may be annotated. User-defined annotations, such as the standard library's JSON::Field , are defined using the annotation keyword. A number of built-in annotations are provided by the compiler. Users can define their own annotations using the annotation keyword, which works similarly to defining a class or struct . annotation MyAnnotation end The annotation can then be applied to various items, including: Instance and class methods Instance variables Classes, structs, enums, and modules annotation MyAnnotation end @[ MyAnnotation ] def foo \"foo\" end @[ MyAnnotation ] class Klass end @[ MyAnnotation ] module MyModule end Applications \u00b6 Annotations are best used to store metadata about a given instance variable, type, or method so that it can be read at compile time using macros. One of the main benefits of annotations is that they are applied directly to instance variables/methods, which causes classes to look more natural since a standard macro is not needed to create these properties/methods. A few applications for annotations: Object Serialization \u00b6 Have an annotation that when applied to an instance variable determines if that instance variable should be serialized, or with what key. Crystal's JSON::Serializable and YAML::Serializable are examples of this. ORMs \u00b6 An annotation could be used to designate a property as an ORM column. The name and type of the instance variable can be read off the TypeNode in addition to the annotation; removing the need for any ORM specific macro. The annotation itself could also be used to store metadata about the column, such as if it is nullable, the name of the column, or if it is the primary key. Fields \u00b6 Data can be stored within an annotation. annotation MyAnnotaion end # The fields can either be a key/value pair @[ MyAnnotation ( key : \"value\" , value : 123 ) ] # Or positional @[ MyAnnotation ( \"foo\" , 123 , false ) ] Key/value \u00b6 The values of annotation key/value pairs can be accessed at compile time via the [] method. annotation MyAnnotation end @[ MyAnnotation ( value : 2 ) ] def annotation_value # The name can be a `String`, `Symbol`, or `MacroId` {{ @def . annotation ( MyAnnotation ) [ :value ] }} end annotation_value # => 2 The named_args method can be used to read all key/value pairs on an annotation as a NamedTupleLiteral . This method is defined on all annotations by default, and is unique to each applied annotation. annotation MyAnnotation end @[ MyAnnotation ( value : 2 , name : \"Jim\" ) ] def annotation_named_args {{ @def . annotation ( MyAnnotation ) . named_args }} end annotation_named_args # => {value: 2, name: \"Jim\"} Since this method returns a NamedTupleLiteral , all of the methods on that type are available for use. Especially #double_splat which makes it easy to pass annotation arguments to methods. annotation MyAnnotation end class SomeClass def initialize ( @value : Int32 , @name : String ); end end @[ MyAnnotation ( value : 2 , name : \"Jim\" ) ] def new_test {% begin %} SomeClass . new {{ @def . annotation ( MyAnnotation ) . named_args . double_splat }} {% end %} end new_test # => #<SomeClass:0x5621a19ddf00 @name=\"Jim\", @value=2> Positional \u00b6 Positional values can be accessed at compile time via the [] method; however, only one index can be accessed at a time. annotation MyAnnotation end @[ MyAnnotation ( 1 , 2 , 3 , 4 ) ] def annotation_read {% for idx in [ 0 , 1 , 2 , 3 , 4 ] %} {% value = @def . annotation ( MyAnnotation ) [ idx ] %} pp \"{{ idx }} = {{ value }}\" {% end %} end annotation_read # Which would print \"0 = 1\" \"1 = 2\" \"2 = 3\" \"3 = 4\" \"4 = nil\" The args method can be used to read all positional arguments on an annotation as a TupleLiteral . This method is defined on all annotations by default, and is unique to each applied annotation. annotation MyAnnotation end @[ MyAnnotation ( 1 , 2 , 3 , 4 ) ] def annotation_args {{ @def . annotation ( MyAnnotation ) . args }} end annotation_args # => {1, 2, 3, 4} Since the return type of TupleLiteral is iterable, we can rewrite the previous example in a better way. By extension, all of the methods on TupleLiteral are available for use as well. annotation MyAnnotation end @[ MyAnnotation ( 1 , \"foo\" , true , 17.0 ) ] def annotation_read {% for value , idx in @def . annotation ( MyAnnotation ) . args %} pp \"{{ idx }} = #{{{ value }}} \" {% end %} end annotation_read # Which would print \"0 = 1\" \"1 = foo\" \"2 = true\" \"3 = 17.0\" Reading \u00b6 Annotations can be read off of a TypeNode , Def , or MetaVar using the .annotation(type : TypeNode) method. This method return an Annotation object representing the applied annotation of the supplied type. Note If multiple annotations of the same type are applied, the .annotation method will return the last one. The @type and @def variables can be used to get a TypeNode or Def object to use the .annotation method on. However, it is also possible to get TypeNode / Def types using other methods on TypeNode . For example TypeNode.all_subclasses or TypeNode.methods , respectively. The TypeNode.instance_vars can be used to get an array of instance variable MetaVar objects that would allow reading annotations defined on those instance variables. Note TypeNode.instance_vars currently only works in the context of an instance/class method. annotation MyClass end annotation MyMethod end annotation MyIvar end @[ MyClass ] class Foo pp {{ @type . annotation ( MyClass ) . stringify }} @[ MyIvar ] @num : Int32 = 1 @[ MyIvar ] property name : String = \"jim\" def properties {% for ivar in @type . instance_vars %} pp {{ ivar . annotation ( MyIvar ) . stringify }} {% end %} end end @[ MyMethod ] def my_method pp {{ @def . annotation ( MyMethod ) . stringify }} end Foo . new . properties my_method pp {{ Foo . annotation ( MyClass ) . stringify }} # Which would print \"@[MyClass]\" \"@[MyIvar]\" \"@[MyIvar]\" \"@[MyMethod]\" \"@[MyClass]\" Reading Multiple Annotations \u00b6 If there are multiple annotations of the same type applied to the same instance variable/method/type, the .annotations(type : TypeNode) method can be used. This will work on anything that .annotation(type : TypeNode) would, but instead returns an ArrayLiteral(Annotation) . annotation MyAnnotation end @[ MyAnnotation ( \"foo\" ) ] @[ MyAnnotation ( 123 ) ] @[ MyAnnotation ( 123 ) ] def annotation_read {% for ann , idx in @def . annotations ( MyAnnotation ) %} pp \"Annotation {{ idx }} = {{ ann[0].id }}\" {% end %} end annotation_read # Which would print \"Annotation 0 = foo\" \"Annotation 1 = 123\" \"Annotation 2 = 123\"","title":"Annotations"},{"location":"syntax_and_semantics/annotations/index.html#annotations","text":"Annotations can be used to add metadata to certain features in the source code. Types, methods and instance variables may be annotated. User-defined annotations, such as the standard library's JSON::Field , are defined using the annotation keyword. A number of built-in annotations are provided by the compiler. Users can define their own annotations using the annotation keyword, which works similarly to defining a class or struct . annotation MyAnnotation end The annotation can then be applied to various items, including: Instance and class methods Instance variables Classes, structs, enums, and modules annotation MyAnnotation end @[ MyAnnotation ] def foo \"foo\" end @[ MyAnnotation ] class Klass end @[ MyAnnotation ] module MyModule end","title":"Annotations"},{"location":"syntax_and_semantics/annotations/index.html#applications","text":"Annotations are best used to store metadata about a given instance variable, type, or method so that it can be read at compile time using macros. One of the main benefits of annotations is that they are applied directly to instance variables/methods, which causes classes to look more natural since a standard macro is not needed to create these properties/methods. A few applications for annotations:","title":"Applications"},{"location":"syntax_and_semantics/annotations/index.html#object-serialization","text":"Have an annotation that when applied to an instance variable determines if that instance variable should be serialized, or with what key. Crystal's JSON::Serializable and YAML::Serializable are examples of this.","title":"Object Serialization"},{"location":"syntax_and_semantics/annotations/index.html#orms","text":"An annotation could be used to designate a property as an ORM column. The name and type of the instance variable can be read off the TypeNode in addition to the annotation; removing the need for any ORM specific macro. The annotation itself could also be used to store metadata about the column, such as if it is nullable, the name of the column, or if it is the primary key.","title":"ORMs"},{"location":"syntax_and_semantics/annotations/index.html#fields","text":"Data can be stored within an annotation. annotation MyAnnotaion end # The fields can either be a key/value pair @[ MyAnnotation ( key : \"value\" , value : 123 ) ] # Or positional @[ MyAnnotation ( \"foo\" , 123 , false ) ]","title":"Fields"},{"location":"syntax_and_semantics/annotations/index.html#keyvalue","text":"The values of annotation key/value pairs can be accessed at compile time via the [] method. annotation MyAnnotation end @[ MyAnnotation ( value : 2 ) ] def annotation_value # The name can be a `String`, `Symbol`, or `MacroId` {{ @def . annotation ( MyAnnotation ) [ :value ] }} end annotation_value # => 2 The named_args method can be used to read all key/value pairs on an annotation as a NamedTupleLiteral . This method is defined on all annotations by default, and is unique to each applied annotation. annotation MyAnnotation end @[ MyAnnotation ( value : 2 , name : \"Jim\" ) ] def annotation_named_args {{ @def . annotation ( MyAnnotation ) . named_args }} end annotation_named_args # => {value: 2, name: \"Jim\"} Since this method returns a NamedTupleLiteral , all of the methods on that type are available for use. Especially #double_splat which makes it easy to pass annotation arguments to methods. annotation MyAnnotation end class SomeClass def initialize ( @value : Int32 , @name : String ); end end @[ MyAnnotation ( value : 2 , name : \"Jim\" ) ] def new_test {% begin %} SomeClass . new {{ @def . annotation ( MyAnnotation ) . named_args . double_splat }} {% end %} end new_test # => #<SomeClass:0x5621a19ddf00 @name=\"Jim\", @value=2>","title":"Key/value"},{"location":"syntax_and_semantics/annotations/index.html#positional","text":"Positional values can be accessed at compile time via the [] method; however, only one index can be accessed at a time. annotation MyAnnotation end @[ MyAnnotation ( 1 , 2 , 3 , 4 ) ] def annotation_read {% for idx in [ 0 , 1 , 2 , 3 , 4 ] %} {% value = @def . annotation ( MyAnnotation ) [ idx ] %} pp \"{{ idx }} = {{ value }}\" {% end %} end annotation_read # Which would print \"0 = 1\" \"1 = 2\" \"2 = 3\" \"3 = 4\" \"4 = nil\" The args method can be used to read all positional arguments on an annotation as a TupleLiteral . This method is defined on all annotations by default, and is unique to each applied annotation. annotation MyAnnotation end @[ MyAnnotation ( 1 , 2 , 3 , 4 ) ] def annotation_args {{ @def . annotation ( MyAnnotation ) . args }} end annotation_args # => {1, 2, 3, 4} Since the return type of TupleLiteral is iterable, we can rewrite the previous example in a better way. By extension, all of the methods on TupleLiteral are available for use as well. annotation MyAnnotation end @[ MyAnnotation ( 1 , \"foo\" , true , 17.0 ) ] def annotation_read {% for value , idx in @def . annotation ( MyAnnotation ) . args %} pp \"{{ idx }} = #{{{ value }}} \" {% end %} end annotation_read # Which would print \"0 = 1\" \"1 = foo\" \"2 = true\" \"3 = 17.0\"","title":"Positional"},{"location":"syntax_and_semantics/annotations/index.html#reading","text":"Annotations can be read off of a TypeNode , Def , or MetaVar using the .annotation(type : TypeNode) method. This method return an Annotation object representing the applied annotation of the supplied type. Note If multiple annotations of the same type are applied, the .annotation method will return the last one. The @type and @def variables can be used to get a TypeNode or Def object to use the .annotation method on. However, it is also possible to get TypeNode / Def types using other methods on TypeNode . For example TypeNode.all_subclasses or TypeNode.methods , respectively. The TypeNode.instance_vars can be used to get an array of instance variable MetaVar objects that would allow reading annotations defined on those instance variables. Note TypeNode.instance_vars currently only works in the context of an instance/class method. annotation MyClass end annotation MyMethod end annotation MyIvar end @[ MyClass ] class Foo pp {{ @type . annotation ( MyClass ) . stringify }} @[ MyIvar ] @num : Int32 = 1 @[ MyIvar ] property name : String = \"jim\" def properties {% for ivar in @type . instance_vars %} pp {{ ivar . annotation ( MyIvar ) . stringify }} {% end %} end end @[ MyMethod ] def my_method pp {{ @def . annotation ( MyMethod ) . stringify }} end Foo . new . properties my_method pp {{ Foo . annotation ( MyClass ) . stringify }} # Which would print \"@[MyClass]\" \"@[MyIvar]\" \"@[MyIvar]\" \"@[MyMethod]\" \"@[MyClass]\"","title":"Reading"},{"location":"syntax_and_semantics/annotations/index.html#reading-multiple-annotations","text":"If there are multiple annotations of the same type applied to the same instance variable/method/type, the .annotations(type : TypeNode) method can be used. This will work on anything that .annotation(type : TypeNode) would, but instead returns an ArrayLiteral(Annotation) . annotation MyAnnotation end @[ MyAnnotation ( \"foo\" ) ] @[ MyAnnotation ( 123 ) ] @[ MyAnnotation ( 123 ) ] def annotation_read {% for ann , idx in @def . annotations ( MyAnnotation ) %} pp \"Annotation {{ idx }} = {{ ann[0].id }}\" {% end %} end annotation_read # Which would print \"Annotation 0 = foo\" \"Annotation 1 = 123\" \"Annotation 2 = 123\"","title":"Reading Multiple Annotations"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html","text":"The Crystal standard library includes some pre-defined annotations: Link \u00b6 Tells the compiler how to link a C library. This is explained in the lib section. Extern \u00b6 Marking a Crystal struct with this annotation makes it possible to use it in lib declarations: @[ Extern ] struct MyStruct end lib MyLib fun my_func ( s : MyStruct ) # OK (gives an error without the Extern annotation) end You can also make a struct behave like a C union (this can be pretty unsafe): # A struct to easily convert between Int32 codepoints and Chars @[ Extern ( union : true ) ] struct Int32OrChar property int = 0 property char = '\\0' end s = Int32OrChar . new s . char = 'A' s . int # => 65 s . int = 66 s . char # => 'B' ThreadLocal \u00b6 The @[ThreadLocal] annotation can be applied to class variables and C external variables. It makes them be thread local. class DontUseThis # One for each thread @[ ThreadLocal ] @@values = [] of Int32 end ThreadLocal is used in the standard library to implement the runtime and shouldn't be needed or used outside it. Packed \u00b6 Marks a C struct as packed, which prevents the automatic insertion of padding bytes between fields. This is typically only needed if the C library explicitly uses packed structs. AlwaysInline \u00b6 Gives a hint to the compiler to always inline a method: @[ AlwaysInline ] def foo 1 end NoInline \u00b6 Tells the compiler to never inline a method call. This has no effect if the method yields, since functions which yield are always inlined. @[ NoInline ] def foo 1 end ReturnsTwice \u00b6 Marks a method or lib fun as returning twice. The C setjmp is an example of such a function. Raises \u00b6 Marks a method or lib fun as potentially raising an exception. This is explained in the callbacks section. CallConvention \u00b6 Indicates the call convention of a lib fun . For example: lib LibFoo @[ CallConvention ( \"X86_StdCall\" ) ] fun foo : Int32 end The list of valid call conventions is: C (the default) Fast Cold WebKit_JS AnyReg X86_StdCall X86_FastCall They are explained here . Flags \u00b6 Marks an enum as a \"flags enum\", which changes the behaviour of some of its methods, like to_s .","title":"Built-in annotations"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#link","text":"Tells the compiler how to link a C library. This is explained in the lib section.","title":"Link"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#extern","text":"Marking a Crystal struct with this annotation makes it possible to use it in lib declarations: @[ Extern ] struct MyStruct end lib MyLib fun my_func ( s : MyStruct ) # OK (gives an error without the Extern annotation) end You can also make a struct behave like a C union (this can be pretty unsafe): # A struct to easily convert between Int32 codepoints and Chars @[ Extern ( union : true ) ] struct Int32OrChar property int = 0 property char = '\\0' end s = Int32OrChar . new s . char = 'A' s . int # => 65 s . int = 66 s . char # => 'B'","title":"Extern"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#threadlocal","text":"The @[ThreadLocal] annotation can be applied to class variables and C external variables. It makes them be thread local. class DontUseThis # One for each thread @[ ThreadLocal ] @@values = [] of Int32 end ThreadLocal is used in the standard library to implement the runtime and shouldn't be needed or used outside it.","title":"ThreadLocal"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#packed","text":"Marks a C struct as packed, which prevents the automatic insertion of padding bytes between fields. This is typically only needed if the C library explicitly uses packed structs.","title":"Packed"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#alwaysinline","text":"Gives a hint to the compiler to always inline a method: @[ AlwaysInline ] def foo 1 end","title":"AlwaysInline"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#noinline","text":"Tells the compiler to never inline a method call. This has no effect if the method yields, since functions which yield are always inlined. @[ NoInline ] def foo 1 end","title":"NoInline"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#returnstwice","text":"Marks a method or lib fun as returning twice. The C setjmp is an example of such a function.","title":"ReturnsTwice"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#raises","text":"Marks a method or lib fun as potentially raising an exception. This is explained in the callbacks section.","title":"Raises"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#callconvention","text":"Indicates the call convention of a lib fun . For example: lib LibFoo @[ CallConvention ( \"X86_StdCall\" ) ] fun foo : Int32 end The list of valid call conventions is: C (the default) Fast Cold WebKit_JS AnyReg X86_StdCall X86_FastCall They are explained here .","title":"CallConvention"},{"location":"syntax_and_semantics/annotations/built_in_annotations.html#flags","text":"Marks an enum as a \"flags enum\", which changes the behaviour of some of its methods, like to_s .","title":"Flags"},{"location":"syntax_and_semantics/c_bindings/index.html","text":"C bindings \u00b6 Crystal allows you to bind to existing C libraries without writing a single line in C. Additionally, it provides some conveniences like out and to_unsafe so writing bindings is as painless as possible.","title":"C bindings"},{"location":"syntax_and_semantics/c_bindings/index.html#c-bindings","text":"Crystal allows you to bind to existing C libraries without writing a single line in C. Additionally, it provides some conveniences like out and to_unsafe so writing bindings is as painless as possible.","title":"C bindings"},{"location":"syntax_and_semantics/c_bindings/alias.html","text":"alias \u00b6 An alias declaration inside a lib declares a C typedef : lib X alias MyInt = Int32 end Now Int32 and MyInt are interchangeable: lib X alias MyInt = Int32 fun some_fun ( value : MyInt ) end X . some_fun 1 # OK An alias is most useful to avoid writing long types over and over, but also to declare a type based on compile-time flags: lib C {% if flag? ( :x86_64 ) %} alias SizeT = Int64 {% else %} alias SizeT = Int32 {% end %} fun memcmp ( p1 : Void * , p2 : Void * , size : C :: SizeT ) : Int32 end Refer to the type grammar for the notation used in alias types.","title":"alias"},{"location":"syntax_and_semantics/c_bindings/alias.html#alias","text":"An alias declaration inside a lib declares a C typedef : lib X alias MyInt = Int32 end Now Int32 and MyInt are interchangeable: lib X alias MyInt = Int32 fun some_fun ( value : MyInt ) end X . some_fun 1 # OK An alias is most useful to avoid writing long types over and over, but also to declare a type based on compile-time flags: lib C {% if flag? ( :x86_64 ) %} alias SizeT = Int64 {% else %} alias SizeT = Int32 {% end %} fun memcmp ( p1 : Void * , p2 : Void * , size : C :: SizeT ) : Int32 end Refer to the type grammar for the notation used in alias types.","title":"alias"},{"location":"syntax_and_semantics/c_bindings/callbacks.html","text":"Callbacks \u00b6 You can use function types in C declarations: lib X # In C: # # void callback(int (*f)(int)); fun callback ( f : Int32 -> Int32 ) end Then you can pass a function (a Proc ) like this: f = -> ( x : Int32 ) { x + 1 } X . callback ( f ) If you define the function inline in the same call you can omit the parameter types, the compiler will add the types for you based on the fun signature: X . callback -> ( x ) { x + 1 } Note, however, that functions passed to C can't form closures. If the compiler detects at compile-time that a closure is being passed, an error will be issued: y = 2 X . callback -> ( x ) { x + y } # Error: can't send closure to C function If the compiler can't detect this at compile-time, an exception will be raised at runtime. Refer to the type grammar for the notation used in callbacks and procs types. If you want to pass NULL instead of a callback, just pass nil : # Same as callback(NULL) in C X . callback nil Passing a closure to a C function \u00b6 Most of the time a C function that allows setting a callback also provides a parameter for custom data. This custom data is then sent as an argument to the callback. For example, suppose a C function that invokes a callback at every tick, passing that tick: lib LibTicker fun on_tick ( callback : ( Int32 , Void * -> ), data : Void * ) end To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it. module Ticker # The callback for the user doesn't have a Void* @@box : Pointer ( Void )? def self . on_tick ( & callback : Int32 -> ) # Since Proc is a {Void*, Void*}, we can't turn that into a Void*, so we # \"box\" it: we allocate memory and store the Proc there boxed_data = Box . box ( callback ) # We must save this in Crystal-land so the GC doesn't collect it (*) @@box = boxed_data # We pass a callback that doesn't form a closure, and pass the boxed_data as # the callback data LibTicker . on_tick ( -> ( tick , data ) { # Now we turn data back into the Proc, using Box.unbox data_as_callback = Box ( typeof ( callback )) . unbox ( data ) # And finally invoke the user's callback data_as_callback . call ( tick ) }, boxed_data ) end end Ticker . on_tick do | tick | puts tick end Note that we save the boxed callback in @@box . The reason is that if we don't do it, and our code doesn't reference it anymore, the GC will collect it. The C library will of course store the callback, but Crystal's GC has no way of knowing that. Raises annotation \u00b6 If a C function executes a user-provided callback that might raise, it must be annotated with the @[Raises] annotation. The compiler infers this annotation for a method if it invokes a method that is marked as @[Raises] or raises (recursively). However, some C functions accept callbacks to be executed by other C functions. For example, suppose a fictitious library: lib LibFoo fun store_callback ( callback : -> ) fun execute_callback end LibFoo . store_callback -> { raise \"OH NO!\" } LibFoo . execute_callback If the callback passed to store_callback raises, then execute_callback will raise. However, the compiler doesn't know that execute_callback can potentially raise because it is not marked as @[Raises] and the compiler has no way to figure this out. In these cases you have to manually mark such functions: lib LibFoo fun store_callback ( callback : -> ) @[ Raises ] fun execute_callback end If you don't mark them, begin/rescue blocks that surround this function's calls won't work as expected.","title":"Callbacks"},{"location":"syntax_and_semantics/c_bindings/callbacks.html#callbacks","text":"You can use function types in C declarations: lib X # In C: # # void callback(int (*f)(int)); fun callback ( f : Int32 -> Int32 ) end Then you can pass a function (a Proc ) like this: f = -> ( x : Int32 ) { x + 1 } X . callback ( f ) If you define the function inline in the same call you can omit the parameter types, the compiler will add the types for you based on the fun signature: X . callback -> ( x ) { x + 1 } Note, however, that functions passed to C can't form closures. If the compiler detects at compile-time that a closure is being passed, an error will be issued: y = 2 X . callback -> ( x ) { x + y } # Error: can't send closure to C function If the compiler can't detect this at compile-time, an exception will be raised at runtime. Refer to the type grammar for the notation used in callbacks and procs types. If you want to pass NULL instead of a callback, just pass nil : # Same as callback(NULL) in C X . callback nil","title":"Callbacks"},{"location":"syntax_and_semantics/c_bindings/callbacks.html#passing-a-closure-to-a-c-function","text":"Most of the time a C function that allows setting a callback also provides a parameter for custom data. This custom data is then sent as an argument to the callback. For example, suppose a C function that invokes a callback at every tick, passing that tick: lib LibTicker fun on_tick ( callback : ( Int32 , Void * -> ), data : Void * ) end To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it. module Ticker # The callback for the user doesn't have a Void* @@box : Pointer ( Void )? def self . on_tick ( & callback : Int32 -> ) # Since Proc is a {Void*, Void*}, we can't turn that into a Void*, so we # \"box\" it: we allocate memory and store the Proc there boxed_data = Box . box ( callback ) # We must save this in Crystal-land so the GC doesn't collect it (*) @@box = boxed_data # We pass a callback that doesn't form a closure, and pass the boxed_data as # the callback data LibTicker . on_tick ( -> ( tick , data ) { # Now we turn data back into the Proc, using Box.unbox data_as_callback = Box ( typeof ( callback )) . unbox ( data ) # And finally invoke the user's callback data_as_callback . call ( tick ) }, boxed_data ) end end Ticker . on_tick do | tick | puts tick end Note that we save the boxed callback in @@box . The reason is that if we don't do it, and our code doesn't reference it anymore, the GC will collect it. The C library will of course store the callback, but Crystal's GC has no way of knowing that.","title":"Passing a closure to a C function"},{"location":"syntax_and_semantics/c_bindings/callbacks.html#raises-annotation","text":"If a C function executes a user-provided callback that might raise, it must be annotated with the @[Raises] annotation. The compiler infers this annotation for a method if it invokes a method that is marked as @[Raises] or raises (recursively). However, some C functions accept callbacks to be executed by other C functions. For example, suppose a fictitious library: lib LibFoo fun store_callback ( callback : -> ) fun execute_callback end LibFoo . store_callback -> { raise \"OH NO!\" } LibFoo . execute_callback If the callback passed to store_callback raises, then execute_callback will raise. However, the compiler doesn't know that execute_callback can potentially raise because it is not marked as @[Raises] and the compiler has no way to figure this out. In these cases you have to manually mark such functions: lib LibFoo fun store_callback ( callback : -> ) @[ Raises ] fun execute_callback end If you don't mark them, begin/rescue blocks that surround this function's calls won't work as expected.","title":"Raises annotation"},{"location":"syntax_and_semantics/c_bindings/constants.html","text":"Constants \u00b6 You can also declare constants inside a lib declaration: @[ Link ( \"pcre\" ) ] lib PCRE INFO_CAPTURECOUNT = 2 end PCRE :: INFO_CAPTURECOUNT # => 2","title":"Constants"},{"location":"syntax_and_semantics/c_bindings/constants.html#constants","text":"You can also declare constants inside a lib declaration: @[ Link ( \"pcre\" ) ] lib PCRE INFO_CAPTURECOUNT = 2 end PCRE :: INFO_CAPTURECOUNT # => 2","title":"Constants"},{"location":"syntax_and_semantics/c_bindings/enum.html","text":"enum \u00b6 An enum declaration inside a lib declares a C enum: lib X # In C: # # enum SomeEnum { # Zero, # One, # Two, # Three, # }; enum SomeEnum Zero One Two Three end end As in C, the first member of the enum has a value of zero and each successive value is incremented by one. To use a value: X :: SomeEnum :: One # => One You can specify the value of a member: lib X enum SomeEnum Ten = 10 Twenty = 10 * 2 ThirtyTwo = 1 << 5 end end As you can see, some basic math is allowed for a member value: + , - , * , / , & , | , << , >> and % . The type of an enum member is Int32 by default, even if you specify a different type in a constant value: lib X enum SomeEnum A = 1_u32 end end X :: SomeEnum # => 1_i32 However, you can change this default type: lib X enum SomeEnum : Int8 Zero Two = 2 end end X :: SomeEnum :: Zero # => 0_i8 X :: SomeEnum :: Two # => 2_i8 You can use an enum as a type in a fun parameter or struct or union members: lib X enum SomeEnum One Two end fun some_fun ( value : SomeEnum ) end","title":"enum"},{"location":"syntax_and_semantics/c_bindings/enum.html#enum","text":"An enum declaration inside a lib declares a C enum: lib X # In C: # # enum SomeEnum { # Zero, # One, # Two, # Three, # }; enum SomeEnum Zero One Two Three end end As in C, the first member of the enum has a value of zero and each successive value is incremented by one. To use a value: X :: SomeEnum :: One # => One You can specify the value of a member: lib X enum SomeEnum Ten = 10 Twenty = 10 * 2 ThirtyTwo = 1 << 5 end end As you can see, some basic math is allowed for a member value: + , - , * , / , & , | , << , >> and % . The type of an enum member is Int32 by default, even if you specify a different type in a constant value: lib X enum SomeEnum A = 1_u32 end end X :: SomeEnum # => 1_i32 However, you can change this default type: lib X enum SomeEnum : Int8 Zero Two = 2 end end X :: SomeEnum :: Zero # => 0_i8 X :: SomeEnum :: Two # => 2_i8 You can use an enum as a type in a fun parameter or struct or union members: lib X enum SomeEnum One Two end fun some_fun ( value : SomeEnum ) end","title":"enum"},{"location":"syntax_and_semantics/c_bindings/fun.html","text":"fun \u00b6 A fun declaration inside a lib binds to a C function. lib C # In C: double cos(double x) fun cos ( value : Float64 ) : Float64 end Once you bind it, the function is available inside the C type as if it was a class method: C . cos ( 1.5 ) # => 0.0707372 You can omit the parentheses if the function doesn't have parameters (and omit them in the call as well): lib C fun getch : Int32 end C . getch If the return type is void you can omit it: lib C fun srand ( seed : UInt32 ) end C . srand ( 1_u32 ) You can bind to variadic functions: lib X fun variadic ( value : Int32 , ... ) : Int32 end X . variadic ( 1 , 2 , 3 , 4 ) Note that there are no implicit conversions (except to_unsafe , which is explained later) when invoking a C function: you must pass the exact type that is expected. For integers and floats you can use the various to_... methods. Function names \u00b6 Function names in a lib definition can start with an upper case letter. That's different from methods and function definitions outside a lib , which must start with a lower case letter. Function names in Crystal can be different from the C name. The following example shows how to bind the C function name SDL_Init as LibSDL.init in Crystal. lib LibSDL fun init = SDL_Init ( flags : UInt32 ) : Int32 end The C name can be put in quotes to be able to write a name that is not a valid identifier: lib LLVMIntrinsics fun ceil_f32 = \"llvm.ceil.f32\" ( value : Float32 ) : Float32 end This can also be used to give shorter, nicer names to C functions, as these tend to be long and are usually prefixed with the library name. Types in C Bindings \u00b6 The valid types to use in C bindings are: Primitive types ( Int8 , ..., Int64 , UInt8 , ..., UInt64 , Float32 , Float64 ) Pointer types ( Pointer(Int32) , which can also be written as Int32* ) Static arrays ( StaticArray(Int32, 8) , which can also be written as Int32[8] ) Function types ( Function(Int32, Int32) , which can also be written as Int32 -> Int32 ) Other struct , union , enum , type or alias declared previously. Void : the absence of a return value. NoReturn : similar to Void , but the compiler understands that no code can be executed after that invocation. Crystal structs marked with the @[Extern] annotation Refer to the type grammar for the notation used in fun types. The standard library defines the LibC lib with aliases for common C types, like int , short , size_t . Use them in bindings like this: lib MyLib fun my_fun ( some_size : LibC :: SizeT ) end Note The C char type is UInt8 in Crystal, so a char* or a const char* is UInt8* . The Char type in Crystal is a unicode codepoint so it is represented by four bytes, making it similar to an Int32 , not to an UInt8 . There's also the alias LibC::Char if in doubt.","title":"fun"},{"location":"syntax_and_semantics/c_bindings/fun.html#fun","text":"A fun declaration inside a lib binds to a C function. lib C # In C: double cos(double x) fun cos ( value : Float64 ) : Float64 end Once you bind it, the function is available inside the C type as if it was a class method: C . cos ( 1.5 ) # => 0.0707372 You can omit the parentheses if the function doesn't have parameters (and omit them in the call as well): lib C fun getch : Int32 end C . getch If the return type is void you can omit it: lib C fun srand ( seed : UInt32 ) end C . srand ( 1_u32 ) You can bind to variadic functions: lib X fun variadic ( value : Int32 , ... ) : Int32 end X . variadic ( 1 , 2 , 3 , 4 ) Note that there are no implicit conversions (except to_unsafe , which is explained later) when invoking a C function: you must pass the exact type that is expected. For integers and floats you can use the various to_... methods.","title":"fun"},{"location":"syntax_and_semantics/c_bindings/fun.html#function-names","text":"Function names in a lib definition can start with an upper case letter. That's different from methods and function definitions outside a lib , which must start with a lower case letter. Function names in Crystal can be different from the C name. The following example shows how to bind the C function name SDL_Init as LibSDL.init in Crystal. lib LibSDL fun init = SDL_Init ( flags : UInt32 ) : Int32 end The C name can be put in quotes to be able to write a name that is not a valid identifier: lib LLVMIntrinsics fun ceil_f32 = \"llvm.ceil.f32\" ( value : Float32 ) : Float32 end This can also be used to give shorter, nicer names to C functions, as these tend to be long and are usually prefixed with the library name.","title":"Function names"},{"location":"syntax_and_semantics/c_bindings/fun.html#types-in-c-bindings","text":"The valid types to use in C bindings are: Primitive types ( Int8 , ..., Int64 , UInt8 , ..., UInt64 , Float32 , Float64 ) Pointer types ( Pointer(Int32) , which can also be written as Int32* ) Static arrays ( StaticArray(Int32, 8) , which can also be written as Int32[8] ) Function types ( Function(Int32, Int32) , which can also be written as Int32 -> Int32 ) Other struct , union , enum , type or alias declared previously. Void : the absence of a return value. NoReturn : similar to Void , but the compiler understands that no code can be executed after that invocation. Crystal structs marked with the @[Extern] annotation Refer to the type grammar for the notation used in fun types. The standard library defines the LibC lib with aliases for common C types, like int , short , size_t . Use them in bindings like this: lib MyLib fun my_fun ( some_size : LibC :: SizeT ) end Note The C char type is UInt8 in Crystal, so a char* or a const char* is UInt8* . The Char type in Crystal is a unicode codepoint so it is represented by four bytes, making it similar to an Int32 , not to an UInt8 . There's also the alias LibC::Char if in doubt.","title":"Types in C Bindings"},{"location":"syntax_and_semantics/c_bindings/lib.html","text":"lib \u00b6 A lib declaration groups C functions and types that belong to a library. @[ Link ( \"pcre\" ) ] lib LibPCRE end Although not enforced by the compiler, a lib 's name usually starts with Lib . Attributes are used to pass flags to the linker to find external libraries: @[Link(\"pcre\")] will pass -lpcre to the linker, but the compiler will first try to use pkg-config . @[Link(ldflags: \"...\")] will pass those flags directly to the linker, without modification. For example: @[Link(ldflags: \"-lpcre\")] . A common technique is to use backticks to execute commands: @[Link(ldflags: \"`pkg-config libpcre --libs`\")] . @[Link(framework: \"Cocoa\")] will pass -framework Cocoa to the linker (only useful in macOS). Attributes can be omitted if the library is implicitly linked, as in the case of libc.","title":"lib"},{"location":"syntax_and_semantics/c_bindings/lib.html#lib","text":"A lib declaration groups C functions and types that belong to a library. @[ Link ( \"pcre\" ) ] lib LibPCRE end Although not enforced by the compiler, a lib 's name usually starts with Lib . Attributes are used to pass flags to the linker to find external libraries: @[Link(\"pcre\")] will pass -lpcre to the linker, but the compiler will first try to use pkg-config . @[Link(ldflags: \"...\")] will pass those flags directly to the linker, without modification. For example: @[Link(ldflags: \"-lpcre\")] . A common technique is to use backticks to execute commands: @[Link(ldflags: \"`pkg-config libpcre --libs`\")] . @[Link(framework: \"Cocoa\")] will pass -framework Cocoa to the linker (only useful in macOS). Attributes can be omitted if the library is implicitly linked, as in the case of libc.","title":"lib"},{"location":"syntax_and_semantics/c_bindings/out.html","text":"out \u00b6 Consider the waitpid function: lib C fun waitpid ( pid : Int32 , status_ptr : Int32 * , options : Int32 ) : Int32 end The documentation of the function says: The status information from the child process is stored in the object that status_ptr points to, unless status_ptr is a null pointer. We can use this function like this: status_ptr = uninitialized Int32 C . waitpid ( pid , pointerof ( status_ptr ), options ) In this way we pass a pointer of status_ptr to the function for it to fill its value. There's a simpler way to write the above by using an out parameter: C . waitpid ( pid , out status_ptr , options ) The compiler will automatically declare a status_ptr variable of type Int32 , because the parameter's type is Int32* . This will work for any fun parameter, as long as its type is a pointer (and, of course, as long as the function does fill the value the pointer is pointing to).","title":"out"},{"location":"syntax_and_semantics/c_bindings/out.html#out","text":"Consider the waitpid function: lib C fun waitpid ( pid : Int32 , status_ptr : Int32 * , options : Int32 ) : Int32 end The documentation of the function says: The status information from the child process is stored in the object that status_ptr points to, unless status_ptr is a null pointer. We can use this function like this: status_ptr = uninitialized Int32 C . waitpid ( pid , pointerof ( status_ptr ), options ) In this way we pass a pointer of status_ptr to the function for it to fill its value. There's a simpler way to write the above by using an out parameter: C . waitpid ( pid , out status_ptr , options ) The compiler will automatically declare a status_ptr variable of type Int32 , because the parameter's type is Int32* . This will work for any fun parameter, as long as its type is a pointer (and, of course, as long as the function does fill the value the pointer is pointing to).","title":"out"},{"location":"syntax_and_semantics/c_bindings/struct.html","text":"struct \u00b6 A struct declaration inside a lib declares a C struct. lib C # In C: # # struct TimeZone { # int minutes_west; # int dst_time; # }; struct TimeZone minutes_west : Int32 dst_time : Int32 end end You can also specify many fields of the same type: lib C struct TimeZone minutes_west , dst_time : Int32 end end Recursive structs work just like you expect them to: lib C struct LinkedListNode prev , _next : LinkedListNode * end struct LinkedList head : LinkedListNode * end end To create an instance of a struct use new : tz = C :: TimeZone . new This allocates the struct on the stack. A C struct starts with all its fields set to \"zero\": integers and floats start at zero, pointers start with an address of zero, etc. To avoid this initialization you can use uninitialized : tz = uninitialized C :: TimeZone tz . minutes_west # => some garbage value You can set and get its properties: tz = C :: TimeZone . new tz . minutes_west = 1 tz . minutes_west # => 1 If the assigned value is not exactly the same as the property's type, to_unsafe will be tried. You can also initialize some fields with a syntax similar to named arguments : tz = C :: TimeZone . new minutes_west : 1 , dst_time : 2 tz . minutes_west # => 1 tz . dst_time # => 2 A C struct is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method: def change_it ( tz ) tz . minutes_west = 1 end tz = C :: TimeZone . new change_it tz tz . minutes_west # => 0 Refer to the type grammar for the notation used in struct field types.","title":"struct"},{"location":"syntax_and_semantics/c_bindings/struct.html#struct","text":"A struct declaration inside a lib declares a C struct. lib C # In C: # # struct TimeZone { # int minutes_west; # int dst_time; # }; struct TimeZone minutes_west : Int32 dst_time : Int32 end end You can also specify many fields of the same type: lib C struct TimeZone minutes_west , dst_time : Int32 end end Recursive structs work just like you expect them to: lib C struct LinkedListNode prev , _next : LinkedListNode * end struct LinkedList head : LinkedListNode * end end To create an instance of a struct use new : tz = C :: TimeZone . new This allocates the struct on the stack. A C struct starts with all its fields set to \"zero\": integers and floats start at zero, pointers start with an address of zero, etc. To avoid this initialization you can use uninitialized : tz = uninitialized C :: TimeZone tz . minutes_west # => some garbage value You can set and get its properties: tz = C :: TimeZone . new tz . minutes_west = 1 tz . minutes_west # => 1 If the assigned value is not exactly the same as the property's type, to_unsafe will be tried. You can also initialize some fields with a syntax similar to named arguments : tz = C :: TimeZone . new minutes_west : 1 , dst_time : 2 tz . minutes_west # => 1 tz . dst_time # => 2 A C struct is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method: def change_it ( tz ) tz . minutes_west = 1 end tz = C :: TimeZone . new change_it tz tz . minutes_west # => 0 Refer to the type grammar for the notation used in struct field types.","title":"struct"},{"location":"syntax_and_semantics/c_bindings/to_unsafe.html","text":"to_unsafe \u00b6 If a type defines a to_unsafe method, when passing it to C the value returned by this method will be passed. For example: lib C fun exit ( status : Int32 ) : NoReturn end class IntWrapper def initialize ( @value ) end def to_unsafe @value end end wrapper = IntWrapper . new ( 1 ) C . exit ( wrapper ) # wrapper.to_unsafe is passed to C function which has type Int32 This is very useful for defining wrappers of C types without having to explicitly transform them to their wrapped values. For example, the String class implements to_unsafe to return UInt8* : lib C fun printf ( format : UInt8 * , ... ) : Int32 end a = 1 b = 2 C . printf \"%d + %d = %d \\n \" , a , b , a + b","title":"to_unsafe"},{"location":"syntax_and_semantics/c_bindings/to_unsafe.html#to_unsafe","text":"If a type defines a to_unsafe method, when passing it to C the value returned by this method will be passed. For example: lib C fun exit ( status : Int32 ) : NoReturn end class IntWrapper def initialize ( @value ) end def to_unsafe @value end end wrapper = IntWrapper . new ( 1 ) C . exit ( wrapper ) # wrapper.to_unsafe is passed to C function which has type Int32 This is very useful for defining wrappers of C types without having to explicitly transform them to their wrapped values. For example, the String class implements to_unsafe to return UInt8* : lib C fun printf ( format : UInt8 * , ... ) : Int32 end a = 1 b = 2 C . printf \"%d + %d = %d \\n \" , a , b , a + b","title":"to_unsafe"},{"location":"syntax_and_semantics/c_bindings/type.html","text":"type \u00b6 A type declaration inside a lib declares a kind of C typedef , but stronger: lib X type MyInt = Int32 end Unlike C, Int32 and MyInt are not interchangeable: lib X type MyInt = Int32 fun some_fun ( value : MyInt ) end X . some_fun 1 # Error: argument 'value' of 'X#some_fun' must be X::MyInt, not Int32 Thus, a type declaration is useful for opaque types that are created by the C library you are wrapping. An example of this is the C FILE type, which you can obtain with fopen . Refer to the type grammar for the notation used in typedef types.","title":"type"},{"location":"syntax_and_semantics/c_bindings/type.html#type","text":"A type declaration inside a lib declares a kind of C typedef , but stronger: lib X type MyInt = Int32 end Unlike C, Int32 and MyInt are not interchangeable: lib X type MyInt = Int32 fun some_fun ( value : MyInt ) end X . some_fun 1 # Error: argument 'value' of 'X#some_fun' must be X::MyInt, not Int32 Thus, a type declaration is useful for opaque types that are created by the C library you are wrapping. An example of this is the C FILE type, which you can obtain with fopen . Refer to the type grammar for the notation used in typedef types.","title":"type"},{"location":"syntax_and_semantics/c_bindings/union.html","text":"union \u00b6 A union declaration inside a lib declares a C union: lib U # In C: # # union IntOrFloat { # int some_int; # double some_float; # }; union IntOrFloat some_int : Int32 some_float : Float64 end end To create an instance of a union use new : value = U :: IntOrFloat . new This allocates the union on the stack. A C union starts with all its fields set to \"zero\": integers and floats start at zero, pointers start with an address of zero, etc. To avoid this initialization you can use uninitialized : value = uninitialized U :: IntOrFloat value . some_int # => some garbage value You can set and get its properties: value = U :: IntOrFloat . new value . some_int = 1 value . some_int # => 1 value . some_float # => 4.94066e-324 If the assigned value is not exactly the same as the property's type, to_unsafe will be tried. A C union is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method: def change_it ( value ) value . some_int = 1 end value = U :: IntOrFloat . new change_it value value . some_int # => 0 Refer to the type grammar for the notation used in union field types.","title":"union"},{"location":"syntax_and_semantics/c_bindings/union.html#union","text":"A union declaration inside a lib declares a C union: lib U # In C: # # union IntOrFloat { # int some_int; # double some_float; # }; union IntOrFloat some_int : Int32 some_float : Float64 end end To create an instance of a union use new : value = U :: IntOrFloat . new This allocates the union on the stack. A C union starts with all its fields set to \"zero\": integers and floats start at zero, pointers start with an address of zero, etc. To avoid this initialization you can use uninitialized : value = uninitialized U :: IntOrFloat value . some_int # => some garbage value You can set and get its properties: value = U :: IntOrFloat . new value . some_int = 1 value . some_int # => 1 value . some_float # => 4.94066e-324 If the assigned value is not exactly the same as the property's type, to_unsafe will be tried. A C union is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method: def change_it ( value ) value . some_int = 1 end value = U :: IntOrFloat . new change_it value value . some_int # => 0 Refer to the type grammar for the notation used in union field types.","title":"union"},{"location":"syntax_and_semantics/c_bindings/variables.html","text":"Variables \u00b6 Variables exposed by a C library can be declared inside a lib declaration using a global-variable-like declaration: lib C $errno : Int32 end Then it can be get and set: C . errno # => some value C . errno = 0 C . errno # => 0 A variable can be marked as thread local with an annotation: lib C @[ ThreadLocal ] $errno : Int32 end Refer to the type grammar for the notation used in external variables types.","title":"Variables"},{"location":"syntax_and_semantics/c_bindings/variables.html#variables","text":"Variables exposed by a C library can be declared inside a lib declaration using a global-variable-like declaration: lib C $errno : Int32 end Then it can be get and set: C . errno # => some value C . errno = 0 C . errno # => 0 A variable can be marked as thread local with an annotation: lib C @[ ThreadLocal ] $errno : Int32 end Refer to the type grammar for the notation used in external variables types.","title":"Variables"},{"location":"syntax_and_semantics/literals/index.html","text":"Literals \u00b6 Crystal provides several literals for creating values of some basic types. Literal Sample values Nil nil Bool true , false Integers 18 , -12 , 19_i64 , 14_u32 , 64_u8 Floats 1.0 , 1.0_f32 , 1e10 , -0.5 Char 'a' , '\\n' , '\u3042' String \"foo\\tbar\" , %(\"\u3042\") , %q(foo #{foo}) Symbol :symbol , :\"foo bar\" Array [1, 2, 3] , [1, 2, 3] of Int32 , %w(one two three) Array-like Set{1, 2, 3} Hash {\"foo\" => 2} , {} of String => Int32 Hash-like MyType{\"foo\" => \"bar\"} Range 1..9 , 1...10 , 0..var Regex /(foo)?bar/ , /foo #{foo}/imx , %r(foo/) Tuple {1, \"hello\", 'x'} NamedTuple {name: \"Crystal\", year: 2011} , {\"this is a key\": 1} Proc ->(x : Int32, y : Int32) { x + y } Command `echo foo` , %x(echo foo)","title":"Literals"},{"location":"syntax_and_semantics/literals/index.html#literals","text":"Crystal provides several literals for creating values of some basic types. Literal Sample values Nil nil Bool true , false Integers 18 , -12 , 19_i64 , 14_u32 , 64_u8 Floats 1.0 , 1.0_f32 , 1e10 , -0.5 Char 'a' , '\\n' , '\u3042' String \"foo\\tbar\" , %(\"\u3042\") , %q(foo #{foo}) Symbol :symbol , :\"foo bar\" Array [1, 2, 3] , [1, 2, 3] of Int32 , %w(one two three) Array-like Set{1, 2, 3} Hash {\"foo\" => 2} , {} of String => Int32 Hash-like MyType{\"foo\" => \"bar\"} Range 1..9 , 1...10 , 0..var Regex /(foo)?bar/ , /foo #{foo}/imx , %r(foo/) Tuple {1, \"hello\", 'x'} NamedTuple {name: \"Crystal\", year: 2011} , {\"this is a key\": 1} Proc ->(x : Int32, y : Int32) { x + y } Command `echo foo` , %x(echo foo)","title":"Literals"},{"location":"syntax_and_semantics/literals/array.html","text":"Array \u00b6 An Array is an ordered and integer-indexed generic collection of elements of a specific type T . Arrays are typically created with an array literal denoted by square brackets ( [] ) and individual elements separated by a comma ( , ). [ 1 , 2 , 3 ] Generic Type Argument \u00b6 The array's generic type argument T is inferred from the types of the elements inside the literal. When all elements of the array have the same type, T equals to that. Otherwise it will be a union of all element types. [ 1 , 2 , 3 ] # => Array(Int32) [ 1 , \"hello\" , 'x' ] # => Array(Int32 | String | Char) An explicit type can be specified by immediately following the closing bracket with of and a type, each separated by whitespace. This overwrites the inferred type and can be used for example to create an array that holds only some types initially but can accept other types later. array_of_numbers = [ 1 , 2 , 3 ] of Float64 | Int32 # => Array(Float64 | Int32) array_of_numbers << 0.5 # => [1, 2, 3, 0.5] array_of_int_or_string = [ 1 , 2 , 3 ] of Int32 | String # => Array(Int32 | String) array_of_int_or_string << \"foo\" # => [1, 2, 3, \"foo\"] Empty array literals always need a type specification: [] of Int32 # => Array(Int32).new Percent Array Literals \u00b6 Arrays of strings and arrays of symbols can be created with percent array literals: %w(one two three) # => [\"one\", \"two\", \"three\"] %i(one two three) # => [:one, :two, :three] Array-like Type Literal \u00b6 Crystal supports an additional literal for arrays and array-like types. It consists of the name of the type followed by a list of elements enclosed in curly braces ( {} ) and individual elements separated by a comma ( , ). Array { 1 , 2 , 3 } This literal can be used with any type as long as it has an argless constructor and responds to << . IO :: Memory { 1 , 2 , 3 } Set { 1 , 2 , 3 } For a non-generic type like IO::Memory , this is equivalent to: array_like = IO :: Memory . new array_like << 1 array_like << 2 array_like << 3 For a generic type like Set , the generic type T is inferred from the types of the elements in the same way as with the array literal. The above is equivalent to: array_like = Set ( typeof ( 1 , 2 , 3 )) . new array_like << 1 array_like << 2 array_like << 3 The type arguments can be explicitly specified as part of the type name: Set ( Int32 ){ 1 , 2 , 3 }","title":"Array"},{"location":"syntax_and_semantics/literals/array.html#array","text":"An Array is an ordered and integer-indexed generic collection of elements of a specific type T . Arrays are typically created with an array literal denoted by square brackets ( [] ) and individual elements separated by a comma ( , ). [ 1 , 2 , 3 ]","title":"Array"},{"location":"syntax_and_semantics/literals/array.html#generic-type-argument","text":"The array's generic type argument T is inferred from the types of the elements inside the literal. When all elements of the array have the same type, T equals to that. Otherwise it will be a union of all element types. [ 1 , 2 , 3 ] # => Array(Int32) [ 1 , \"hello\" , 'x' ] # => Array(Int32 | String | Char) An explicit type can be specified by immediately following the closing bracket with of and a type, each separated by whitespace. This overwrites the inferred type and can be used for example to create an array that holds only some types initially but can accept other types later. array_of_numbers = [ 1 , 2 , 3 ] of Float64 | Int32 # => Array(Float64 | Int32) array_of_numbers << 0.5 # => [1, 2, 3, 0.5] array_of_int_or_string = [ 1 , 2 , 3 ] of Int32 | String # => Array(Int32 | String) array_of_int_or_string << \"foo\" # => [1, 2, 3, \"foo\"] Empty array literals always need a type specification: [] of Int32 # => Array(Int32).new","title":"Generic Type Argument"},{"location":"syntax_and_semantics/literals/array.html#percent-array-literals","text":"Arrays of strings and arrays of symbols can be created with percent array literals: %w(one two three) # => [\"one\", \"two\", \"three\"] %i(one two three) # => [:one, :two, :three]","title":"Percent Array Literals"},{"location":"syntax_and_semantics/literals/array.html#array-like-type-literal","text":"Crystal supports an additional literal for arrays and array-like types. It consists of the name of the type followed by a list of elements enclosed in curly braces ( {} ) and individual elements separated by a comma ( , ). Array { 1 , 2 , 3 } This literal can be used with any type as long as it has an argless constructor and responds to << . IO :: Memory { 1 , 2 , 3 } Set { 1 , 2 , 3 } For a non-generic type like IO::Memory , this is equivalent to: array_like = IO :: Memory . new array_like << 1 array_like << 2 array_like << 3 For a generic type like Set , the generic type T is inferred from the types of the elements in the same way as with the array literal. The above is equivalent to: array_like = Set ( typeof ( 1 , 2 , 3 )) . new array_like << 1 array_like << 2 array_like << 3 The type arguments can be explicitly specified as part of the type name: Set ( Int32 ){ 1 , 2 , 3 }","title":"Array-like Type Literal"},{"location":"syntax_and_semantics/literals/bool.html","text":"Bool \u00b6 Bool has only two possible values: true and false . They are constructed using the following literals: true # A Bool that is true false # A Bool that is false","title":"Bool"},{"location":"syntax_and_semantics/literals/bool.html#bool","text":"Bool has only two possible values: true and false . They are constructed using the following literals: true # A Bool that is true false # A Bool that is false","title":"Bool"},{"location":"syntax_and_semantics/literals/char.html","text":"Char \u00b6 A Char represents a 32-bit Unicode code point . It is typically created with a char literal by enclosing an UTF-8 character in single quotes. 'a' 'z' '0' '_' '\u3042' A backslash denotes a special character, which can either be a named escape sequence or a numerical representation of a unicode codepoint. Available escape sequences: '\\'' # single quote '\\\\' # backslash '\\a' # alert '\\b' # backspace '\\e' # escape '\\f' # form feed '\\n' # newline '\\r' # carriage return '\\t' # tab '\\v' # vertical tab '\\uFFFF' # hexadecimal unicode character '\\u{10FFFF}' # hexadecimal unicode character A backslash followed by a u denotes a unicode codepoint. It can either be followed by exactly four hexadecimal characters representing the unicode bytes ( \\u0000 to \\uFFFF ) or a number of one to six hexadecimal characters wrapped in curly braces ( \\u{0} to \\u{10FFFF} . '\\u0041' # => 'A' '\\u{41}' # => 'A' '\\u{1F52E}' # => '&#x1F52E;'","title":"Char"},{"location":"syntax_and_semantics/literals/char.html#char","text":"A Char represents a 32-bit Unicode code point . It is typically created with a char literal by enclosing an UTF-8 character in single quotes. 'a' 'z' '0' '_' '\u3042' A backslash denotes a special character, which can either be a named escape sequence or a numerical representation of a unicode codepoint. Available escape sequences: '\\'' # single quote '\\\\' # backslash '\\a' # alert '\\b' # backspace '\\e' # escape '\\f' # form feed '\\n' # newline '\\r' # carriage return '\\t' # tab '\\v' # vertical tab '\\uFFFF' # hexadecimal unicode character '\\u{10FFFF}' # hexadecimal unicode character A backslash followed by a u denotes a unicode codepoint. It can either be followed by exactly four hexadecimal characters representing the unicode bytes ( \\u0000 to \\uFFFF ) or a number of one to six hexadecimal characters wrapped in curly braces ( \\u{0} to \\u{10FFFF} . '\\u0041' # => 'A' '\\u{41}' # => 'A' '\\u{1F52E}' # => '&#x1F52E;'","title":"Char"},{"location":"syntax_and_semantics/literals/command.html","text":"Command literal \u00b6 A command literal is a string delimited by backticks ` or a %x percent literal. It will be substituted at runtime by the captured output from executing the string in a subshell. The same escaping and interpolation rules apply as for regular strings. Similar to percent string literals, valid delimiters for %x are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the string escapes the next end delimiter. The special variable $? holds the exit status of the command as a Process::Status . It is only available in the same scope as the command literal. `echo foo` # => \"foo\" $? . success? # => true Internally, the compiler rewrites command literals to calls to the top-level method `() with a string literal containing the command as argument: `echo #{argument}` and %x(echo #{argument}) are rewritten to `(\"echo #{argument}\") . Security concerns \u00b6 While command literals may prove useful for simple script-like tools, special caution is advised when interpolating user input because it may easily lead to command injection. user_input = \"hello; rm -rf *\" `echo #{ user_input } ` This command will write hello and subsequently delete all files and folders in the current working directory. To avoid this, command literals should generally not be used with interpolated user input. Process from the standard library offers a safe way to provide user input as command arguments: user_input = \"hello; rm -rf *\" process = Process . new ( \"echo\" , [ user_input ] , output : Process :: Redirect :: Pipe ) process . output . gets_to_end # => \"hello; rm -rf *\" process . wait . success? # => true","title":"Command"},{"location":"syntax_and_semantics/literals/command.html#command-literal","text":"A command literal is a string delimited by backticks ` or a %x percent literal. It will be substituted at runtime by the captured output from executing the string in a subshell. The same escaping and interpolation rules apply as for regular strings. Similar to percent string literals, valid delimiters for %x are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the string escapes the next end delimiter. The special variable $? holds the exit status of the command as a Process::Status . It is only available in the same scope as the command literal. `echo foo` # => \"foo\" $? . success? # => true Internally, the compiler rewrites command literals to calls to the top-level method `() with a string literal containing the command as argument: `echo #{argument}` and %x(echo #{argument}) are rewritten to `(\"echo #{argument}\") .","title":"Command literal"},{"location":"syntax_and_semantics/literals/command.html#security-concerns","text":"While command literals may prove useful for simple script-like tools, special caution is advised when interpolating user input because it may easily lead to command injection. user_input = \"hello; rm -rf *\" `echo #{ user_input } ` This command will write hello and subsequently delete all files and folders in the current working directory. To avoid this, command literals should generally not be used with interpolated user input. Process from the standard library offers a safe way to provide user input as command arguments: user_input = \"hello; rm -rf *\" process = Process . new ( \"echo\" , [ user_input ] , output : Process :: Redirect :: Pipe ) process . output . gets_to_end # => \"hello; rm -rf *\" process . wait . success? # => true","title":"Security concerns"},{"location":"syntax_and_semantics/literals/floats.html","text":"Floats \u00b6 There are two floating point types, Float32 and Float64 , which correspond to the binary32 and binary64 types defined by IEEE. A floating point literal is an optional + or - sign, followed by a sequence of numbers or underscores, followed by a dot, followed by numbers or underscores, followed by an optional exponent suffix, followed by an optional type suffix. If no suffix is present, the literal's type is Float64 . 1.0 # Float64 1.0_f32 # Float32 1_f32 # Float32 1e10 # Float64 1.5e10 # Float64 1.5e-7 # Float64 + 1.3 # Float64 - 0.5 # Float64 The underscore _ before the suffix is optional. Underscores can be used to make some numbers more readable: 1_000_000.111_111 # a lot more readable than 1000000.111111, yet functionally the same","title":"Floats"},{"location":"syntax_and_semantics/literals/floats.html#floats","text":"There are two floating point types, Float32 and Float64 , which correspond to the binary32 and binary64 types defined by IEEE. A floating point literal is an optional + or - sign, followed by a sequence of numbers or underscores, followed by a dot, followed by numbers or underscores, followed by an optional exponent suffix, followed by an optional type suffix. If no suffix is present, the literal's type is Float64 . 1.0 # Float64 1.0_f32 # Float32 1_f32 # Float32 1e10 # Float64 1.5e10 # Float64 1.5e-7 # Float64 + 1.3 # Float64 - 0.5 # Float64 The underscore _ before the suffix is optional. Underscores can be used to make some numbers more readable: 1_000_000.111_111 # a lot more readable than 1000000.111111, yet functionally the same","title":"Floats"},{"location":"syntax_and_semantics/literals/hash.html","text":"Hash \u00b6 A Hash is a generic collection of key-value pairs mapping keys of type K to values of type V . Hashes are typically created with a hash literal denoted by curly braces ( { } ) enclosing a list of pairs using => as delimiter between key and value and separated by commas , . { \"one\" => 1 , \"two\" => 2 } Generic Type Argument \u00b6 The generic type arguments for keys K and values V are inferred from the types of the keys or values inside the literal, respectively. When all have the same type, K / V equals to that. Otherwise it will be a union of all key types or value types respectively. { 1 => 2 , 3 => 4 } # Hash(Int32, Int32) { 1 => 2 , 'a' => 3 } # Hash(Int32 | Char, Int32) Explicit types can be specified by immediately following the closing bracket with of (separated by whitespace), a key type ( K ) followed by => as delimiter and a value type ( V ). This overwrites the inferred types and can be used for example to create a hash that holds only some types initially but can accept other types as well. Empty hash literals always need type specifications: {} of Int32 => Int32 # => Hash(Int32, Int32).new Hash-like Type Literal \u00b6 Crystal supports an additional literal for hashes and hash-like types. It consists of the name of the type followed by a list of comma separated key-value pairs enclosed in curly braces ( {} ). Hash { \"one\" => 1 , \"two\" => 2 } This literal can be used with any type as long as it has an argless constructor and responds to []= . HTTP :: Headers { \"foo\" => \"bar\" } For a non-generic type like HTTP::Headers , this is equivalent to: headers = HTTP :: Headers . new headers [ \"foo\" ] = \"bar\" For a generic type, the generic types are inferred from the types of the keys and values in the same way as with the hash literal. MyHash { \"foo\" => 1 , \"bar\" => \"baz\" } If MyHash is generic, the above is equivalent to this: my_hash = MyHash ( typeof ( \"foo\" , \"bar\" ), typeof ( 1 , \"baz\" )) . new my_hash [ \"foo\" ] = 1 my_hash [ \"bar\" ] = \"baz\" The type arguments can be explicitly specified as part of the type name: MyHash ( String , String | Int32 ){ \"foo\" => \"bar\" }","title":"Hash"},{"location":"syntax_and_semantics/literals/hash.html#hash","text":"A Hash is a generic collection of key-value pairs mapping keys of type K to values of type V . Hashes are typically created with a hash literal denoted by curly braces ( { } ) enclosing a list of pairs using => as delimiter between key and value and separated by commas , . { \"one\" => 1 , \"two\" => 2 }","title":"Hash"},{"location":"syntax_and_semantics/literals/hash.html#generic-type-argument","text":"The generic type arguments for keys K and values V are inferred from the types of the keys or values inside the literal, respectively. When all have the same type, K / V equals to that. Otherwise it will be a union of all key types or value types respectively. { 1 => 2 , 3 => 4 } # Hash(Int32, Int32) { 1 => 2 , 'a' => 3 } # Hash(Int32 | Char, Int32) Explicit types can be specified by immediately following the closing bracket with of (separated by whitespace), a key type ( K ) followed by => as delimiter and a value type ( V ). This overwrites the inferred types and can be used for example to create a hash that holds only some types initially but can accept other types as well. Empty hash literals always need type specifications: {} of Int32 => Int32 # => Hash(Int32, Int32).new","title":"Generic Type Argument"},{"location":"syntax_and_semantics/literals/hash.html#hash-like-type-literal","text":"Crystal supports an additional literal for hashes and hash-like types. It consists of the name of the type followed by a list of comma separated key-value pairs enclosed in curly braces ( {} ). Hash { \"one\" => 1 , \"two\" => 2 } This literal can be used with any type as long as it has an argless constructor and responds to []= . HTTP :: Headers { \"foo\" => \"bar\" } For a non-generic type like HTTP::Headers , this is equivalent to: headers = HTTP :: Headers . new headers [ \"foo\" ] = \"bar\" For a generic type, the generic types are inferred from the types of the keys and values in the same way as with the hash literal. MyHash { \"foo\" => 1 , \"bar\" => \"baz\" } If MyHash is generic, the above is equivalent to this: my_hash = MyHash ( typeof ( \"foo\" , \"bar\" ), typeof ( 1 , \"baz\" )) . new my_hash [ \"foo\" ] = 1 my_hash [ \"bar\" ] = \"baz\" The type arguments can be explicitly specified as part of the type name: MyHash ( String , String | Int32 ){ \"foo\" => \"bar\" }","title":"Hash-like Type Literal"},{"location":"syntax_and_semantics/literals/integers.html","text":"Integers \u00b6 There are four signed integer types, and four unsigned integer types: Type Length Minimum Value Maximum Value Int8 8 -128 127 Int16 16 \u221232,768 32,767 Int32 32 \u22122,147,483,648 2,147,483,647 Int64 64 \u22122 63 2 63 - 1 UInt8 8 0 255 UInt16 16 0 65,535 UInt32 32 0 4,294,967,295 UInt64 64 0 2 64 - 1 An integer literal is an optional + or - sign, followed by a sequence of digits and underscores, optionally followed by a suffix. If no suffix is present, the literal's type is the lowest between Int32 , Int64 and UInt64 in which the number fits: 1 # Int32 1_i8 # Int8 1_i16 # Int16 1_i32 # Int32 1_i64 # Int64 1_u8 # UInt8 1_u16 # UInt16 1_u32 # UInt32 1_u64 # UInt64 + 10 # Int32 - 20 # Int32 2147483648 # Int64 9223372036854775808 # UInt64 The underscore _ before the suffix is optional. Underscores can be used to make some numbers more readable: 1_000_000 # better than 1000000 Binary numbers start with 0b : 0b1101 # == 13 Octal numbers start with a 0o : 0o123 # == 83 Hexadecimal numbers start with 0x : 0xFE012D # == 16646445 0xfe012d # == 16646445","title":"Integers"},{"location":"syntax_and_semantics/literals/integers.html#integers","text":"There are four signed integer types, and four unsigned integer types: Type Length Minimum Value Maximum Value Int8 8 -128 127 Int16 16 \u221232,768 32,767 Int32 32 \u22122,147,483,648 2,147,483,647 Int64 64 \u22122 63 2 63 - 1 UInt8 8 0 255 UInt16 16 0 65,535 UInt32 32 0 4,294,967,295 UInt64 64 0 2 64 - 1 An integer literal is an optional + or - sign, followed by a sequence of digits and underscores, optionally followed by a suffix. If no suffix is present, the literal's type is the lowest between Int32 , Int64 and UInt64 in which the number fits: 1 # Int32 1_i8 # Int8 1_i16 # Int16 1_i32 # Int32 1_i64 # Int64 1_u8 # UInt8 1_u16 # UInt16 1_u32 # UInt32 1_u64 # UInt64 + 10 # Int32 - 20 # Int32 2147483648 # Int64 9223372036854775808 # UInt64 The underscore _ before the suffix is optional. Underscores can be used to make some numbers more readable: 1_000_000 # better than 1000000 Binary numbers start with 0b : 0b1101 # == 13 Octal numbers start with a 0o : 0o123 # == 83 Hexadecimal numbers start with 0x : 0xFE012D # == 16646445 0xfe012d # == 16646445","title":"Integers"},{"location":"syntax_and_semantics/literals/named_tuple.html","text":"NamedTuple \u00b6 A NamedTuple is typically created with a named tuple literal: tuple = { name : \"Crystal\" , year : 2011 } # NamedTuple(name: String, year: Int32) tuple [ :name ] # => \"Crystal\" (String) tuple [ :year ] # => 2011 (Int32) To denote a named tuple type you can write: # The type denoting a named tuple of x: Int32, y: String NamedTuple ( x : Int32 , y : String ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type grammar : # An array of named tuples of x: Int32, y: String Array ({ x : Int32 , y : String }) A named tuple key can also be a string literal: { \"this is a key\" : 1 }","title":"NamedTuple"},{"location":"syntax_and_semantics/literals/named_tuple.html#namedtuple","text":"A NamedTuple is typically created with a named tuple literal: tuple = { name : \"Crystal\" , year : 2011 } # NamedTuple(name: String, year: Int32) tuple [ :name ] # => \"Crystal\" (String) tuple [ :year ] # => 2011 (Int32) To denote a named tuple type you can write: # The type denoting a named tuple of x: Int32, y: String NamedTuple ( x : Int32 , y : String ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type grammar : # An array of named tuples of x: Int32, y: String Array ({ x : Int32 , y : String }) A named tuple key can also be a string literal: { \"this is a key\" : 1 }","title":"NamedTuple"},{"location":"syntax_and_semantics/literals/nil.html","text":"Nil \u00b6 The Nil type is used to represent the absence of a value, similar to null in other languages. It only has a single value: nil","title":"Nil"},{"location":"syntax_and_semantics/literals/nil.html#nil","text":"The Nil type is used to represent the absence of a value, similar to null in other languages. It only has a single value: nil","title":"Nil"},{"location":"syntax_and_semantics/literals/proc.html","text":"Proc \u00b6 A Proc represents a function pointer with an optional context (the closure data). It is typically created with a proc literal: # A proc without parameters -> { 1 } # Proc(Int32) # A proc with one parameters -> ( x : Int32 ) { x . to_s } # Proc(Int32, String) # A proc with two parameters -> ( x : Int32 , y : Int32 ) { x + y } # Proc(Int32, Int32, Int32) The types of the parameters are mandatory, except when directly sending a proc literal to a lib fun in C bindings. The return type is inferred from the proc's body. A special new method is provided too: Proc ( Int32 , String ) . new { | x | x . to_s } # Proc(Int32, String) This form allows you to specify the return type and to check it against the proc's body. The Proc type \u00b6 To denote a Proc type you can write: # A Proc accepting a single Int32 argument and returning a String Proc ( Int32 , String ) # A proc accepting no arguments and returning Void Proc ( Void ) # A proc accepting two arguments (one Int32 and one String) and returning a Char Proc ( Int32 , String , Char ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type : # An array of Proc(Int32, String, Char) Array ( Int32 , String -> Char ) Invoking \u00b6 To invoke a Proc, you invoke the call method on it. The number of arguments must match the proc's type: proc = -> ( x : Int32 , y : Int32 ) { x + y } proc . call ( 1 , 2 ) # => 3 From methods \u00b6 A Proc can be created from an existing method: def one 1 end proc = -> one proc . call # => 1 If the method has parameters, you must specify their types: def plus_one ( x ) x + 1 end proc = -> plus_one ( Int32 ) proc . call ( 41 ) # => 42 A proc can optionally specify a receiver: str = \"hello\" proc = -> str . count ( Char ) proc . call ( 'e' ) # => 1 proc . call ( 'l' ) # => 2","title":"Proc"},{"location":"syntax_and_semantics/literals/proc.html#proc","text":"A Proc represents a function pointer with an optional context (the closure data). It is typically created with a proc literal: # A proc without parameters -> { 1 } # Proc(Int32) # A proc with one parameters -> ( x : Int32 ) { x . to_s } # Proc(Int32, String) # A proc with two parameters -> ( x : Int32 , y : Int32 ) { x + y } # Proc(Int32, Int32, Int32) The types of the parameters are mandatory, except when directly sending a proc literal to a lib fun in C bindings. The return type is inferred from the proc's body. A special new method is provided too: Proc ( Int32 , String ) . new { | x | x . to_s } # Proc(Int32, String) This form allows you to specify the return type and to check it against the proc's body.","title":"Proc"},{"location":"syntax_and_semantics/literals/proc.html#the-proc-type","text":"To denote a Proc type you can write: # A Proc accepting a single Int32 argument and returning a String Proc ( Int32 , String ) # A proc accepting no arguments and returning Void Proc ( Void ) # A proc accepting two arguments (one Int32 and one String) and returning a Char Proc ( Int32 , String , Char ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type : # An array of Proc(Int32, String, Char) Array ( Int32 , String -> Char )","title":"The Proc type"},{"location":"syntax_and_semantics/literals/proc.html#invoking","text":"To invoke a Proc, you invoke the call method on it. The number of arguments must match the proc's type: proc = -> ( x : Int32 , y : Int32 ) { x + y } proc . call ( 1 , 2 ) # => 3","title":"Invoking"},{"location":"syntax_and_semantics/literals/proc.html#from-methods","text":"A Proc can be created from an existing method: def one 1 end proc = -> one proc . call # => 1 If the method has parameters, you must specify their types: def plus_one ( x ) x + 1 end proc = -> plus_one ( Int32 ) proc . call ( 41 ) # => 42 A proc can optionally specify a receiver: str = \"hello\" proc = -> str . count ( Char ) proc . call ( 'e' ) # => 1 proc . call ( 'l' ) # => 2","title":"From methods"},{"location":"syntax_and_semantics/literals/range.html","text":"Range \u00b6 A Range represents an interval between two values. It is typically constructed with a range literal, consisting of two or three dots: x..y : Two dots denote an inclusive range, including x and y and all values in between (in mathematics: [x, y] ) . x...y : Three dots denote an exclusive range, including x and all values up to but not including y (in mathematics: [x, y) ). ( 0 .. 5 ) . to_a # => [0, 1, 2, 3, 4, 5] ( 0 ... 5 ) . to_a # => [0, 1, 2, 3, 4] Note Range literals are often wrapped in parentheses, for example if it is meant to be used as the receiver of a call. 0..5.to_a without parentheses would be semantically equivalent to 0..(5.to_a) because method calls and other operators have higher precedence than the range literal. An easy way to remember which one is inclusive and which one is exclusive it to think of the extra dot as if it pushes y further away, thus leaving it outside of the range. The literal x..y is semantically equivalent to the explicit constructor Range.new(x, y) and x...y to Range.new(x, y, true) . The begin and end values do not necessarily need to be of the same type: true..1 is a valid range, although pretty useless Enumerable methods won't work with incompatible types. They need at least to be comparable. Ranges with nil as begin are called begin-less and nil as end are called end-less ranges. In the literal notation, nil can be omitted: x.. is an end-less range starting from x , and ..x is an begin-less range ending at x . numbers = [ 1 , 10 , 3 , 4 , 5 , 8 ] numbers . select ( 6 .. ) # => [10, 8] numbers . select ( .. 6 ) # => [1, 3, 4, 5] numbers [ 2 ..] = [ 3 , 4 , 5 , 8 ] numbers [.. 2 ] = [ 1 , 10 , 3 ] A range that is both begin-less and end-less is valid and can be expressed as .. or ... but it's typically not very useful.","title":"Range"},{"location":"syntax_and_semantics/literals/range.html#range","text":"A Range represents an interval between two values. It is typically constructed with a range literal, consisting of two or three dots: x..y : Two dots denote an inclusive range, including x and y and all values in between (in mathematics: [x, y] ) . x...y : Three dots denote an exclusive range, including x and all values up to but not including y (in mathematics: [x, y) ). ( 0 .. 5 ) . to_a # => [0, 1, 2, 3, 4, 5] ( 0 ... 5 ) . to_a # => [0, 1, 2, 3, 4] Note Range literals are often wrapped in parentheses, for example if it is meant to be used as the receiver of a call. 0..5.to_a without parentheses would be semantically equivalent to 0..(5.to_a) because method calls and other operators have higher precedence than the range literal. An easy way to remember which one is inclusive and which one is exclusive it to think of the extra dot as if it pushes y further away, thus leaving it outside of the range. The literal x..y is semantically equivalent to the explicit constructor Range.new(x, y) and x...y to Range.new(x, y, true) . The begin and end values do not necessarily need to be of the same type: true..1 is a valid range, although pretty useless Enumerable methods won't work with incompatible types. They need at least to be comparable. Ranges with nil as begin are called begin-less and nil as end are called end-less ranges. In the literal notation, nil can be omitted: x.. is an end-less range starting from x , and ..x is an begin-less range ending at x . numbers = [ 1 , 10 , 3 , 4 , 5 , 8 ] numbers . select ( 6 .. ) # => [10, 8] numbers . select ( .. 6 ) # => [1, 3, 4, 5] numbers [ 2 ..] = [ 3 , 4 , 5 , 8 ] numbers [.. 2 ] = [ 1 , 10 , 3 ] A range that is both begin-less and end-less is valid and can be expressed as .. or ... but it's typically not very useful.","title":"Range"},{"location":"syntax_and_semantics/literals/regex.html","text":"Regular Expressions \u00b6 Regular expressions are represented by the Regex class. A Regex is typically created with a regex literal using PCRE syntax. It consists of a string of UTF-8 characters enclosed in forward slashes ( / ): /foo|bar/ /h(e+)llo/ /\\d+/ /\u3042/ Escaping \u00b6 Regular expressions support the same escape sequences as String literals . /\\// # slash /\\\\/ # backslash /\\b/ # backspace /\\e/ # escape /\\f/ # form feed /\\n/ # newline /\\r/ # carriage return /\\t/ # tab /\\v/ # vertical tab /\\NNN/ # octal ASCII character /\\xNN/ # hexadecimal ASCII character /\\x{FFFF}/ # hexadecimal unicode character /\\x{10FFFF}/ # hexadecimal unicode character The delimiter character / must be escaped inside slash-delimited regular expression literals. Note that special characters of the PCRE syntax need to be escaped if they are intended as literal characters. Interpolation \u00b6 Interpolation works in regular expression literals just as it does in string literals . Be aware that using this feature will cause an exception to be raised at runtime, if the resulting string results in an invalid regular expression. Modifiers \u00b6 The closing delimiter may be followed by a number of optional modifiers to adjust the matching behaviour of the regular expression. i : case-insensitive matching ( PCRE_CASELESS ): Unicode letters in the pattern match both upper and lower case letters in the subject string. m : multiline matching ( PCRE_MULTILINE ): The start of line ( ^ ) and end of line ( $ ) metacharacters match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. x : extended whitespace matching ( PCRE_EXTENDED ): Most white space characters in the pattern are totally ignored except when ignore or inside a character class. Unescaped hash characters # denote the start of a comment ranging to the end of the line. /foo/i . match ( \"FOO\" ) # => #<Regex::MatchData \"FOO\"> /foo/m . match ( \"bar \\n foo\" ) # => #<Regex::MatchData \"foo\"> /foo /x . match ( \"foo\" ) # => #<Regex::MatchData \"foo\"> /foo /imx . match ( \"bar \\n FOO\" ) # => #<Regex::MatchData \"FOO\"> Percent regex literals \u00b6 Besides slash-delimited literals, regular expressions may also be expressed as a percent literal indicated by %r and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the literal escapes the next end delimiter. These are handy to write regular expressions that include slashes which would have to be escaped in slash-delimited literals. %r((/)) # => /(\\/)/ %r[[/]] # => /[\\/]/ %r{{/}} # => /{\\/}/ %r<</>> # => /<\\/>/ %r|/| # => /\\//","title":"Regex"},{"location":"syntax_and_semantics/literals/regex.html#regular-expressions","text":"Regular expressions are represented by the Regex class. A Regex is typically created with a regex literal using PCRE syntax. It consists of a string of UTF-8 characters enclosed in forward slashes ( / ): /foo|bar/ /h(e+)llo/ /\\d+/ /\u3042/","title":"Regular Expressions"},{"location":"syntax_and_semantics/literals/regex.html#escaping","text":"Regular expressions support the same escape sequences as String literals . /\\// # slash /\\\\/ # backslash /\\b/ # backspace /\\e/ # escape /\\f/ # form feed /\\n/ # newline /\\r/ # carriage return /\\t/ # tab /\\v/ # vertical tab /\\NNN/ # octal ASCII character /\\xNN/ # hexadecimal ASCII character /\\x{FFFF}/ # hexadecimal unicode character /\\x{10FFFF}/ # hexadecimal unicode character The delimiter character / must be escaped inside slash-delimited regular expression literals. Note that special characters of the PCRE syntax need to be escaped if they are intended as literal characters.","title":"Escaping"},{"location":"syntax_and_semantics/literals/regex.html#interpolation","text":"Interpolation works in regular expression literals just as it does in string literals . Be aware that using this feature will cause an exception to be raised at runtime, if the resulting string results in an invalid regular expression.","title":"Interpolation"},{"location":"syntax_and_semantics/literals/regex.html#modifiers","text":"The closing delimiter may be followed by a number of optional modifiers to adjust the matching behaviour of the regular expression. i : case-insensitive matching ( PCRE_CASELESS ): Unicode letters in the pattern match both upper and lower case letters in the subject string. m : multiline matching ( PCRE_MULTILINE ): The start of line ( ^ ) and end of line ( $ ) metacharacters match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. x : extended whitespace matching ( PCRE_EXTENDED ): Most white space characters in the pattern are totally ignored except when ignore or inside a character class. Unescaped hash characters # denote the start of a comment ranging to the end of the line. /foo/i . match ( \"FOO\" ) # => #<Regex::MatchData \"FOO\"> /foo/m . match ( \"bar \\n foo\" ) # => #<Regex::MatchData \"foo\"> /foo /x . match ( \"foo\" ) # => #<Regex::MatchData \"foo\"> /foo /imx . match ( \"bar \\n FOO\" ) # => #<Regex::MatchData \"FOO\">","title":"Modifiers"},{"location":"syntax_and_semantics/literals/regex.html#percent-regex-literals","text":"Besides slash-delimited literals, regular expressions may also be expressed as a percent literal indicated by %r and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the literal escapes the next end delimiter. These are handy to write regular expressions that include slashes which would have to be escaped in slash-delimited literals. %r((/)) # => /(\\/)/ %r[[/]] # => /[\\/]/ %r{{/}} # => /{\\/}/ %r<</>> # => /<\\/>/ %r|/| # => /\\//","title":"Percent regex literals"},{"location":"syntax_and_semantics/literals/string.html","text":"String \u00b6 A String represents an immutable sequence of UTF-8 characters. A String is typically created with a string literal enclosing UTF-8 characters in double quotes ( \" ): \"hello world\" Escaping \u00b6 A backslash denotes a special character inside a string, which can either be a named escape sequence or a numerical representation of a unicode codepoint. Available escape sequences: \" \\\" \" # double quote \" \\\\ \" # backslash \" \\a \" # alert \" \\b \" # backspace \" \\e \" # escape \" \\f \" # form feed \" \\n \" # newline \" \\r \" # carriage return \" \\t \" # tab \" \\v \" # vertical tab \" \\377 \" # octal ASCII character \" \\xFF \" # hexadecimal ASCII character \" \\uFFFF \" # hexadecimal unicode character \" \\u{0} \" .. \" \\u{10FFFF} \" # hexadecimal unicode character Any other character following a backslash is interpreted as the character itself. A backslash followed by at most three digits ranging from 0 to 7 denotes a code point written in octal: \" \\101 \" # => \"A\" \" \\123 \" # => \"S\" \" \\12 \" # => \"\\n\" \" \\1 \" # string with one character with code point 1 A backslash followed by a u denotes a unicode codepoint. It can either be followed by exactly four hexadecimal characters representing the unicode bytes ( \\u0000 to \\uFFFF ) or a number of one to six hexadecimal characters wrapped in curly braces ( \\u{0} to \\u{10FFFF} . \" \\u0041 \" # => \"A\" \" \\u{41} \" # => \"A\" \" \\u{1F52E} \" # => \"&#x1F52E;\" One curly brace can contain multiple unicode characters each separated by a whitespace. \" \\u{48 45 4C 4C 4F} \" # => \"HELLO\" Interpolation \u00b6 A string literal with interpolation allows to embed expressions into the string which will be expanded at runtime. a = 1 b = 2 \"sum: #{ a } + #{ b } = #{ a + b } \" # => \"sum: 1 + 2 = 3\" String interpolation is also possible with String#% . Any expression may be placed inside the interpolated section, but it\u2019s best to keep the expression small for readability. Interpolation can be disabled by escaping the # character with a backslash or by using a non-interpolating string literal like %q() . \" \\# {a + b}\" # => \"#{a + b}\" %q(#{a + b}) # => \"#{a + b}\" Interpolation is implemented using a String::Builder and invoking Object#to_s(IO) on each expression enclosed by #{...} . The expression \"sum: #{a} + #{b} = #{a + b}\" is equivalent to: String . build do | io | io << \"sum: \" io << a io << \" + \" io << b io << \" = \" io << a + b end Percent string literals \u00b6 Besides double-quotes strings, Crystal also supports string literals indicated by a percent sign ( % ) and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested meaning a start delimiter inside the string escapes the next end delimiter. These are handy to write strings that include double quotes which would have to be escaped in double-quoted strings. %(hello (\"world\")) # => \"hello (\\\"world\\\")\" %[hello [\"world\"]] # => \"hello [\\\"world\\\"]\" %{hello {\"world\"}} # => \"hello {\\\"world\\\"}\" %<hello <\"world\">> # => \"hello <\\\"world\\\">\" %|hello \"world\"| # => \"hello \\\"world\\\"\" A literal denoted by %q does not apply interpolation nor escapes while %Q has the same meaning as % . name = \"world\" %q(hello \\n #{name}) # => \"hello \\\\n \\#{name}\" %Q(hello \\n #{ name } ) # => \"hello \\n world\" Percent string array literal \u00b6 Besides the single string literal, there is also a percent literal to create an Array of strings. It is indicated by %w and a pair of delimiters. Valid delimiters are as same as percent string literals . %w(foo bar baz) # => [\"foo\", \"bar\", \"baz\"] %w(foo\\nbar baz) # => [\"foo\\\\nbar\", \"baz\"] %w(foo(bar) baz) # => [\"foo(bar)\", \"baz\"] Note that literal denoted by %w does not apply interpolation nor escapes except spaces. Since strings are separated by a single space character ( ) which must be escaped to use it as a part of a string. %w(foo\\ bar baz) # => [\"foo bar\", \"baz\"] Multiline strings \u00b6 Any string literal can span multiple lines: \"hello world\" # => \"hello\\n world\" Note that in the above example trailing and leading spaces, as well as newlines, end up in the resulting string. To avoid this a string can be split into multiple lines by joining multiple literals with a backslash: \"hello \" \\ \"world, \" \\ \"no newlines\" # same as \"hello world, no newlines\" Alternatively, a backslash followed by a newline can be inserted inside the string literal: \"hello \\ world, \\ no newlines\" # same as \"hello world, no newlines\" In this case, leading whitespace is not included in the resulting string. Heredoc \u00b6 A here document or heredoc can be useful for writing strings spanning over multiple lines. A heredoc is denoted by <<- followed by an heredoc identifier which is an alphanumeric sequence starting with a letter (and may include underscores). The heredoc starts in the following line and ends with the next line that contains only the heredoc identifier, optionally preceeded by whitespace. <<- XML <parent> <child /> </parent> XML Leading whitespace is removed from the heredoc contents according to the number of whitespace in the last line before the heredoc identifier. <<- STRING # => \"Hello\\n world\" Hello world STRING <<- STRING # => \" Hello\\n world\" Hello world STRING After the heredoc identifier, and in that same line, anything that follows continues the original expression that came before the heredoc. It's as if the end of the starting heredoc identifier is the end of the string. However, the string contents come in subsequent lines until the ending heredoc idenfitier which must be on its own line. <<- STRING . upcase # => \"HELLO\" hello STRING def upcase ( string ) string . upcase end upcase ( <<- STRING ) # => \"HELLO WORLD\" Hello World STRING If multiple heredocs start in the same line, their bodies are read sequentially: print ( <<- FIRST , <<- SECOND ) # prints \"HelloWorld\" Hello FIRST World SECOND A heredoc generally allows interpolation and escapes. To denote a heredoc without interpolation or escapes, the opening heredoc identifier is enclosed in single quotes: <<- ' HERE ' # => \"hello \\\\n \\#{world}\" hello \\n #{world} HERE","title":"String"},{"location":"syntax_and_semantics/literals/string.html#string","text":"A String represents an immutable sequence of UTF-8 characters. A String is typically created with a string literal enclosing UTF-8 characters in double quotes ( \" ): \"hello world\"","title":"String"},{"location":"syntax_and_semantics/literals/string.html#escaping","text":"A backslash denotes a special character inside a string, which can either be a named escape sequence or a numerical representation of a unicode codepoint. Available escape sequences: \" \\\" \" # double quote \" \\\\ \" # backslash \" \\a \" # alert \" \\b \" # backspace \" \\e \" # escape \" \\f \" # form feed \" \\n \" # newline \" \\r \" # carriage return \" \\t \" # tab \" \\v \" # vertical tab \" \\377 \" # octal ASCII character \" \\xFF \" # hexadecimal ASCII character \" \\uFFFF \" # hexadecimal unicode character \" \\u{0} \" .. \" \\u{10FFFF} \" # hexadecimal unicode character Any other character following a backslash is interpreted as the character itself. A backslash followed by at most three digits ranging from 0 to 7 denotes a code point written in octal: \" \\101 \" # => \"A\" \" \\123 \" # => \"S\" \" \\12 \" # => \"\\n\" \" \\1 \" # string with one character with code point 1 A backslash followed by a u denotes a unicode codepoint. It can either be followed by exactly four hexadecimal characters representing the unicode bytes ( \\u0000 to \\uFFFF ) or a number of one to six hexadecimal characters wrapped in curly braces ( \\u{0} to \\u{10FFFF} . \" \\u0041 \" # => \"A\" \" \\u{41} \" # => \"A\" \" \\u{1F52E} \" # => \"&#x1F52E;\" One curly brace can contain multiple unicode characters each separated by a whitespace. \" \\u{48 45 4C 4C 4F} \" # => \"HELLO\"","title":"Escaping"},{"location":"syntax_and_semantics/literals/string.html#interpolation","text":"A string literal with interpolation allows to embed expressions into the string which will be expanded at runtime. a = 1 b = 2 \"sum: #{ a } + #{ b } = #{ a + b } \" # => \"sum: 1 + 2 = 3\" String interpolation is also possible with String#% . Any expression may be placed inside the interpolated section, but it\u2019s best to keep the expression small for readability. Interpolation can be disabled by escaping the # character with a backslash or by using a non-interpolating string literal like %q() . \" \\# {a + b}\" # => \"#{a + b}\" %q(#{a + b}) # => \"#{a + b}\" Interpolation is implemented using a String::Builder and invoking Object#to_s(IO) on each expression enclosed by #{...} . The expression \"sum: #{a} + #{b} = #{a + b}\" is equivalent to: String . build do | io | io << \"sum: \" io << a io << \" + \" io << b io << \" = \" io << a + b end","title":"Interpolation"},{"location":"syntax_and_semantics/literals/string.html#percent-string-literals","text":"Besides double-quotes strings, Crystal also supports string literals indicated by a percent sign ( % ) and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested meaning a start delimiter inside the string escapes the next end delimiter. These are handy to write strings that include double quotes which would have to be escaped in double-quoted strings. %(hello (\"world\")) # => \"hello (\\\"world\\\")\" %[hello [\"world\"]] # => \"hello [\\\"world\\\"]\" %{hello {\"world\"}} # => \"hello {\\\"world\\\"}\" %<hello <\"world\">> # => \"hello <\\\"world\\\">\" %|hello \"world\"| # => \"hello \\\"world\\\"\" A literal denoted by %q does not apply interpolation nor escapes while %Q has the same meaning as % . name = \"world\" %q(hello \\n #{name}) # => \"hello \\\\n \\#{name}\" %Q(hello \\n #{ name } ) # => \"hello \\n world\"","title":"Percent string literals"},{"location":"syntax_and_semantics/literals/string.html#percent-string-array-literal","text":"Besides the single string literal, there is also a percent literal to create an Array of strings. It is indicated by %w and a pair of delimiters. Valid delimiters are as same as percent string literals . %w(foo bar baz) # => [\"foo\", \"bar\", \"baz\"] %w(foo\\nbar baz) # => [\"foo\\\\nbar\", \"baz\"] %w(foo(bar) baz) # => [\"foo(bar)\", \"baz\"] Note that literal denoted by %w does not apply interpolation nor escapes except spaces. Since strings are separated by a single space character ( ) which must be escaped to use it as a part of a string. %w(foo\\ bar baz) # => [\"foo bar\", \"baz\"]","title":"Percent string array literal"},{"location":"syntax_and_semantics/literals/string.html#multiline-strings","text":"Any string literal can span multiple lines: \"hello world\" # => \"hello\\n world\" Note that in the above example trailing and leading spaces, as well as newlines, end up in the resulting string. To avoid this a string can be split into multiple lines by joining multiple literals with a backslash: \"hello \" \\ \"world, \" \\ \"no newlines\" # same as \"hello world, no newlines\" Alternatively, a backslash followed by a newline can be inserted inside the string literal: \"hello \\ world, \\ no newlines\" # same as \"hello world, no newlines\" In this case, leading whitespace is not included in the resulting string.","title":"Multiline strings"},{"location":"syntax_and_semantics/literals/string.html#heredoc","text":"A here document or heredoc can be useful for writing strings spanning over multiple lines. A heredoc is denoted by <<- followed by an heredoc identifier which is an alphanumeric sequence starting with a letter (and may include underscores). The heredoc starts in the following line and ends with the next line that contains only the heredoc identifier, optionally preceeded by whitespace. <<- XML <parent> <child /> </parent> XML Leading whitespace is removed from the heredoc contents according to the number of whitespace in the last line before the heredoc identifier. <<- STRING # => \"Hello\\n world\" Hello world STRING <<- STRING # => \" Hello\\n world\" Hello world STRING After the heredoc identifier, and in that same line, anything that follows continues the original expression that came before the heredoc. It's as if the end of the starting heredoc identifier is the end of the string. However, the string contents come in subsequent lines until the ending heredoc idenfitier which must be on its own line. <<- STRING . upcase # => \"HELLO\" hello STRING def upcase ( string ) string . upcase end upcase ( <<- STRING ) # => \"HELLO WORLD\" Hello World STRING If multiple heredocs start in the same line, their bodies are read sequentially: print ( <<- FIRST , <<- SECOND ) # prints \"HelloWorld\" Hello FIRST World SECOND A heredoc generally allows interpolation and escapes. To denote a heredoc without interpolation or escapes, the opening heredoc identifier is enclosed in single quotes: <<- ' HERE ' # => \"hello \\\\n \\#{world}\" hello \\n #{world} HERE","title":"Heredoc"},{"location":"syntax_and_semantics/literals/symbol.html","text":"Symbol \u00b6 A Symbol represents a unique name inside the entire source code. Symbols are interpreted at compile time and cannot be created dynamically. The only way to create a Symbol is by using a symbol literal, denoted by a colon ( : ) followed by an identifier. The identifier may optionally be enclosed in double quotes ( \" ). :unquoted_symbol :\"quoted symbol\" :\"a\" # identical to :a :\u3042 A double-quoted identifier can contain any unicode character including white spaces and accepts the same escape sequences as a string literal , yet no interpolation. For an unquoted identifier the same naming rules apply as for methods. It can contain alphanumeric characters, underscore ( _ ) or characters with a code point greater than 159 ( 0x9F ). It must not start with a number and may end with an exclamation mark ( ! ) or question mark ( ? ). :question? :exclamation! All Crystal operators can be used as symbol names unquoted: :+ :- :* :/ :% :& :| :^ :** :>> :<< :== :!= :< :<= :> :>= :<=> :=== :[] :[]? :[]= :! :~ :!~ :=~ Internally, symbols are implemented as constants with a numeric value of type Int32 . Percent symbol array literal \u00b6 Besides the single symbol literal, there is also a percent literal to create an Array of symbols. It is indicated by %i and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the string escapes the next end delimiter. %i(foo bar baz) # => [:foo, :bar, :baz] %i(foo\\nbar baz) # => [:\"foo\\nbar\", :baz] %i(foo(bar) baz) # => [:\"foo(bar)\", :baz] Identifiers may contain any unicode characters. Individual symbols are separated by a single space character ( ) which must be escaped to use it as a part of an identifier. %i(foo\\ bar baz) # => [:\"foo bar\", :baz]","title":"Symbol"},{"location":"syntax_and_semantics/literals/symbol.html#symbol","text":"A Symbol represents a unique name inside the entire source code. Symbols are interpreted at compile time and cannot be created dynamically. The only way to create a Symbol is by using a symbol literal, denoted by a colon ( : ) followed by an identifier. The identifier may optionally be enclosed in double quotes ( \" ). :unquoted_symbol :\"quoted symbol\" :\"a\" # identical to :a :\u3042 A double-quoted identifier can contain any unicode character including white spaces and accepts the same escape sequences as a string literal , yet no interpolation. For an unquoted identifier the same naming rules apply as for methods. It can contain alphanumeric characters, underscore ( _ ) or characters with a code point greater than 159 ( 0x9F ). It must not start with a number and may end with an exclamation mark ( ! ) or question mark ( ? ). :question? :exclamation! All Crystal operators can be used as symbol names unquoted: :+ :- :* :/ :% :& :| :^ :** :>> :<< :== :!= :< :<= :> :>= :<=> :=== :[] :[]? :[]= :! :~ :!~ :=~ Internally, symbols are implemented as constants with a numeric value of type Int32 .","title":"Symbol"},{"location":"syntax_and_semantics/literals/symbol.html#percent-symbol-array-literal","text":"Besides the single symbol literal, there is also a percent literal to create an Array of symbols. It is indicated by %i and a pair of delimiters. Valid delimiters are parentheses () , square brackets [] , curly braces {} , angles <> and pipes || . Except for the pipes, all delimiters can be nested; meaning a start delimiter inside the string escapes the next end delimiter. %i(foo bar baz) # => [:foo, :bar, :baz] %i(foo\\nbar baz) # => [:\"foo\\nbar\", :baz] %i(foo(bar) baz) # => [:\"foo(bar)\", :baz] Identifiers may contain any unicode characters. Individual symbols are separated by a single space character ( ) which must be escaped to use it as a part of an identifier. %i(foo\\ bar baz) # => [:\"foo bar\", :baz]","title":"Percent symbol array literal"},{"location":"syntax_and_semantics/literals/tuple.html","text":"Tuple \u00b6 A Tuple is typically created with a tuple literal: tuple = { 1 , \"hello\" , 'x' } # Tuple(Int32, String, Char) tuple [ 0 ] # => 1 (Int32) tuple [ 1 ] # => \"hello\" (String) tuple [ 2 ] # => 'x' (Char) To create an empty tuple use Tuple.new . To denote a tuple type you can write: # The type denoting a tuple of Int32, String and Char Tuple ( Int32 , String , Char ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type grammar : # An array of tuples of Int32, String and Char Array ({ Int32 , String , Char })","title":"Tuple"},{"location":"syntax_and_semantics/literals/tuple.html#tuple","text":"A Tuple is typically created with a tuple literal: tuple = { 1 , \"hello\" , 'x' } # Tuple(Int32, String, Char) tuple [ 0 ] # => 1 (Int32) tuple [ 1 ] # => \"hello\" (String) tuple [ 2 ] # => 'x' (Char) To create an empty tuple use Tuple.new . To denote a tuple type you can write: # The type denoting a tuple of Int32, String and Char Tuple ( Int32 , String , Char ) In type restrictions, generic type arguments and other places where a type is expected, you can use a shorter syntax, as explained in the type grammar : # An array of tuples of Int32, String and Char Array ({ Int32 , String , Char })","title":"Tuple"},{"location":"syntax_and_semantics/macros/index.html","text":"Macros \u00b6 Macros are methods that receive AST nodes at compile-time and produce code that is pasted into a program. For example: macro define_method ( name , content ) def {{ name }} {{ content }} end end # This generates: # # def foo # 1 # end define_method foo , 1 foo # => 1 A macro's definition body looks like regular Crystal code with extra syntax to manipulate the AST nodes. The generated code must be valid Crystal code, meaning that you can't for example generate a def without a matching end , or a single when expression of a case , since both of them are not complete valid expressions. Refer to Pitfalls for more information. Scope \u00b6 Macros declared at the top-level are visible anywhere. If a top-level macro is marked as private it is only accessible in that file. They can also be defined in classes and modules, and are visible in those scopes. Macros are also looked-up in the ancestors chain (superclasses and included modules). For example, a block which is given an object to use as the default receiver by being invoked with with ... yield can access macros defined within that object's ancestors chain: class Foo macro emphasize ( value ) \"*** #{ {{ value }} } ***\" end def yield_with_self with self yield end end Foo . new . yield_with_self { emphasize ( 10 ) } # => \"***10***\" Macros defined in classes and modules can be invoked from outside of them too: class Foo macro emphasize ( value ) \"*** #{ {{ value }} } ***\" end end Foo . emphasize ( 10 ) # => \"***10***\" Interpolation \u00b6 You use {{...}} to paste, or interpolate, an AST node, as in the above example. Note that the node is pasted as-is. If in the previous example we pass a symbol, the generated code becomes invalid: # This generates: # # def :foo # 1 # end define_method :foo , 1 Note that :foo was the result of the interpolation, because that's what was passed to the macro. You can use the method ASTNode#id in these cases, where you just need an identifier. Macro calls \u00b6 You can invoke a fixed subset of methods on AST nodes at compile-time. These methods are documented in a fictitious Crystal::Macros module. For example, invoking ASTNode#id in the above example solves the problem: macro define_method ( name , content ) def {{ name . id }} {{ content }} end end # This correctly generates: # # def foo # 1 # end define_method :foo , 1 Modules and classes \u00b6 Modules, classes and structs can also be generated: macro define_class ( module_name , class_name , method , content ) module {{ module_name }} class {{ class_name }} def initialize ( @name : String ) end def {{ method }} {{ content }} + @name end end end end # This generates: # module Foo # class Bar # def initialize(@name : String) # end # # def say # \"hi \" + @name # end # end # end define_class Foo , Bar , say , \"hi \" p Foo :: Bar . new ( \"John\" ) . say # => \"hi John\" Conditionals \u00b6 You use {% if condition %} ... {% end %} to conditionally generate code: macro define_method ( name , content ) def {{ name }} {% if content == 1 %} \"one\" {% elsif content == 2 %} \"two\" {% else %} {{ content }} {% end %} end end define_method foo , 1 define_method bar , 2 define_method baz , 3 foo # => one bar # => two baz # => 3 Similar to regular code, Nop , NilLiteral and a false BoolLiteral are considered falsey , while everything else is considered truthy . Macro conditionals can be used outside a macro definition: {% if env ( \"TEST\" ) %} puts \"We are in test mode\" {% end %} Iteration \u00b6 You can iterate a finite amount of times: macro define_constants ( count ) {% for i in ( 1 .. count ) %} PI_ {{ i . id }} = Math :: PI * {{ i }} {% end %} end define_constants ( 3 ) PI_1 # => 3.14159... PI_2 # => 6.28318... PI_3 # => 9.42477... To iterate an ArrayLiteral : macro define_dummy_methods ( names ) {% for name , index in names %} def {{ name . id }} {{ index }} end {% end %} end define_dummy_methods [ foo , bar , baz ] foo # => 0 bar # => 1 baz # => 2 The index variable in the above example is optional. To iterate a HashLiteral : macro define_dummy_methods ( hash ) {% for key , value in hash %} def {{ key . id }} {{ value }} end {% end %} end define_dummy_methods ({ foo : 10 , bar : 20 }) foo # => 10 bar # => 20 Macro iterations can be used outside a macro definition: {% for name , index in [ \"foo\" , \"bar\" , \"baz\" ] %} def {{ name . id }} {{ index }} end {% end %} foo # => 0 bar # => 1 baz # => 2 Variadic arguments and splatting \u00b6 A macro can accept variadic arguments: macro define_dummy_methods ( * names ) {% for name , index in names %} def {{ name . id }} {{ index }} end {% end %} end define_dummy_methods foo , bar , baz foo # => 0 bar # => 1 baz # => 2 The arguments are packed into a TupleLiteral and passed to the macro. Additionally, using * when interpolating a TupleLiteral interpolates the elements separated by commas: macro println ( * values ) print {{ * values }} , '\\n' end println 1 , 2 , 3 # outputs 123\\n Type information \u00b6 When a macro is invoked you can access the current scope, or type, with a special instance variable: @type . The type of this variable is TypeNode , which gives you access to type information at compile time. Note that @type is always the instance type, even when the macro is invoked in a class method. For example: macro add_describe_methods def describe \"Class is: \" + {{ @type . stringify }} end def self . describe \"Class is: \" + {{ @type . stringify }} end end class Foo add_describe_methods end Foo . new . describe # => \"Class is Foo\" Foo . describe # => \"Class is Foo\" Method information \u00b6 When a macro is invoked you can access the method, the macro is in with a special instance variable: @def . The type of this variable is Def unless the macro is outside of a method, in this case it's NilLiteral . Example: module Foo def Foo . boo ( arg1 , arg2 ) {% @def . receiver %} # => Foo {% @def . name %} # => boo {% @def . args %} # => [arg1, arg2] end end Foo . boo ( 0 , 1 ) Constants \u00b6 Macros can access constants. For example: VALUES = [ 1 , 2 , 3 ] {% for value in VALUES %} puts {{ value }} {% end %} If the constant denotes a type, you get back a TypeNode . Nested macros \u00b6 It is possible to define a macro which generates one or more macro definitions. You must escape macro expressions of the inner macro by preceding them with a backslash character \"\\\" to prevent them from being evaluated by the outer macro. macro define_macros ( * names ) {% for name in names %} macro greeting_for_ {{ name . id }} ( greeting ) \\ {% if greeting == \"hola\" %} \"\u00a1hola {{name.id}}!\" \\ {% else %} \"\\{{greeting.id}} {{name.id}}\" \\ {% end %} end {% end %} end # This generates: # # macro greeting_for_alice # {% if greeting == \"hola\" %} # \"\u00a1hola alice!\" # {% else %} # \"{{greeting.id}} alice\" # {% end %} # end # macro greeting_for_bob # {% if greeting == \"hola\" %} # \"\u00a1hola bob!\" # {% else %} # \"{{greeting.id}} bob\" # {% end %} # end define_macros alice , bob greeting_for_alice \"hello\" # => \"hello alice\" greeting_for_bob \"hallo\" # => \"hallo bob\" greeting_for_alice \"hej\" # => \"hej alice\" greeting_for_bob \"hola\" # => \"\u00a1hola bob!\" verbatim \u00b6 Another way to define a nested macro is by using the special verbatim call. Using this you will not be able to use any variable interpolation but will not need to escape the inner macro characters. macro define_macros ( * names ) {% for name in names %} macro greeting_for_ {{ name . id }} ( greeting ) # name will not be available within the verbatim block \\ {% name = {{ name . stringify }} %} {% verbatim do %} {% if greeting == \"hola\" %} \"\u00a1hola {{name.id}}!\" {% else %} \"{{greeting.id}} {{name.id}}\" {% end %} {% end %} end {% end %} end # This generates: # # macro greeting_for_alice # {% name = \"alice\" %} # {% if greeting == \"hola\" %} # \"\u00a1hola alice!\" # {% else %} # \"{{greeting.id}} alice\" # {% end %} # end # macro greeting_for_bob # {% name = \"bob\" %} # {% if greeting == \"hola\" %} # \"\u00a1hola bob!\" # {% else %} # \"{{greeting.id}} bob\" # {% end %} # end define_macros alice , bob greeting_for_alice \"hello\" # => \"hello alice\" greeting_for_bob \"hallo\" # => \"hallo bob\" greeting_for_alice \"hej\" # => \"hej alice\" greeting_for_bob \"hola\" # => \"\u00a1hola bob!\" Notice the variables in the inner macro are not available within the verbatim block. The contents of the block are transferred \"as is\", essentially as a string, until re-examined by the compiler. Comments \u00b6 Macro expressions are evaluated both within comments as well as compilable sections of code. This may be used to provide relevant documentation for expansions: {% for name , index in [ \"foo\" , \"bar\" , \"baz\" ] %} # Provides a placeholder {{name.id}} method. Always returns {{index}}. def {{ name . id }} {{ index }} end {% end %} This evaluation applies to both interpolation and directives. As a result of this, macros cannot be commented out. macro a # {% if false %} puts 42 # {% end %} end a The expression above will result in no output. Pitfalls \u00b6 When writing macros (especially outside of a macro definition) it is important to remember that the generated code from the macro must be valid Crystal code by itself even before it is merged into the main program's code. This means, for example, a macro cannot generate a one or more when expressions of a case statement unless case was a part of the generated code. Here is an example of such an invalid macro: case 42 {% for klass in [ Int32 , String ] %} # Syntax Error: unexpected token: {% (expecting when, else or end) when {{ klass . id }} p \"is {{klass}}\" {% end %} end Notice that case is not within the macro. The code generated by the macro consists solely of two when expressions which, by themselves, is not valid Crystal code. We must include case within the macro in order to make it valid by using begin and end : {% begin %} case 42 {% for klass in [ Int32 , String ] %} when {{ klass . id }} p \"is {{klass}}\" {% end %} end {% end %}","title":"Macros"},{"location":"syntax_and_semantics/macros/index.html#macros","text":"Macros are methods that receive AST nodes at compile-time and produce code that is pasted into a program. For example: macro define_method ( name , content ) def {{ name }} {{ content }} end end # This generates: # # def foo # 1 # end define_method foo , 1 foo # => 1 A macro's definition body looks like regular Crystal code with extra syntax to manipulate the AST nodes. The generated code must be valid Crystal code, meaning that you can't for example generate a def without a matching end , or a single when expression of a case , since both of them are not complete valid expressions. Refer to Pitfalls for more information.","title":"Macros"},{"location":"syntax_and_semantics/macros/index.html#scope","text":"Macros declared at the top-level are visible anywhere. If a top-level macro is marked as private it is only accessible in that file. They can also be defined in classes and modules, and are visible in those scopes. Macros are also looked-up in the ancestors chain (superclasses and included modules). For example, a block which is given an object to use as the default receiver by being invoked with with ... yield can access macros defined within that object's ancestors chain: class Foo macro emphasize ( value ) \"*** #{ {{ value }} } ***\" end def yield_with_self with self yield end end Foo . new . yield_with_self { emphasize ( 10 ) } # => \"***10***\" Macros defined in classes and modules can be invoked from outside of them too: class Foo macro emphasize ( value ) \"*** #{ {{ value }} } ***\" end end Foo . emphasize ( 10 ) # => \"***10***\"","title":"Scope"},{"location":"syntax_and_semantics/macros/index.html#interpolation","text":"You use {{...}} to paste, or interpolate, an AST node, as in the above example. Note that the node is pasted as-is. If in the previous example we pass a symbol, the generated code becomes invalid: # This generates: # # def :foo # 1 # end define_method :foo , 1 Note that :foo was the result of the interpolation, because that's what was passed to the macro. You can use the method ASTNode#id in these cases, where you just need an identifier.","title":"Interpolation"},{"location":"syntax_and_semantics/macros/index.html#macro-calls","text":"You can invoke a fixed subset of methods on AST nodes at compile-time. These methods are documented in a fictitious Crystal::Macros module. For example, invoking ASTNode#id in the above example solves the problem: macro define_method ( name , content ) def {{ name . id }} {{ content }} end end # This correctly generates: # # def foo # 1 # end define_method :foo , 1","title":"Macro calls"},{"location":"syntax_and_semantics/macros/index.html#modules-and-classes","text":"Modules, classes and structs can also be generated: macro define_class ( module_name , class_name , method , content ) module {{ module_name }} class {{ class_name }} def initialize ( @name : String ) end def {{ method }} {{ content }} + @name end end end end # This generates: # module Foo # class Bar # def initialize(@name : String) # end # # def say # \"hi \" + @name # end # end # end define_class Foo , Bar , say , \"hi \" p Foo :: Bar . new ( \"John\" ) . say # => \"hi John\"","title":"Modules and classes"},{"location":"syntax_and_semantics/macros/index.html#conditionals","text":"You use {% if condition %} ... {% end %} to conditionally generate code: macro define_method ( name , content ) def {{ name }} {% if content == 1 %} \"one\" {% elsif content == 2 %} \"two\" {% else %} {{ content }} {% end %} end end define_method foo , 1 define_method bar , 2 define_method baz , 3 foo # => one bar # => two baz # => 3 Similar to regular code, Nop , NilLiteral and a false BoolLiteral are considered falsey , while everything else is considered truthy . Macro conditionals can be used outside a macro definition: {% if env ( \"TEST\" ) %} puts \"We are in test mode\" {% end %}","title":"Conditionals"},{"location":"syntax_and_semantics/macros/index.html#iteration","text":"You can iterate a finite amount of times: macro define_constants ( count ) {% for i in ( 1 .. count ) %} PI_ {{ i . id }} = Math :: PI * {{ i }} {% end %} end define_constants ( 3 ) PI_1 # => 3.14159... PI_2 # => 6.28318... PI_3 # => 9.42477... To iterate an ArrayLiteral : macro define_dummy_methods ( names ) {% for name , index in names %} def {{ name . id }} {{ index }} end {% end %} end define_dummy_methods [ foo , bar , baz ] foo # => 0 bar # => 1 baz # => 2 The index variable in the above example is optional. To iterate a HashLiteral : macro define_dummy_methods ( hash ) {% for key , value in hash %} def {{ key . id }} {{ value }} end {% end %} end define_dummy_methods ({ foo : 10 , bar : 20 }) foo # => 10 bar # => 20 Macro iterations can be used outside a macro definition: {% for name , index in [ \"foo\" , \"bar\" , \"baz\" ] %} def {{ name . id }} {{ index }} end {% end %} foo # => 0 bar # => 1 baz # => 2","title":"Iteration"},{"location":"syntax_and_semantics/macros/index.html#variadic-arguments-and-splatting","text":"A macro can accept variadic arguments: macro define_dummy_methods ( * names ) {% for name , index in names %} def {{ name . id }} {{ index }} end {% end %} end define_dummy_methods foo , bar , baz foo # => 0 bar # => 1 baz # => 2 The arguments are packed into a TupleLiteral and passed to the macro. Additionally, using * when interpolating a TupleLiteral interpolates the elements separated by commas: macro println ( * values ) print {{ * values }} , '\\n' end println 1 , 2 , 3 # outputs 123\\n","title":"Variadic arguments and splatting"},{"location":"syntax_and_semantics/macros/index.html#type-information","text":"When a macro is invoked you can access the current scope, or type, with a special instance variable: @type . The type of this variable is TypeNode , which gives you access to type information at compile time. Note that @type is always the instance type, even when the macro is invoked in a class method. For example: macro add_describe_methods def describe \"Class is: \" + {{ @type . stringify }} end def self . describe \"Class is: \" + {{ @type . stringify }} end end class Foo add_describe_methods end Foo . new . describe # => \"Class is Foo\" Foo . describe # => \"Class is Foo\"","title":"Type information"},{"location":"syntax_and_semantics/macros/index.html#method-information","text":"When a macro is invoked you can access the method, the macro is in with a special instance variable: @def . The type of this variable is Def unless the macro is outside of a method, in this case it's NilLiteral . Example: module Foo def Foo . boo ( arg1 , arg2 ) {% @def . receiver %} # => Foo {% @def . name %} # => boo {% @def . args %} # => [arg1, arg2] end end Foo . boo ( 0 , 1 )","title":"Method information"},{"location":"syntax_and_semantics/macros/index.html#constants","text":"Macros can access constants. For example: VALUES = [ 1 , 2 , 3 ] {% for value in VALUES %} puts {{ value }} {% end %} If the constant denotes a type, you get back a TypeNode .","title":"Constants"},{"location":"syntax_and_semantics/macros/index.html#nested-macros","text":"It is possible to define a macro which generates one or more macro definitions. You must escape macro expressions of the inner macro by preceding them with a backslash character \"\\\" to prevent them from being evaluated by the outer macro. macro define_macros ( * names ) {% for name in names %} macro greeting_for_ {{ name . id }} ( greeting ) \\ {% if greeting == \"hola\" %} \"\u00a1hola {{name.id}}!\" \\ {% else %} \"\\{{greeting.id}} {{name.id}}\" \\ {% end %} end {% end %} end # This generates: # # macro greeting_for_alice # {% if greeting == \"hola\" %} # \"\u00a1hola alice!\" # {% else %} # \"{{greeting.id}} alice\" # {% end %} # end # macro greeting_for_bob # {% if greeting == \"hola\" %} # \"\u00a1hola bob!\" # {% else %} # \"{{greeting.id}} bob\" # {% end %} # end define_macros alice , bob greeting_for_alice \"hello\" # => \"hello alice\" greeting_for_bob \"hallo\" # => \"hallo bob\" greeting_for_alice \"hej\" # => \"hej alice\" greeting_for_bob \"hola\" # => \"\u00a1hola bob!\"","title":"Nested macros"},{"location":"syntax_and_semantics/macros/index.html#verbatim","text":"Another way to define a nested macro is by using the special verbatim call. Using this you will not be able to use any variable interpolation but will not need to escape the inner macro characters. macro define_macros ( * names ) {% for name in names %} macro greeting_for_ {{ name . id }} ( greeting ) # name will not be available within the verbatim block \\ {% name = {{ name . stringify }} %} {% verbatim do %} {% if greeting == \"hola\" %} \"\u00a1hola {{name.id}}!\" {% else %} \"{{greeting.id}} {{name.id}}\" {% end %} {% end %} end {% end %} end # This generates: # # macro greeting_for_alice # {% name = \"alice\" %} # {% if greeting == \"hola\" %} # \"\u00a1hola alice!\" # {% else %} # \"{{greeting.id}} alice\" # {% end %} # end # macro greeting_for_bob # {% name = \"bob\" %} # {% if greeting == \"hola\" %} # \"\u00a1hola bob!\" # {% else %} # \"{{greeting.id}} bob\" # {% end %} # end define_macros alice , bob greeting_for_alice \"hello\" # => \"hello alice\" greeting_for_bob \"hallo\" # => \"hallo bob\" greeting_for_alice \"hej\" # => \"hej alice\" greeting_for_bob \"hola\" # => \"\u00a1hola bob!\" Notice the variables in the inner macro are not available within the verbatim block. The contents of the block are transferred \"as is\", essentially as a string, until re-examined by the compiler.","title":"verbatim"},{"location":"syntax_and_semantics/macros/index.html#comments","text":"Macro expressions are evaluated both within comments as well as compilable sections of code. This may be used to provide relevant documentation for expansions: {% for name , index in [ \"foo\" , \"bar\" , \"baz\" ] %} # Provides a placeholder {{name.id}} method. Always returns {{index}}. def {{ name . id }} {{ index }} end {% end %} This evaluation applies to both interpolation and directives. As a result of this, macros cannot be commented out. macro a # {% if false %} puts 42 # {% end %} end a The expression above will result in no output.","title":"Comments"},{"location":"syntax_and_semantics/macros/index.html#pitfalls","text":"When writing macros (especially outside of a macro definition) it is important to remember that the generated code from the macro must be valid Crystal code by itself even before it is merged into the main program's code. This means, for example, a macro cannot generate a one or more when expressions of a case statement unless case was a part of the generated code. Here is an example of such an invalid macro: case 42 {% for klass in [ Int32 , String ] %} # Syntax Error: unexpected token: {% (expecting when, else or end) when {{ klass . id }} p \"is {{klass}}\" {% end %} end Notice that case is not within the macro. The code generated by the macro consists solely of two when expressions which, by themselves, is not valid Crystal code. We must include case within the macro in order to make it valid by using begin and end : {% begin %} case 42 {% for klass in [ Int32 , String ] %} when {{ klass . id }} p \"is {{klass}}\" {% end %} end {% end %}","title":"Pitfalls"},{"location":"syntax_and_semantics/macros/fresh_variables.html","text":"Fresh variables \u00b6 Once macros generate code, they are parsed with a regular Crystal parser where local variables in the context of the macro invocations are assumed to be defined. This is better understood with an example: macro update_x x = 1 end x = 0 update_x x # => 1 This can sometimes be useful to avoid repetitive code by deliberately reading/writing local variables, but can also overwrite local variables by mistake. To avoid this, fresh variables can be declared with %name : macro dont_update_x % x = 1 puts % x end x = 0 dont_update_x # outputs 1 x # => 0 Using %x in the above example, we declare a variable whose name is guaranteed not to conflict with local variables in the current scope. Additionally, fresh variables with respect to some other AST node can be declared with %var{key1, key2, ..., keyN} . For example: macro fresh_vars_sample ( * names ) # First declare vars {% for name , index in names %} print \"Declaring: \" , \"%name{index}\" , '\\n' % name { index } = {{ index }} {% end %} # Then print them {% for name , index in names %} print \"%name{index}: \" , % name { index }, '\\n' {% end %} end fresh_vars_sample a , b , c # Sample output: # Declaring: __temp_255 # Declaring: __temp_256 # Declaring: __temp_257 # __temp_255: 0 # __temp_256: 1 # __temp_257: 2 In the above example, three indexed variables are declared, assigned values, and then printed, displaying their corresponding indices.","title":"Fresh variables"},{"location":"syntax_and_semantics/macros/fresh_variables.html#fresh-variables","text":"Once macros generate code, they are parsed with a regular Crystal parser where local variables in the context of the macro invocations are assumed to be defined. This is better understood with an example: macro update_x x = 1 end x = 0 update_x x # => 1 This can sometimes be useful to avoid repetitive code by deliberately reading/writing local variables, but can also overwrite local variables by mistake. To avoid this, fresh variables can be declared with %name : macro dont_update_x % x = 1 puts % x end x = 0 dont_update_x # outputs 1 x # => 0 Using %x in the above example, we declare a variable whose name is guaranteed not to conflict with local variables in the current scope. Additionally, fresh variables with respect to some other AST node can be declared with %var{key1, key2, ..., keyN} . For example: macro fresh_vars_sample ( * names ) # First declare vars {% for name , index in names %} print \"Declaring: \" , \"%name{index}\" , '\\n' % name { index } = {{ index }} {% end %} # Then print them {% for name , index in names %} print \"%name{index}: \" , % name { index }, '\\n' {% end %} end fresh_vars_sample a , b , c # Sample output: # Declaring: __temp_255 # Declaring: __temp_256 # Declaring: __temp_257 # __temp_255: 0 # __temp_256: 1 # __temp_257: 2 In the above example, three indexed variables are declared, assigned values, and then printed, displaying their corresponding indices.","title":"Fresh variables"},{"location":"syntax_and_semantics/macros/hooks.html","text":"Hooks \u00b6 Special macros exist that are invoked in some situations as hooks, at compile time: inherited is invoked when a subclass is defined. @type is the inheriting type. included is invoked when a module is included. @type is the including type. extended is invoked when a module is extended. @type is the extending type. method_missing is invoked when a method is not found. method_added is invoked when a new method is defined in the current scope. finished is invoked after instance variable types for all classes are known. Example of inherited : class Parent macro inherited def lineage \"{{@type.name.id}} < Parent\" end end end class Child < Parent end Child . new . lineage # => \"Child < Parent\" Example of method_missing : macro method_missing ( call ) print \"Got \" , {{ call . name . id . stringify }} , \" with \" , {{ call . args . size }} , \" arguments\" , '\\n' end foo # Prints: Got foo with 0 arguments bar 'a' , 'b' # Prints: Got bar with 2 arguments Example of method_added : macro method_added ( method ) {% puts \"Method added:\" , method . name . stringify %} end def generate_random_number 4 end # => Method added: generate_random_number Both method_missing and method_added only apply to calls or methods in the same class that the macro is defined in, or only in the top level if the macro is defined outside of a class. For example: macro method_missing ( call ) puts \"In outer scope, got call: \" , {{ call . name . stringify }} end class SomeClass macro method_missing ( call ) puts \"Inside SomeClass, got call: \" , {{ call . name . stringify }} end end class OtherClass end # This call is handled by the top-level `method_missing` foo # => In outer scope, got call: foo obj = SomeClass . new # This is handled by the one inside SomeClass obj . bar # => Inside SomeClass, got call: bar other = OtherClass . new # Neither OtherClass or its parents define a `method_missing` macro other . baz # => Error: Undefined method 'baz' for OtherClass finished is called once a type has been completely defined - this includes extensions on that class. Consider the following program: macro print_methods {% puts @type . methods . map &. name %} end class Foo macro finished {% puts @type . methods . map &. name %} end print_methods end class Foo def bar puts \"I'm a method!\" end end Foo . new . bar The print_methods macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of Foo is compiled the finished macro will be run, which will print [bar] .","title":"Hooks"},{"location":"syntax_and_semantics/macros/hooks.html#hooks","text":"Special macros exist that are invoked in some situations as hooks, at compile time: inherited is invoked when a subclass is defined. @type is the inheriting type. included is invoked when a module is included. @type is the including type. extended is invoked when a module is extended. @type is the extending type. method_missing is invoked when a method is not found. method_added is invoked when a new method is defined in the current scope. finished is invoked after instance variable types for all classes are known. Example of inherited : class Parent macro inherited def lineage \"{{@type.name.id}} < Parent\" end end end class Child < Parent end Child . new . lineage # => \"Child < Parent\" Example of method_missing : macro method_missing ( call ) print \"Got \" , {{ call . name . id . stringify }} , \" with \" , {{ call . args . size }} , \" arguments\" , '\\n' end foo # Prints: Got foo with 0 arguments bar 'a' , 'b' # Prints: Got bar with 2 arguments Example of method_added : macro method_added ( method ) {% puts \"Method added:\" , method . name . stringify %} end def generate_random_number 4 end # => Method added: generate_random_number Both method_missing and method_added only apply to calls or methods in the same class that the macro is defined in, or only in the top level if the macro is defined outside of a class. For example: macro method_missing ( call ) puts \"In outer scope, got call: \" , {{ call . name . stringify }} end class SomeClass macro method_missing ( call ) puts \"Inside SomeClass, got call: \" , {{ call . name . stringify }} end end class OtherClass end # This call is handled by the top-level `method_missing` foo # => In outer scope, got call: foo obj = SomeClass . new # This is handled by the one inside SomeClass obj . bar # => Inside SomeClass, got call: bar other = OtherClass . new # Neither OtherClass or its parents define a `method_missing` macro other . baz # => Error: Undefined method 'baz' for OtherClass finished is called once a type has been completely defined - this includes extensions on that class. Consider the following program: macro print_methods {% puts @type . methods . map &. name %} end class Foo macro finished {% puts @type . methods . map &. name %} end print_methods end class Foo def bar puts \"I'm a method!\" end end Foo . new . bar The print_methods macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of Foo is compiled the finished macro will be run, which will print [bar] .","title":"Hooks"},{"location":"syntax_and_semantics/macros/macro_methods.html","text":"Macro methods \u00b6 Macro defs allow you to define a method for a class hierarchy which is then instantiated for each concrete subtype. A def is implicitly considered a macro def if it contains a macro expression which refers to @type . For example: class Object def instance_vars_names {{ @type . instance_vars . map &. name . stringify }} end end class Person def initialize ( @name : String , @age : Int32 ) end end person = Person . new \"John\" , 30 person . instance_vars_names # => [\"name\", \"age\"] In macro definitions, arguments are passed as their AST nodes, giving you access to them in macro expansions ( {{some_macro_argument}} ). However that is not true for macro defs. Here the parameter list is that of the method generated by the macro def. You cannot access the call arguments during compile-time. class Object def has_instance_var? ( name ) : Bool # We cannot access name inside the macro expansion here, # instead we need to use the macro language to construct an array # and do the inclusion check at runtime. {{ @type . instance_vars . map &. name . stringify }} . includes? name end end person = Person . new \"John\" , 30 person . has_instance_var? ( \"name\" ) # => true person . has_instance_var? ( \"birthday\" ) # => false","title":"Macro methods"},{"location":"syntax_and_semantics/macros/macro_methods.html#macro-methods","text":"Macro defs allow you to define a method for a class hierarchy which is then instantiated for each concrete subtype. A def is implicitly considered a macro def if it contains a macro expression which refers to @type . For example: class Object def instance_vars_names {{ @type . instance_vars . map &. name . stringify }} end end class Person def initialize ( @name : String , @age : Int32 ) end end person = Person . new \"John\" , 30 person . instance_vars_names # => [\"name\", \"age\"] In macro definitions, arguments are passed as their AST nodes, giving you access to them in macro expansions ( {{some_macro_argument}} ). However that is not true for macro defs. Here the parameter list is that of the method generated by the macro def. You cannot access the call arguments during compile-time. class Object def has_instance_var? ( name ) : Bool # We cannot access name inside the macro expansion here, # instead we need to use the macro language to construct an array # and do the inclusion check at runtime. {{ @type . instance_vars . map &. name . stringify }} . includes? name end end person = Person . new \"John\" , 30 person . has_instance_var? ( \"name\" ) # => true person . has_instance_var? ( \"birthday\" ) # => false","title":"Macro methods"},{"location":"the_shards_command/index.html","text":"The shards command \u00b6 Crystal is typically accompanied by Shards, its dependency manager. It manages dependencies for Crystal projects and libraries with reproducible installs across computers and systems. Installation \u00b6 Shards is usually distributed with Crystal itself. Alternatively, a separate shards package may be available for your system. To install from source, download or clone the repository and run make CRFLAGS=--release . The compiled binary is in bin/shards and should be added to PATH . Usage \u00b6 shards requires the presence of a shard.yml file in the project folder (working directory). This file describes the project and lists dependencies that are required to build it. A default file can be created by running shards init . The file's contents are explained in the Writing a Shard guide and a detailed description of the file format is provided by the shard.yml specification . Running shards install resolves and installs the specified dependencies. The installed versions are written into a shard.lock file for using the exact same dependency versions when running shards install again. If your shard builds an application, both shard.yml and shard.lock should be checked into version control to provide reproducible dependency installs. If it is only a library for other shards to depend on, shard.lock should not be checked in, only shard.yml . It's good advice to add it to .gitignore (the crystal init does this automatically when initializing a lib repository). Shards commands \u00b6 shards [ <options>... ] [ <command> ] If no command is given, install will be run by default. shards build : Builds an executable shards check : Verifies dependencies are installed shards init : Generates a new shard.yml shards install : Resolves and installs dependencies shards list : Lists installed dependencies shards prune : Removes unused dependencies shards update : Resolves and updates dependencies shards version : Shows version of a shard To see the available options for a particular command, use --help after a command. Common options: --version : Prints the version of shards . -h, --help : Prints usage synopsis. --no-color : Disabled colored output. --production : Runs in release mode. Development dependencies won't be installed and only locked dependencies will be installed. Commands will fail if dependencies in shard.yml and shard.lock are out of sync (used by install , update , check and list command) -q, --quiet : Decreases the log verbosity, printing only warnings and errors. -v, --verbose : Increases the log verbosity, printing all debug statements. shards build \u00b6 shards build [ <targets> ] [ <options>... ] Builds the specified targets in bin path. If no targets are specified, all are built. This command ensures all dependencies are installed, so it is not necessary to run shards install before. All options following the command are delegated to crystal build . shards check \u00b6 shards check Verifies that all dependencies are installed and requirements are satisfied. Exit status: 0 : Dependencies are satisfied. 1 : Dependencies are not satisfied. shards init \u00b6 shards init Initializes a shard folder and creates a shard.yml . shards install \u00b6 shards install Resolves and installs dependencies into the lib folder. If not already present, generates a shard.lock file from resolved dependencies, locking version numbers or Git commits. Reads and enforces locked versions and commits if a shard.lock file is present. The install command may fail if a locked version doesn't match a requirement, but may succeed if a new dependency was added, as long as it doesn't generate a conflict, thus generating a new shard.lock file. shards list \u00b6 shards list Lists the installed dependencies and their versions. shards prune \u00b6 shards prune Removes unused dependencies from lib folder. shards update \u00b6 shards update Resolves and updates all dependencies into the lib folder again, whatever the locked versions and commits in the shard.lock file. Eventually generates a new shard.lock file. shards version \u00b6 shards version [ <path> ] Prints the version of the shard.","title":"The shards command"},{"location":"the_shards_command/index.html#the-shards-command","text":"Crystal is typically accompanied by Shards, its dependency manager. It manages dependencies for Crystal projects and libraries with reproducible installs across computers and systems.","title":"The shards command"},{"location":"the_shards_command/index.html#installation","text":"Shards is usually distributed with Crystal itself. Alternatively, a separate shards package may be available for your system. To install from source, download or clone the repository and run make CRFLAGS=--release . The compiled binary is in bin/shards and should be added to PATH .","title":"Installation"},{"location":"the_shards_command/index.html#usage","text":"shards requires the presence of a shard.yml file in the project folder (working directory). This file describes the project and lists dependencies that are required to build it. A default file can be created by running shards init . The file's contents are explained in the Writing a Shard guide and a detailed description of the file format is provided by the shard.yml specification . Running shards install resolves and installs the specified dependencies. The installed versions are written into a shard.lock file for using the exact same dependency versions when running shards install again. If your shard builds an application, both shard.yml and shard.lock should be checked into version control to provide reproducible dependency installs. If it is only a library for other shards to depend on, shard.lock should not be checked in, only shard.yml . It's good advice to add it to .gitignore (the crystal init does this automatically when initializing a lib repository).","title":"Usage"},{"location":"the_shards_command/index.html#shards-commands","text":"shards [ <options>... ] [ <command> ] If no command is given, install will be run by default. shards build : Builds an executable shards check : Verifies dependencies are installed shards init : Generates a new shard.yml shards install : Resolves and installs dependencies shards list : Lists installed dependencies shards prune : Removes unused dependencies shards update : Resolves and updates dependencies shards version : Shows version of a shard To see the available options for a particular command, use --help after a command. Common options: --version : Prints the version of shards . -h, --help : Prints usage synopsis. --no-color : Disabled colored output. --production : Runs in release mode. Development dependencies won't be installed and only locked dependencies will be installed. Commands will fail if dependencies in shard.yml and shard.lock are out of sync (used by install , update , check and list command) -q, --quiet : Decreases the log verbosity, printing only warnings and errors. -v, --verbose : Increases the log verbosity, printing all debug statements.","title":"Shards commands"},{"location":"the_shards_command/index.html#shards-build","text":"shards build [ <targets> ] [ <options>... ] Builds the specified targets in bin path. If no targets are specified, all are built. This command ensures all dependencies are installed, so it is not necessary to run shards install before. All options following the command are delegated to crystal build .","title":"shards build"},{"location":"the_shards_command/index.html#shards-check","text":"shards check Verifies that all dependencies are installed and requirements are satisfied. Exit status: 0 : Dependencies are satisfied. 1 : Dependencies are not satisfied.","title":"shards check"},{"location":"the_shards_command/index.html#shards-init","text":"shards init Initializes a shard folder and creates a shard.yml .","title":"shards init"},{"location":"the_shards_command/index.html#shards-install","text":"shards install Resolves and installs dependencies into the lib folder. If not already present, generates a shard.lock file from resolved dependencies, locking version numbers or Git commits. Reads and enforces locked versions and commits if a shard.lock file is present. The install command may fail if a locked version doesn't match a requirement, but may succeed if a new dependency was added, as long as it doesn't generate a conflict, thus generating a new shard.lock file.","title":"shards install"},{"location":"the_shards_command/index.html#shards-list","text":"shards list Lists the installed dependencies and their versions.","title":"shards list"},{"location":"the_shards_command/index.html#shards-prune","text":"shards prune Removes unused dependencies from lib folder.","title":"shards prune"},{"location":"the_shards_command/index.html#shards-update","text":"shards update Resolves and updates all dependencies into the lib folder again, whatever the locked versions and commits in the shard.lock file. Eventually generates a new shard.lock file.","title":"shards update"},{"location":"the_shards_command/index.html#shards-version","text":"shards version [ <path> ] Prints the version of the shard.","title":"shards version"},{"location":"tutorials/index.html","text":"","title":"Tutorials"},{"location":"using_the_compiler/index.html","text":"Using the compiler \u00b6 Compiling and running at once \u00b6 To compile and run a program in a single shot, invoke crystal run with a single filename: $ echo 'puts \"Hello World!\"' > hello_world.cr $ crystal run hello_world.cr Hello World! The run command compiles the source file hello_world.cr to a binary executable in a temporary location and immediately executes it. Creating an executable \u00b6 The crystal build command builds a binary executable. The output file has the same name as the source file minus the extension .cr . $ crystal build hello_world.cr $ ./hello_world Hello World! Release builds \u00b6 By default, the generated executables are not fully optimized. The --release flag can be used to enable optimizations. $ crystal build hello_world.cr --release Compiling without release mode is much faster and the resulting binaries still offer pretty good performance. Building in release mode should be used for production-ready executables and when performing benchmarks. For simple development builds, there is usually no reason to do so. To reduce the binary size for distributable files, the --no-debug flag can be used. This removes debug symbols reducing file size, but obviously making debugging more difficult. Creating a statically-linked executable \u00b6 The --static flag can be used to build a statically-linked executable: $ crystal build hello_world.cr --release --static Note Building fully statical linked executables is currently only supported on Alpine Linux. More information about statically linking can be found in the Static Linking guide . The compiler uses the CRYSTAL_LIBRARY_PATH environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries. Creating a Crystal project \u00b6 The crystal init command helps to initialize a Crystal project folder, setting up a basic project structure. crystal init app <name> is used for an application, crystal init lib <name> for a library. $ crystal init app myapp create myapp/.gitignore create myapp/.editorconfig create myapp/LICENSE create myapp/README.md create myapp/.travis.yml create myapp/shard.yml create myapp/src/myapp.cr create myapp/src/myapp/version.cr create myapp/spec/spec_helper.cr create myapp/spec/myapp_spec.cr Initialized empty Git repository in /home/crystal/myapp/.git/ Not all of these files are required for every project, and some might need more customization, but crystal init creates a good default environment for developing Crystal applications and libraries. Compiler commands \u00b6 crystal init : generate a new project crystal build : build an executable crystal docs : generate documentation crystal env : print Crystal environment information crystal eval : eval code from args or standard input crystal play : starts crystal playground server crystal run : build and run program crystal spec : build and run specs crystal tool : run a compiler tool crystal help : show help about commands and options crystal version : show version To see the available options for a particular command, use --help after a command: crystal run \u00b6 The run command compiles a source file to a binary executable and immediately runs it. crystal [run] [<options>] <programfile> [-- <argument>...] Arguments to the compiled binary can be separated with double dash -- from the compiler arguments. The binary executable is stored in a temporary location between compiling and running. Example: $ echo 'puts \"Hello #{ARGV[0]?}!\"' > hello_world.cr $ crystal run hello_world.cr -- Crystal Hello Crystal! Common options: --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --progress : Show progress during compilation. --static : Link statically. More options are described in the integrated help: crystal run --help or man page man crystal . crystal build \u00b6 The crystal build command builds a dynamically-linked binary executable. crystal build [<options>] <programfile> Unless specified, the resulting binary will have the same name as the source file minus the extension .cr . Example: $ echo 'puts \"Hello #{ARGV[0]?}!\"' > hello_world.cr $ crystal build hello_world.cr $ ./hello_world Crystal Hello Crystal! Common options: --cross-compile : Generate a .o file, and print the command to generate an executable to stdout. -D FLAG, --define FLAG : Define a compile-time flag. -o <output_file> : Define the name of the binary executable. --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --link-flags FLAGS : Additional flags to pass to the linker. --lto=thin : Use ThinLTO, improving performance on release builds. --no-debug : Skip any symbolic debug info, reducing the output file size. --progress : Show progress during compilation. --static : Link statically. --verbose : Display executed commands. More options are described in the integrated help: crystal build --help or man page man crystal . crystal eval \u00b6 The crystal eval command reads Crystal source code from command line or stdin, compiles it to a binary executable and immediately runs it. crystal eval [<options>] [<source>] If no source argument is provided, the Crystal source is read from standard input. The binary executable is stored in a temporary location between compiling and running. Example: $ crystal eval 'puts \"Hello World\"' Hello World! $ echo 'puts \"Hello World\"' | crystal eval Hello World! Note When running interactively, stdin can usually be closed by typing the end of transmission character ( Ctrl+D ). Common options: -o <output_file> : Define the name of the binary executable. --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --lto=thin : Use ThinLTO, improves performance. --no-debug : Skip any symbolic debug info, reducing the output file size. --progress : Show progress during compilation. --static : Link statically. More options are described in the integrated help: crystal eval --help or man page man crystal . crystal version \u00b6 The crystal version command prints the Crystal version, LLVM version and default target triple. crystal version Example: $ crystal version Crystal 0.25.1 [b782738ff] (2018-06-27) LLVM: 4.0.0 Default target: x86_64-unknown-linux-gnu crystal init \u00b6 The crystal init command initializes a Crystal project folder. crystal init (lib|app) <name> [<dir>] The first argument is either lib or app . A lib is a reusable library whereas app describes an application not intended to be used as a dependency. A library doesn't have a shard.lock file in its repository and no build target in shard.yml , but instructions for using it as a dependency. Example: $ crystal init lib my_cool_lib create my_cool_lib/.gitignore create my_cool_lib/.editorconfig create my_cool_lib/LICENSE create my_cool_lib/README.md create my_cool_lib/.travis.yml create my_cool_lib/shard.yml create my_cool_lib/src/my_cool_lib.cr create my_cool_lib/spec/spec_helper.cr create my_cool_lib/spec/my_cool_lib_spec.cr Initialized empty Git repository in ~/my_cool_lib/.git/ crystal docs \u00b6 The crystal docs command generates API documentation from inline docstrings in Crystal files (see Documenting Code ). crystal docs [ --output = <output_dir> ] [ --canonical-base-url = <url> ] [ <source_file>... ] The command creates a static website in output_dir (default ./docs ), consisting of HTML files for each Crystal type, in a folder structure mirroring the Crystal namespaces. The entrypoint docs/index.html can be opened by any web browser. The entire API docs are also stored as a JSON document in $output_dir/index.json . By default, all Crystal files in ./src will be appended (i.e. src/**/*.cr ). In order to account for load-order dependencies, source_file can be used to specify one (or multiple) entrypoints for the docs generator. crystal docs src/my_app.cr Common options: --project-name=NAME : Set the project name. The default value is extracted from shard.yml if available. In case no default can be found, this option is mandatory. --project-version=VERSION : Set the project version. The default value is extracted from current git commit or shard.yml if available. In case no default can be found, this option is mandatory. --output=DIR, -o DIR : Set the output directory (default: ./docs ) --canonical-base-url=URL, -b URL : Set the canonical base url For the above example to output the docs at public with custom canonical base url, and entrypoint src/my_app.cr , the following arguments can be used: crystal docs --output public --canonical-base-url http://example.com/ src/my_app.cr crystal env \u00b6 The crystal env command prints environment variables used by Crystal. crystal env [ <var>... ] By default, it prints information as a shell script. If one or more var arguments are provided, the value of each named variable is printed on its own line. Example: $ crystal env CRYSTAL_CACHE_DIR=\"/home/crystal/.cache/crystal\" CRYSTAL_PATH=\"/usr/bin/../share/crystal/src:lib\" CRYSTAL_VERSION=\"0.28.0\" CRYSTAL_LIBRARY_PATH=\"/usr/bin/../lib/crystal/lib\" $ crystal env CRYSTAL_VERSION 0.28.0 crystal spec \u00b6 The crystal spec command compiles and runs a Crystal spec suite. crystal spec [<options>] [<file>...] [-- [<runner_options>]] All files arguments are concatenated into a single Crystal source. If an argument points to a folder, all spec files inside that folder are appended. If no files argument is provided, the default is ./spec . A filename can be suffixed by : and a line number, providing this location to the --location runner option (see below). Run crystal spec --options for available options. Runner options: runner_options are provided to the compiled binary executable which runs the specs. They should be separated from the other arguments by a double dash ( -- ). --verbose : Prints verbose output, including all example names. --profile : Prints the 10 slowest specs. --fail-fast : Abort the spec run on first failure. --junit_output <output_dir> : Generates JUnit XML output. The following options can be combined to filter the list of specs to run. --example <name> : Runs examples whose full nested names include name . --line <line> : Runs examples whose line matches line . --location <file>:<line> : Runs example(s) at line in file (multiple options allowed). --tag <tag> : Runs examples with the specified tag, or excludes examples by adding ~ before the tag (multiple options allowed). --tag a --tag b will include specs tagged with a OR b . --tag ~a --tag ~b will include specs not tagged with a AND not tagged with b . --tag a --tag ~b will include specs tagged with a , but not tagged with b Example: $ crystal spec F Failures: 1) Myapp works Failure/Error: false.should eq(true) Expected: true got: false # spec/myapp_spec.cr:7 Finished in 880 microseconds 1 examples, 1 failures, 0 errors, 0 pending Failed examples: crystal spec spec/myapp_spec.cr:6 # Myapp works crystal play \u00b6 The crystal play command starts a webserver serving an interactive Crystal playground. crystal play [--port <port>] [--binding <host>] [--verbose] [file] crystal tool \u00b6 crystal tool context : Show context for given location crystal tool expand : Show macro expansion for given location crystal tool format : Format Crystal files crystal tool hierarchy : Show type hierarchy crystal tool implementations : Show implementations for given call in location crystal tool types : Show types of main variables crystal tool format \u00b6 The crystal tool format command applies default format to Crystal source files. crystal tool format [--check] [<path>...] path can be a file or folder name and include all Crystal files in that folder tree. Omitting path is equal to specifying the current working directory. The formatter also applies to Crystal code blocks in comments (see Documenting Code ). Environment variables \u00b6 The following environment variables are used by the Crystal compiler if set in the environment. Otherwise the compiler will populate them with default values. Their values can be inspected using crystal env . CRYSTAL_CACHE_DIR : Defines path where Crystal caches partial compilation results for faster subsequent builds. This path is also used to temporarily store executables when Crystal programs are run with crystal run rather than crystal build . Default value is the first directory that either exists or can be created of ${XDG_CACHE_HOME}/crystal (if XDG_CACHE_HOME is defined), ${HOME}/.cache/crystal , ${HOME}/.crystal , ./.crystal . If CRYSTAL_CACHE_DIR is set but points to a path that is not writeable, the default values are used instead. CRYSTAL_PATH : Defines paths where Crystal searches for required files. CRYSTAL_VERSION is only available as output of crystal env . The compiler neither sets nor reads it. CRYSTAL_LIBRARY_PATH : The compiler uses the paths in this variable as a first lookup destination for static and dynamic libraries that are to be linked. For example, if static libraries are put in build/libs , setting the environment variable accordingly will tell the compiler to look for libraries there.","title":"Using the compiler"},{"location":"using_the_compiler/index.html#using-the-compiler","text":"","title":"Using the compiler"},{"location":"using_the_compiler/index.html#compiling-and-running-at-once","text":"To compile and run a program in a single shot, invoke crystal run with a single filename: $ echo 'puts \"Hello World!\"' > hello_world.cr $ crystal run hello_world.cr Hello World! The run command compiles the source file hello_world.cr to a binary executable in a temporary location and immediately executes it.","title":"Compiling and running at once"},{"location":"using_the_compiler/index.html#creating-an-executable","text":"The crystal build command builds a binary executable. The output file has the same name as the source file minus the extension .cr . $ crystal build hello_world.cr $ ./hello_world Hello World!","title":"Creating an executable"},{"location":"using_the_compiler/index.html#release-builds","text":"By default, the generated executables are not fully optimized. The --release flag can be used to enable optimizations. $ crystal build hello_world.cr --release Compiling without release mode is much faster and the resulting binaries still offer pretty good performance. Building in release mode should be used for production-ready executables and when performing benchmarks. For simple development builds, there is usually no reason to do so. To reduce the binary size for distributable files, the --no-debug flag can be used. This removes debug symbols reducing file size, but obviously making debugging more difficult.","title":"Release builds"},{"location":"using_the_compiler/index.html#creating-a-statically-linked-executable","text":"The --static flag can be used to build a statically-linked executable: $ crystal build hello_world.cr --release --static Note Building fully statical linked executables is currently only supported on Alpine Linux. More information about statically linking can be found in the Static Linking guide . The compiler uses the CRYSTAL_LIBRARY_PATH environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries.","title":"Creating a statically-linked executable"},{"location":"using_the_compiler/index.html#creating-a-crystal-project","text":"The crystal init command helps to initialize a Crystal project folder, setting up a basic project structure. crystal init app <name> is used for an application, crystal init lib <name> for a library. $ crystal init app myapp create myapp/.gitignore create myapp/.editorconfig create myapp/LICENSE create myapp/README.md create myapp/.travis.yml create myapp/shard.yml create myapp/src/myapp.cr create myapp/src/myapp/version.cr create myapp/spec/spec_helper.cr create myapp/spec/myapp_spec.cr Initialized empty Git repository in /home/crystal/myapp/.git/ Not all of these files are required for every project, and some might need more customization, but crystal init creates a good default environment for developing Crystal applications and libraries.","title":"Creating a Crystal project"},{"location":"using_the_compiler/index.html#compiler-commands","text":"crystal init : generate a new project crystal build : build an executable crystal docs : generate documentation crystal env : print Crystal environment information crystal eval : eval code from args or standard input crystal play : starts crystal playground server crystal run : build and run program crystal spec : build and run specs crystal tool : run a compiler tool crystal help : show help about commands and options crystal version : show version To see the available options for a particular command, use --help after a command:","title":"Compiler commands"},{"location":"using_the_compiler/index.html#crystal-run","text":"The run command compiles a source file to a binary executable and immediately runs it. crystal [run] [<options>] <programfile> [-- <argument>...] Arguments to the compiled binary can be separated with double dash -- from the compiler arguments. The binary executable is stored in a temporary location between compiling and running. Example: $ echo 'puts \"Hello #{ARGV[0]?}!\"' > hello_world.cr $ crystal run hello_world.cr -- Crystal Hello Crystal! Common options: --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --progress : Show progress during compilation. --static : Link statically. More options are described in the integrated help: crystal run --help or man page man crystal .","title":"crystal run"},{"location":"using_the_compiler/index.html#crystal-build","text":"The crystal build command builds a dynamically-linked binary executable. crystal build [<options>] <programfile> Unless specified, the resulting binary will have the same name as the source file minus the extension .cr . Example: $ echo 'puts \"Hello #{ARGV[0]?}!\"' > hello_world.cr $ crystal build hello_world.cr $ ./hello_world Crystal Hello Crystal! Common options: --cross-compile : Generate a .o file, and print the command to generate an executable to stdout. -D FLAG, --define FLAG : Define a compile-time flag. -o <output_file> : Define the name of the binary executable. --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --link-flags FLAGS : Additional flags to pass to the linker. --lto=thin : Use ThinLTO, improving performance on release builds. --no-debug : Skip any symbolic debug info, reducing the output file size. --progress : Show progress during compilation. --static : Link statically. --verbose : Display executed commands. More options are described in the integrated help: crystal build --help or man page man crystal .","title":"crystal build"},{"location":"using_the_compiler/index.html#crystal-eval","text":"The crystal eval command reads Crystal source code from command line or stdin, compiles it to a binary executable and immediately runs it. crystal eval [<options>] [<source>] If no source argument is provided, the Crystal source is read from standard input. The binary executable is stored in a temporary location between compiling and running. Example: $ crystal eval 'puts \"Hello World\"' Hello World! $ echo 'puts \"Hello World\"' | crystal eval Hello World! Note When running interactively, stdin can usually be closed by typing the end of transmission character ( Ctrl+D ). Common options: -o <output_file> : Define the name of the binary executable. --release : Compile in release mode, doing extra work to apply optimizations to the generated code. --lto=thin : Use ThinLTO, improves performance. --no-debug : Skip any symbolic debug info, reducing the output file size. --progress : Show progress during compilation. --static : Link statically. More options are described in the integrated help: crystal eval --help or man page man crystal .","title":"crystal eval"},{"location":"using_the_compiler/index.html#crystal-version","text":"The crystal version command prints the Crystal version, LLVM version and default target triple. crystal version Example: $ crystal version Crystal 0.25.1 [b782738ff] (2018-06-27) LLVM: 4.0.0 Default target: x86_64-unknown-linux-gnu","title":"crystal version"},{"location":"using_the_compiler/index.html#crystal-init","text":"The crystal init command initializes a Crystal project folder. crystal init (lib|app) <name> [<dir>] The first argument is either lib or app . A lib is a reusable library whereas app describes an application not intended to be used as a dependency. A library doesn't have a shard.lock file in its repository and no build target in shard.yml , but instructions for using it as a dependency. Example: $ crystal init lib my_cool_lib create my_cool_lib/.gitignore create my_cool_lib/.editorconfig create my_cool_lib/LICENSE create my_cool_lib/README.md create my_cool_lib/.travis.yml create my_cool_lib/shard.yml create my_cool_lib/src/my_cool_lib.cr create my_cool_lib/spec/spec_helper.cr create my_cool_lib/spec/my_cool_lib_spec.cr Initialized empty Git repository in ~/my_cool_lib/.git/","title":"crystal init"},{"location":"using_the_compiler/index.html#crystal-docs","text":"The crystal docs command generates API documentation from inline docstrings in Crystal files (see Documenting Code ). crystal docs [ --output = <output_dir> ] [ --canonical-base-url = <url> ] [ <source_file>... ] The command creates a static website in output_dir (default ./docs ), consisting of HTML files for each Crystal type, in a folder structure mirroring the Crystal namespaces. The entrypoint docs/index.html can be opened by any web browser. The entire API docs are also stored as a JSON document in $output_dir/index.json . By default, all Crystal files in ./src will be appended (i.e. src/**/*.cr ). In order to account for load-order dependencies, source_file can be used to specify one (or multiple) entrypoints for the docs generator. crystal docs src/my_app.cr Common options: --project-name=NAME : Set the project name. The default value is extracted from shard.yml if available. In case no default can be found, this option is mandatory. --project-version=VERSION : Set the project version. The default value is extracted from current git commit or shard.yml if available. In case no default can be found, this option is mandatory. --output=DIR, -o DIR : Set the output directory (default: ./docs ) --canonical-base-url=URL, -b URL : Set the canonical base url For the above example to output the docs at public with custom canonical base url, and entrypoint src/my_app.cr , the following arguments can be used: crystal docs --output public --canonical-base-url http://example.com/ src/my_app.cr","title":"crystal docs"},{"location":"using_the_compiler/index.html#crystal-env","text":"The crystal env command prints environment variables used by Crystal. crystal env [ <var>... ] By default, it prints information as a shell script. If one or more var arguments are provided, the value of each named variable is printed on its own line. Example: $ crystal env CRYSTAL_CACHE_DIR=\"/home/crystal/.cache/crystal\" CRYSTAL_PATH=\"/usr/bin/../share/crystal/src:lib\" CRYSTAL_VERSION=\"0.28.0\" CRYSTAL_LIBRARY_PATH=\"/usr/bin/../lib/crystal/lib\" $ crystal env CRYSTAL_VERSION 0.28.0","title":"crystal env"},{"location":"using_the_compiler/index.html#crystal-spec","text":"The crystal spec command compiles and runs a Crystal spec suite. crystal spec [<options>] [<file>...] [-- [<runner_options>]] All files arguments are concatenated into a single Crystal source. If an argument points to a folder, all spec files inside that folder are appended. If no files argument is provided, the default is ./spec . A filename can be suffixed by : and a line number, providing this location to the --location runner option (see below). Run crystal spec --options for available options. Runner options: runner_options are provided to the compiled binary executable which runs the specs. They should be separated from the other arguments by a double dash ( -- ). --verbose : Prints verbose output, including all example names. --profile : Prints the 10 slowest specs. --fail-fast : Abort the spec run on first failure. --junit_output <output_dir> : Generates JUnit XML output. The following options can be combined to filter the list of specs to run. --example <name> : Runs examples whose full nested names include name . --line <line> : Runs examples whose line matches line . --location <file>:<line> : Runs example(s) at line in file (multiple options allowed). --tag <tag> : Runs examples with the specified tag, or excludes examples by adding ~ before the tag (multiple options allowed). --tag a --tag b will include specs tagged with a OR b . --tag ~a --tag ~b will include specs not tagged with a AND not tagged with b . --tag a --tag ~b will include specs tagged with a , but not tagged with b Example: $ crystal spec F Failures: 1) Myapp works Failure/Error: false.should eq(true) Expected: true got: false # spec/myapp_spec.cr:7 Finished in 880 microseconds 1 examples, 1 failures, 0 errors, 0 pending Failed examples: crystal spec spec/myapp_spec.cr:6 # Myapp works","title":"crystal spec"},{"location":"using_the_compiler/index.html#crystal-play","text":"The crystal play command starts a webserver serving an interactive Crystal playground. crystal play [--port <port>] [--binding <host>] [--verbose] [file]","title":"crystal play"},{"location":"using_the_compiler/index.html#crystal-tool","text":"crystal tool context : Show context for given location crystal tool expand : Show macro expansion for given location crystal tool format : Format Crystal files crystal tool hierarchy : Show type hierarchy crystal tool implementations : Show implementations for given call in location crystal tool types : Show types of main variables","title":"crystal tool"},{"location":"using_the_compiler/index.html#crystal-tool-format","text":"The crystal tool format command applies default format to Crystal source files. crystal tool format [--check] [<path>...] path can be a file or folder name and include all Crystal files in that folder tree. Omitting path is equal to specifying the current working directory. The formatter also applies to Crystal code blocks in comments (see Documenting Code ).","title":"crystal tool format"},{"location":"using_the_compiler/index.html#environment-variables","text":"The following environment variables are used by the Crystal compiler if set in the environment. Otherwise the compiler will populate them with default values. Their values can be inspected using crystal env . CRYSTAL_CACHE_DIR : Defines path where Crystal caches partial compilation results for faster subsequent builds. This path is also used to temporarily store executables when Crystal programs are run with crystal run rather than crystal build . Default value is the first directory that either exists or can be created of ${XDG_CACHE_HOME}/crystal (if XDG_CACHE_HOME is defined), ${HOME}/.cache/crystal , ${HOME}/.crystal , ./.crystal . If CRYSTAL_CACHE_DIR is set but points to a path that is not writeable, the default values are used instead. CRYSTAL_PATH : Defines paths where Crystal searches for required files. CRYSTAL_VERSION is only available as output of crystal env . The compiler neither sets nor reads it. CRYSTAL_LIBRARY_PATH : The compiler uses the paths in this variable as a first lookup destination for static and dynamic libraries that are to be linked. For example, if static libraries are put in build/libs , setting the environment variable accordingly will tell the compiler to look for libraries there.","title":"Environment variables"}]}